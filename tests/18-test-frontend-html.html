<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frontend Excel Export Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .container { max-width: 600px; margin: 0 auto; }
        button { padding: 10px 20px; margin: 10px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .log { background: #f8f9fa; border: 1px solid #dee2e6; padding: 15px; margin: 10px 0; border-radius: 4px; max-height: 300px; overflow-y: auto; font-family: monospace; white-space: pre-wrap; }
        input { padding: 8px; margin: 5px; border: 1px solid #ccc; border-radius: 4px; }
        .form-group { margin: 10px 0; }
        label { display: inline-block; width: 120px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Frontend Excel Export Test</h1>
        
        <div class="form-group">
            <label>From Date:</label>
            <input type="date" id="fromDate" value="2024-01-01">
        </div>
        
        <div class="form-group">
            <label>To Date:</label>
            <input type="date" id="toDate" value="2024-12-31">
        </div>
        
        <button onclick="testConnection()">Test Connection</button>
        <button onclick="testExcelExport()">Test Excel Export</button>
        <button onclick="clearLog()">Clear Log</button>
        
        <div id="log" class="log">Ready to test Excel export functionality...\n</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.0/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    
    <script>
        function log(message) {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logElement.textContent += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').textContent = 'Log cleared...\n';
        }

        // BackendExcelExportService implementation
        class BackendExcelExportService {
            static getApiUrl() {
                return 'http://localhost:14000/ketoan/listhoadon';
            }

            static normalizeDateString(dateStr) {
                if (!dateStr) return '';
                
                // If already in YYYY-MM-DD format, return as is
                if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                    return dateStr;
                }
                
                // Handle DD/MM/YYYY format
                if (/^\d{2}\/\d{2}\/\d{4}$/.test(dateStr)) {
                    const [day, month, year] = dateStr.split('/');
                    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                }
                
                return dateStr;
            }

            static async testConnection(baseUrl) {
                try {
                    const response = await axios.head(`${baseUrl}/ketoan/listhoadon/export-excel?fromDate=2024-01-01&toDate=2024-01-31`, { 
                        timeout: 5000
                    });
                    return response.status === 200;
                } catch (error) {
                    return false;
                }
            }

            static async checkServerConnection() {
                try {
                    const apiUrl = this.getApiUrl();
                    const baseUrl = apiUrl.replace('/ketoan/listhoadon', '');
                    
                    log(`üîç Checking server connection: ${baseUrl}`);
                    
                    // Test specific Excel export endpoint
                    try {
                        const exportTestResponse = await axios.head(`${baseUrl}/ketoan/listhoadon/export-excel?fromDate=2024-01-01&toDate=2024-01-31`, {
                            timeout: 5000
                        });
                        
                        if (exportTestResponse.status === 200) {
                            return {
                                connected: true,
                                url: baseUrl,
                                message: `Backend server connected on ${baseUrl} (Excel export endpoint working)`
                            };
                        }
                    } catch (exportError) {
                        log('Excel export endpoint test failed, trying health endpoint...');
                    }
                    
                    if (await this.testConnection(baseUrl)) {
                        return {
                            connected: true,
                            url: baseUrl,
                            message: `Backend server connected on ${baseUrl}`
                        };
                    }
                    
                    return {
                        connected: false,
                        message: 'Backend server kh√¥ng kh·∫£ d·ª•ng. Vui l√≤ng ki·ªÉm tra server c√≥ ƒëang ch·∫°y kh√¥ng.'
                    };
                    
                } catch (error) {
                    log(`‚ùå Connection check error: ${error.message}`);
                    return {
                        connected: false,
                        message: `L·ªói ki·ªÉm tra k·∫øt n·ªëi server: ${error.message}`
                    };
                }
            }

            static validateDateRange(fromDate, toDate) {
                if (!fromDate || !toDate) {
                    return { isValid: false, message: 'Vui l√≤ng ch·ªçn ng√†y b·∫Øt ƒë·∫ßu v√† ng√†y k·∫øt th√∫c' };
                }

                const normalizedFromDate = this.normalizeDateString(fromDate);
                const normalizedToDate = this.normalizeDateString(toDate);
                
                const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
                if (!dateRegex.test(normalizedFromDate) || !dateRegex.test(normalizedToDate)) {
                    return { isValid: false, message: 'ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá' };
                }

                const startDate = new Date(normalizedFromDate);
                const endDate = new Date(normalizedToDate);
                
                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                    return { isValid: false, message: 'Ng√†y kh√¥ng h·ª£p l·ªá' };
                }
                
                if (startDate > endDate) {
                    return { isValid: false, message: 'Ng√†y b·∫Øt ƒë·∫ßu ph·∫£i nh·ªè h∆°n ho·∫∑c b·∫±ng ng√†y k·∫øt th√∫c' };
                }
                
                return { isValid: true };
            }

            static async exportToExcel(fromDate, toDate) {
                try {
                    log('üîç Starting Excel export process...');
                    log(`üìÖ Date range: ${fromDate} to ${toDate}`);
                    
                    // Validate date range first
                    const validation = this.validateDateRange(fromDate, toDate);
                    if (!validation.isValid) {
                        alert(`‚ùå Validation Error: ${validation.message}`);
                        return;
                    }
                    
                    // Pre-check server connection
                    log('üîå Checking server connection...');
                    const connectionCheck = await this.checkServerConnection();
                    log(`üîå Connection check result: ${connectionCheck.message}`);
                    
                    if (!connectionCheck.connected) {
                        alert(`‚ùå Server Connection Failed: ${connectionCheck.message}`);
                        return;
                    }
                    
                    // Use the confirmed working server URL
                    const baseUrl = connectionCheck.url;
                    const apiUrl = `${baseUrl}/ketoan/listhoadon/export-excel`;
                    
                    // Normalize date strings
                    const normalizedFromDate = this.normalizeDateString(fromDate);
                    const normalizedToDate = this.normalizeDateString(toDate);
                    
                    log(`üìÖ Normalized dates: ${normalizedFromDate} to ${normalizedToDate}`);
                    
                    // Build request URL with parameters
                    const params = new URLSearchParams({
                        fromDate: normalizedFromDate,
                        toDate: normalizedToDate
                    });
                    
                    const fullUrl = `${apiUrl}?${params.toString()}`;
                    log(`üåê Request URL: ${fullUrl}`);
                    
                    log('üì§ Making Excel export request...');
                    const response = await axios.get(fullUrl, {
                        responseType: 'blob',
                        headers: {
                            'Accept': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/octet-stream, */*',
                            'User-Agent': 'Mozilla/5.0 (compatible; tazagroupcore-Frontend)',
                        },
                        timeout: 30000,
                    });
                    
                    log(`üìä Response received: ${response.status} ${response.statusText}`);
                    log(`üìä Content-Type: ${response.headers['content-type']}`);
                    log(`üìä Data size: ${response.data?.size || 'unknown'} bytes`);
                    
                    // Validate response
                    if (!response.data || response.data.size === 0) {
                        throw new Error('Received empty file from server');
                    }
                    
                    // Create blob and trigger download
                    const blob = new Blob([response.data], {
                        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                    });
                    
                    const filename = `hoa-don-${normalizedFromDate}_${normalizedToDate}.xlsx`;
                    log(`üíæ Downloading file: ${filename} (${blob.size} bytes)`);
                    
                    // Use saveAs to trigger download
                    saveAs(blob, filename);
                    
                    log('‚úÖ Excel export completed successfully!');
                    alert(`‚úÖ Export th√†nh c√¥ng! File: ${filename} (${blob.size} bytes)`);
                    
                } catch (error) {
                    log(`‚ùå Excel export error: ${error.message}`);
                    
                    let errorMessage = 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi export Excel';
                    
                    if (error.response) {
                        errorMessage = `L·ªói server (${error.response.status}): ${error.response.statusText}`;
                        log(`Server error details: ${JSON.stringify(error.response.data)}`);
                    } else if (error.request) {
                        errorMessage = 'Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server';
                        log(`Request error details: ${error.request}`);
                    } else {
                        errorMessage = `L·ªói setup request: ${error.message}`;
                    }
                    
                    alert(`‚ùå Export Excel th·∫•t b·∫°i: ${errorMessage}`);
                }
            }
        }

        async function testConnection() {
            log('üöÄ Testing connection...');
            const result = await BackendExcelExportService.checkServerConnection();
            log(`Connection result: ${result.message}`);
        }

        async function testExcelExport() {
            const fromDate = document.getElementById('fromDate').value;
            const toDate = document.getElementById('toDate').value;
            
            log('üöÄ Testing Excel export...');
            await BackendExcelExportService.exportToExcel(fromDate, toDate);
        }
    </script>
</body>
</html>