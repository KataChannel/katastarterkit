{"version":3,"sources":["turbopack:///[project]/frontend/src/components/ErrorBoundary.tsx","turbopack:///[project]/frontend/src/components/ui/toaster.tsx","turbopack:///[project]/frontend/src/components/providers.tsx","turbopack:///[project]/node_modules/.bun/graphql@16.11.0/node_modules/graphql/language/printer.mjs","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/selectURI.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/cache/inmemory/reactiveVars.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/masking/maskDefinition.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/masking/maskFragment.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/masking/utils.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/utilities/graphql/DocumentTransform.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/utilities/graphql/print.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/masking/maskOperation.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/cache/inmemory/key-extractor.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/utilities/observables/asyncMap.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/core/execute.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/utils/fromError.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/core/from.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/cache/inmemory/helpers.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/utilities/common/errorHandling.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/utilities/common/incrementalResult.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/utils/transformOperation.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/checkFetcher.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/serializeFetchParameter.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/utils/validateOperation.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/core/ApolloLink.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/rewriteURIForGET.ts","turbopack:///[project]/node_modules/.bun/graphql@16.11.0/node_modules/graphql/language/predicates.mjs","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/parseAndCheckHttpResponse.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/cache/inmemory/entityStore.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/cache/inmemory/object-canon.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/cache/core/cache.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/cache/inmemory/readFromStore.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/selectHttpOptionsAndBody.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/react/context/ApolloProvider.tsx","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/createHttpLink.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/utilities/observables/Concast.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/core/QueryInfo.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/cache/inmemory/policies.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/utils/filterOperationVariables.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/cache/inmemory/writeToStore.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/core/LocalState.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/cache/inmemory/inMemoryCache.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/HttpLink.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/utilities/common/mergeDeep.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/error/index.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/utilities/graphql/transform.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/core/QueryManager.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/core/ApolloClient.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/context/index.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/utils/createOperation.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/cache/core/types/common.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/iterators/async.ts","turbopack:///[project]/node_modules/.bun/graphql@16.11.0/node_modules/graphql/language/printString.mjs","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/responseIterator.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/iterators/reader.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/iterators/nodeStream.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/http/iterators/promise.ts","turbopack:///[project]/frontend/src/lib/apollo-client.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/link/utils/throwServerError.ts","turbopack:///[project]/frontend/src/components/support-chat/SupportChatWidgetWrapper.tsx","turbopack:///[project]/frontend/src/components/support-chat/SupportChatWidget.tsx","turbopack:///[project]/node_modules/.bun/framer-motion@12.23.24+498059a1009c1789/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs","turbopack:///[project]/node_modules/.bun/framer-motion@12.23.24+498059a1009c1789/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs","turbopack:///[project]/node_modules/.bun/framer-motion@12.23.24+498059a1009c1789/node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs","turbopack:///[project]/node_modules/.bun/framer-motion@12.23.24+498059a1009c1789/node_modules/framer-motion/dist/es/utils/use-composed-ref.mjs","turbopack:///[project]/node_modules/.bun/framer-motion@12.23.24+498059a1009c1789/node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs"],"sourcesContent":["'use client';\n\nimport React, { Component, ReactNode, ErrorInfo } from 'react';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: Error;\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      hasError: false,\n      error: undefined,\n    };\n  }\n\n  public static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Uncaught error:', error, errorInfo);\n  }\n\n  public render(): ReactNode {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n          <div className=\"max-w-md w-full mx-4\">\n            <div className=\"bg-white rounded-lg shadow-sm border border-red-200 p-8 text-center\">\n              <div className=\"h-16 w-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <svg className=\"h-8 w-8 text-red-600\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 19.5c-.77.833.192 2.5 1.732 2.5z\" />\n                </svg>\n              </div>\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-2\">\n                Something went wrong\n              </h2>\n              <p className=\"text-gray-600 mb-6\">\n                There was an error loading the application. Please refresh the page to try again.\n              </p>\n              <button\n                onClick={() => window.location.reload()}\n                className=\"w-full px-4 py-2 bg-blue-600 text-white font-medium rounded-lg hover:bg-blue-700 transition-colors\"\n              >\n                Refresh Page\n              </button>\n            </div>\n          </div>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n","'use client';\n\nimport { useToast } from '@/hooks/use-toast';\nimport { X, CheckCircle2, AlertCircle, Info, AlertTriangle } from 'lucide-react';\nimport { cn } from '@/lib/utils';\n\nexport function Toaster() {\n  const { toasts, dismiss } = useToast();\n\n  return (\n    <div className=\"fixed top-0 right-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:top-4 sm:right-4 sm:flex-col sm:max-w-[420px] pointer-events-none\">\n      {toasts.map((toast) => (\n        <div\n          key={toast.id}\n          className={cn(\n            'group pointer-events-auto relative flex w-full items-start gap-3 overflow-hidden rounded-lg border p-4 pr-8 shadow-lg transition-all',\n            'animate-in slide-in-from-top-full duration-300',\n            'data-[state=closed]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full',\n            {\n              'bg-white border-gray-200': toast.type === 'info',\n              'bg-green-50 border-green-200': toast.type === 'success',\n              'bg-red-50 border-red-200': toast.type === 'error',\n              'bg-yellow-50 border-yellow-200': toast.type === 'warning',\n            }\n          )}\n          style={{\n            marginBottom: '0.5rem',\n          }}\n        >\n          {/* Icon */}\n          <div className=\"flex-shrink-0 mt-0.5\">\n            {toast.type === 'success' && (\n              <CheckCircle2 className=\"h-5 w-5 text-green-600\" />\n            )}\n            {toast.type === 'error' && (\n              <AlertCircle className=\"h-5 w-5 text-red-600\" />\n            )}\n            {toast.type === 'warning' && (\n              <AlertTriangle className=\"h-5 w-5 text-yellow-600\" />\n            )}\n            {toast.type === 'info' && (\n              <Info className=\"h-5 w-5 text-blue-600\" />\n            )}\n          </div>\n\n          {/* Content */}\n          <div className=\"flex-1 grid gap-1\">\n            <div\n              className={cn('text-sm font-semibold', {\n                'text-gray-900': toast.type === 'info',\n                'text-green-900': toast.type === 'success',\n                'text-red-900': toast.type === 'error',\n                'text-yellow-900': toast.type === 'warning',\n              })}\n            >\n              {toast.title}\n            </div>\n            {toast.description && (\n              <div\n                className={cn('text-sm', {\n                  'text-gray-600': toast.type === 'info',\n                  'text-green-700': toast.type === 'success',\n                  'text-red-700': toast.type === 'error',\n                  'text-yellow-700': toast.type === 'warning',\n                })}\n              >\n                {toast.description}\n              </div>\n            )}\n          </div>\n\n          {/* Close Button */}\n          <button\n            onClick={() => dismiss(toast.id)}\n            className={cn(\n              'absolute right-2 top-2 rounded-md p-1 transition-opacity hover:opacity-100 focus:opacity-100 focus:outline-none focus:ring-2 opacity-70',\n              {\n                'text-gray-500 hover:text-gray-700 focus:ring-gray-400':\n                  toast.type === 'info',\n                'text-green-700 hover:text-green-900 focus:ring-green-400':\n                  toast.type === 'success',\n                'text-red-700 hover:text-red-900 focus:ring-red-400':\n                  toast.type === 'error',\n                'text-yellow-700 hover:text-yellow-900 focus:ring-yellow-400':\n                  toast.type === 'warning',\n              }\n            )}\n          >\n            <X className=\"h-4 w-4\" />\n          </button>\n        </div>\n      ))}\n    </div>\n  );\n}\n","'use client';\n\nimport { ReactNode } from 'react';\nimport { ApolloProvider } from '@apollo/client';\nimport { Toaster } from '@/components/ui/toaster';\nimport { apolloClient } from '@/lib/apollo-client';\nimport { AuthProvider } from '@/contexts/AuthContext';\nimport { ErrorBoundary } from '@/components/ErrorBoundary';\n\ninterface ProvidersProps {\n  children: ReactNode;\n}\n\nexport function Providers({ children }: ProvidersProps) {\n  return (\n    <ErrorBoundary>\n      <ApolloProvider client={apolloClient}>\n        <AuthProvider>\n          <Toaster />\n          {children}\n        </AuthProvider>\n      </ApolloProvider>\n    </ErrorBoundary>\n  );\n}\n","import { printBlockString } from './blockString.mjs';\nimport { printString } from './printString.mjs';\nimport { visit } from './visitor.mjs';\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nexport function print(ast) {\n  return visit(ast, printDocASTReducer);\n}\nconst MAX_LINE_LENGTH = 80;\nconst printDocASTReducer = {\n  Name: {\n    leave: (node) => node.value,\n  },\n  Variable: {\n    leave: (node) => '$' + node.name,\n  },\n  // Document\n  Document: {\n    leave: (node) => join(node.definitions, '\\n\\n'),\n  },\n  OperationDefinition: {\n    leave(node) {\n      const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n      const prefix = join(\n        [\n          node.operation,\n          join([node.name, varDefs]),\n          join(node.directives, ' '),\n        ],\n        ' ',\n      ); // Anonymous queries with no directives or variable definitions can use\n      // the query short form.\n\n      return (prefix === 'query' ? '' : prefix + ' ') + node.selectionSet;\n    },\n  },\n  VariableDefinition: {\n    leave: ({ variable, type, defaultValue, directives }) =>\n      variable +\n      ': ' +\n      type +\n      wrap(' = ', defaultValue) +\n      wrap(' ', join(directives, ' ')),\n  },\n  SelectionSet: {\n    leave: ({ selections }) => block(selections),\n  },\n  Field: {\n    leave({ alias, name, arguments: args, directives, selectionSet }) {\n      const prefix = wrap('', alias, ': ') + name;\n      let argsLine = prefix + wrap('(', join(args, ', '), ')');\n\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n      }\n\n      return join([argsLine, join(directives, ' '), selectionSet], ' ');\n    },\n  },\n  Argument: {\n    leave: ({ name, value }) => name + ': ' + value,\n  },\n  // Fragments\n  FragmentSpread: {\n    leave: ({ name, directives }) =>\n      '...' + name + wrap(' ', join(directives, ' ')),\n  },\n  InlineFragment: {\n    leave: ({ typeCondition, directives, selectionSet }) =>\n      join(\n        [\n          '...',\n          wrap('on ', typeCondition),\n          join(directives, ' '),\n          selectionSet,\n        ],\n        ' ',\n      ),\n  },\n  FragmentDefinition: {\n    leave: (\n      { name, typeCondition, variableDefinitions, directives, selectionSet }, // Note: fragment variable definitions are experimental and may be changed\n    ) =>\n      // or removed in the future.\n      `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` +\n      `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` +\n      selectionSet,\n  },\n  // Value\n  IntValue: {\n    leave: ({ value }) => value,\n  },\n  FloatValue: {\n    leave: ({ value }) => value,\n  },\n  StringValue: {\n    leave: ({ value, block: isBlockString }) =>\n      isBlockString ? printBlockString(value) : printString(value),\n  },\n  BooleanValue: {\n    leave: ({ value }) => (value ? 'true' : 'false'),\n  },\n  NullValue: {\n    leave: () => 'null',\n  },\n  EnumValue: {\n    leave: ({ value }) => value,\n  },\n  ListValue: {\n    leave: ({ values }) => '[' + join(values, ', ') + ']',\n  },\n  ObjectValue: {\n    leave: ({ fields }) => '{' + join(fields, ', ') + '}',\n  },\n  ObjectField: {\n    leave: ({ name, value }) => name + ': ' + value,\n  },\n  // Directive\n  Directive: {\n    leave: ({ name, arguments: args }) =>\n      '@' + name + wrap('(', join(args, ', '), ')'),\n  },\n  // Type\n  NamedType: {\n    leave: ({ name }) => name,\n  },\n  ListType: {\n    leave: ({ type }) => '[' + type + ']',\n  },\n  NonNullType: {\n    leave: ({ type }) => type + '!',\n  },\n  // Type System Definitions\n  SchemaDefinition: {\n    leave: ({ description, directives, operationTypes }) =>\n      wrap('', description, '\\n') +\n      join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n  },\n  OperationTypeDefinition: {\n    leave: ({ operation, type }) => operation + ': ' + type,\n  },\n  ScalarTypeDefinition: {\n    leave: ({ description, name, directives }) =>\n      wrap('', description, '\\n') +\n      join(['scalar', name, join(directives, ' ')], ' '),\n  },\n  ObjectTypeDefinition: {\n    leave: ({ description, name, interfaces, directives, fields }) =>\n      wrap('', description, '\\n') +\n      join(\n        [\n          'type',\n          name,\n          wrap('implements ', join(interfaces, ' & ')),\n          join(directives, ' '),\n          block(fields),\n        ],\n        ' ',\n      ),\n  },\n  FieldDefinition: {\n    leave: ({ description, name, arguments: args, type, directives }) =>\n      wrap('', description, '\\n') +\n      name +\n      (hasMultilineItems(args)\n        ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n        : wrap('(', join(args, ', '), ')')) +\n      ': ' +\n      type +\n      wrap(' ', join(directives, ' ')),\n  },\n  InputValueDefinition: {\n    leave: ({ description, name, type, defaultValue, directives }) =>\n      wrap('', description, '\\n') +\n      join(\n        [name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')],\n        ' ',\n      ),\n  },\n  InterfaceTypeDefinition: {\n    leave: ({ description, name, interfaces, directives, fields }) =>\n      wrap('', description, '\\n') +\n      join(\n        [\n          'interface',\n          name,\n          wrap('implements ', join(interfaces, ' & ')),\n          join(directives, ' '),\n          block(fields),\n        ],\n        ' ',\n      ),\n  },\n  UnionTypeDefinition: {\n    leave: ({ description, name, directives, types }) =>\n      wrap('', description, '\\n') +\n      join(\n        ['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))],\n        ' ',\n      ),\n  },\n  EnumTypeDefinition: {\n    leave: ({ description, name, directives, values }) =>\n      wrap('', description, '\\n') +\n      join(['enum', name, join(directives, ' '), block(values)], ' '),\n  },\n  EnumValueDefinition: {\n    leave: ({ description, name, directives }) =>\n      wrap('', description, '\\n') + join([name, join(directives, ' ')], ' '),\n  },\n  InputObjectTypeDefinition: {\n    leave: ({ description, name, directives, fields }) =>\n      wrap('', description, '\\n') +\n      join(['input', name, join(directives, ' '), block(fields)], ' '),\n  },\n  DirectiveDefinition: {\n    leave: ({ description, name, arguments: args, repeatable, locations }) =>\n      wrap('', description, '\\n') +\n      'directive @' +\n      name +\n      (hasMultilineItems(args)\n        ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n        : wrap('(', join(args, ', '), ')')) +\n      (repeatable ? ' repeatable' : '') +\n      ' on ' +\n      join(locations, ' | '),\n  },\n  SchemaExtension: {\n    leave: ({ directives, operationTypes }) =>\n      join(\n        ['extend schema', join(directives, ' '), block(operationTypes)],\n        ' ',\n      ),\n  },\n  ScalarTypeExtension: {\n    leave: ({ name, directives }) =>\n      join(['extend scalar', name, join(directives, ' ')], ' '),\n  },\n  ObjectTypeExtension: {\n    leave: ({ name, interfaces, directives, fields }) =>\n      join(\n        [\n          'extend type',\n          name,\n          wrap('implements ', join(interfaces, ' & ')),\n          join(directives, ' '),\n          block(fields),\n        ],\n        ' ',\n      ),\n  },\n  InterfaceTypeExtension: {\n    leave: ({ name, interfaces, directives, fields }) =>\n      join(\n        [\n          'extend interface',\n          name,\n          wrap('implements ', join(interfaces, ' & ')),\n          join(directives, ' '),\n          block(fields),\n        ],\n        ' ',\n      ),\n  },\n  UnionTypeExtension: {\n    leave: ({ name, directives, types }) =>\n      join(\n        [\n          'extend union',\n          name,\n          join(directives, ' '),\n          wrap('= ', join(types, ' | ')),\n        ],\n        ' ',\n      ),\n  },\n  EnumTypeExtension: {\n    leave: ({ name, directives, values }) =>\n      join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n  },\n  InputObjectTypeExtension: {\n    leave: ({ name, directives, fields }) =>\n      join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n  },\n};\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\nfunction join(maybeArray, separator = '') {\n  var _maybeArray$filter$jo;\n\n  return (_maybeArray$filter$jo =\n    maybeArray === null || maybeArray === void 0\n      ? void 0\n      : maybeArray.filter((x) => x).join(separator)) !== null &&\n    _maybeArray$filter$jo !== void 0\n    ? _maybeArray$filter$jo\n    : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an indented `{ }` block.\n */\n\nfunction block(array) {\n  return wrap('{\\n', indent(join(array, '\\n')), '\\n}');\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise print an empty string.\n */\n\nfunction wrap(start, maybeString, end = '') {\n  return maybeString != null && maybeString !== ''\n    ? start + maybeString + end\n    : '';\n}\n\nfunction indent(str) {\n  return wrap('  ', str.replace(/\\n/g, '\\n  '));\n}\n\nfunction hasMultilineItems(maybeArray) {\n  var _maybeArray$some;\n\n  // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n  return (_maybeArray$some =\n    maybeArray === null || maybeArray === void 0\n      ? void 0\n      : maybeArray.some((str) => str.includes('\\n'))) !== null &&\n    _maybeArray$some !== void 0\n    ? _maybeArray$some\n    : false;\n}\n","import type { Operation } from \"../core/index.js\";\n\nexport const selectURI = (\n  operation: Operation,\n  fallbackURI?: string | ((operation: Operation) => string)\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === \"function\") {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || \"/graphql\";\n  }\n};\n","import type { OptimisticDependencyFunction } from \"optimism\";\nimport { dep, Slot } from \"optimism\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { ApolloCache } from \"../../core/index.js\";\n\nexport interface ReactiveVar<T> {\n  (newValue?: T): T;\n  onNextChange(listener: ReactiveListener<T>): () => void;\n  attachCache(cache: ApolloCache<any>): this;\n  forgetCache(cache: ApolloCache<any>): boolean;\n}\n\nexport type ReactiveListener<T> = (value: T) => any;\n\n// Contextual Slot that acquires its value when custom read functions are\n// called in Policies#readField.\nexport const cacheSlot = new Slot<ApolloCache<any>>();\n\nconst cacheInfoMap = new WeakMap<\n  ApolloCache<any>,\n  {\n    vars: Set<ReactiveVar<any>>;\n    dep: OptimisticDependencyFunction<ReactiveVar<any>>;\n  }\n>();\n\nfunction getCacheInfo(cache: ApolloCache<any>) {\n  let info = cacheInfoMap.get(cache)!;\n  if (!info) {\n    cacheInfoMap.set(\n      cache,\n      (info = {\n        vars: new Set(),\n        dep: dep(),\n      })\n    );\n  }\n  return info;\n}\n\nexport function forgetCache(cache: ApolloCache<any>) {\n  getCacheInfo(cache).vars.forEach((rv) => rv.forgetCache(cache));\n}\n\n// Calling forgetCache(cache) serves to silence broadcasts and allows the\n// cache to be garbage collected. However, the varsByCache WeakMap\n// preserves the set of reactive variables that were previously associated\n// with this cache, which makes it possible to \"recall\" the cache at a\n// later time, by reattaching it to those variables. If the cache has been\n// garbage collected in the meantime, because it is no longer reachable,\n// you won't be able to call recallCache(cache), and the cache will\n// automatically disappear from the varsByCache WeakMap.\nexport function recallCache(cache: ApolloCache<any>) {\n  getCacheInfo(cache).vars.forEach((rv) => rv.attachCache(cache));\n}\n\nexport function makeVar<T>(value: T): ReactiveVar<T> {\n  const caches = new Set<ApolloCache<any>>();\n  const listeners = new Set<ReactiveListener<T>>();\n\n  const rv: ReactiveVar<T> = function (newValue) {\n    if (arguments.length > 0) {\n      if (value !== newValue) {\n        value = newValue!;\n        caches.forEach((cache) => {\n          // Invalidate any fields with custom read functions that\n          // consumed this variable, so query results involving those\n          // fields will be recomputed the next time we read them.\n          getCacheInfo(cache).dep.dirty(rv);\n          // Broadcast changes to any caches that have previously read\n          // from this variable.\n          broadcast(cache);\n        });\n        // Finally, notify any listeners added via rv.onNextChange.\n        const oldListeners = Array.from(listeners);\n        listeners.clear();\n        oldListeners.forEach((listener) => listener(value));\n      }\n    } else {\n      // When reading from the variable, obtain the current cache from\n      // context via cacheSlot. This isn't entirely foolproof, but it's\n      // the same system that powers varDep.\n      const cache = cacheSlot.getValue();\n      if (cache) {\n        attach(cache);\n        getCacheInfo(cache).dep(rv);\n      }\n    }\n\n    return value;\n  };\n\n  rv.onNextChange = (listener) => {\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n    };\n  };\n\n  const attach = (rv.attachCache = (cache) => {\n    caches.add(cache);\n    getCacheInfo(cache).vars.add(rv);\n    return rv;\n  });\n\n  rv.forgetCache = (cache) => caches.delete(cache);\n\n  return rv;\n}\n\ntype Broadcastable = ApolloCache<any> & {\n  // This method is protected in InMemoryCache, which we are ignoring, but\n  // we still want some semblance of type safety when we call it.\n  broadcastWatches?: InMemoryCache[\"broadcastWatches\"];\n};\n\nfunction broadcast(cache: Broadcastable) {\n  if (cache.broadcastWatches) {\n    cache.broadcastWatches();\n  }\n}\n","import { Kind } from \"graphql\";\nimport type { FragmentDefinitionNode, SelectionSetNode } from \"graphql\";\nimport {\n  getFragmentMaskMode,\n  maybeDeepFreeze,\n  resultKeyNameFromField,\n} from \"../utilities/index.js\";\nimport type { FragmentMap } from \"../utilities/index.js\";\nimport type { ApolloCache } from \"../cache/index.js\";\nimport { disableWarningsSlot } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\n\ninterface MaskingContext {\n  operationType: \"query\" | \"mutation\" | \"subscription\" | \"fragment\";\n  operationName: string | undefined;\n  fragmentMap: FragmentMap;\n  cache: ApolloCache<unknown>;\n  mutableTargets: WeakMap<any, any>;\n  knownChanged: WeakSet<any>;\n}\n\nexport function maskDefinition(\n  data: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext\n) {\n  return disableWarningsSlot.withValue(true, () => {\n    const masked = maskSelectionSet(data, selectionSet, context, false);\n\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\n\nfunction getMutableTarget(\n  data: Record<string, any>,\n  mutableTargets: WeakMap<any, any>\n): typeof data {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n\n  const mutableTarget = Array.isArray(data) ? [] : Object.create(null);\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\n\nfunction maskSelectionSet(\n  data: any,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext,\n  migration: boolean,\n  path?: string | undefined\n): typeof data {\n  const { knownChanged } = context;\n  const memo = getMutableTarget(data, context.mutableTargets);\n\n  if (Array.isArray(data)) {\n    for (const [index, item] of Array.from(data.entries())) {\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n\n      const masked = maskSelectionSet(\n        item,\n        selectionSet,\n        context,\n        migration,\n        __DEV__ ? `${path || \"\"}[${index}]` : void 0\n      );\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n\n      memo[index] = masked;\n    }\n\n    return knownChanged.has(memo) ? memo : data;\n  }\n\n  for (const selection of selectionSet.selections) {\n    let value: any;\n\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n\n    if (selection.kind === Kind.FIELD) {\n      const keyName = resultKeyNameFromField(selection);\n      const childSelectionSet = selection.selectionSet;\n\n      value = memo[keyName] || data[keyName];\n\n      if (value === void 0) {\n        continue;\n      }\n\n      if (childSelectionSet && value !== null) {\n        const masked = maskSelectionSet(\n          data[keyName],\n          childSelectionSet,\n          context,\n          migration,\n          __DEV__ ? `${path || \"\"}.${keyName}` : void 0\n        );\n\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n\n      if (!__DEV__) {\n        memo[keyName] = value;\n      }\n      if (__DEV__) {\n        if (\n          migration &&\n          keyName !== \"__typename\" &&\n          // either the field is not present in the memo object\n          // or it has a `get` descriptor, not a `value` descriptor\n          // => it is a warning accessor and we can overwrite it\n          // with another accessor\n          !Object.getOwnPropertyDescriptor(memo, keyName)?.value\n        ) {\n          Object.defineProperty(\n            memo,\n            keyName,\n            getAccessorWarningDescriptor(\n              keyName,\n              value,\n              path || \"\",\n              context.operationName,\n              context.operationType\n            )\n          );\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n\n    if (\n      selection.kind === Kind.INLINE_FRAGMENT &&\n      (!selection.typeCondition ||\n        context.cache.fragmentMatches!(selection, data.__typename))\n    ) {\n      value = maskSelectionSet(\n        data,\n        selection.selectionSet,\n        context,\n        migration,\n        path\n      );\n    }\n\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = selection.name.value;\n      const fragment: FragmentDefinitionNode | null =\n        context.fragmentMap[fragmentName] ||\n        (context.fragmentMap[fragmentName] =\n          context.cache.lookupFragment(fragmentName)!);\n      invariant(\n        fragment,\n        \"Could not find fragment with name '%s'.\",\n        fragmentName\n      );\n\n      const mode = getFragmentMaskMode(selection);\n\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(\n          data,\n          fragment.selectionSet,\n          context,\n          mode === \"migrate\",\n          path\n        );\n      }\n    }\n\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n\n  return knownChanged.has(memo) ? memo : data;\n}\n\nfunction getAccessorWarningDescriptor(\n  fieldName: string,\n  value: any,\n  path: string,\n  operationName: string | undefined,\n  operationType: string\n): PropertyDescriptor {\n  let getValue = () => {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n\n    invariant.warn(\n      \"Accessing unmasked field on %s at path '%s'. This field will not be available when masking is enabled. Please read the field from the fragment instead.\",\n      operationName ?\n        `${operationType} '${operationName}'`\n      : `anonymous ${operationType}`,\n      `${path}.${fieldName}`.replace(/^\\./, \"\")\n    );\n\n    getValue = () => value;\n\n    return value;\n  };\n\n  return {\n    get() {\n      return getValue();\n    },\n    set(newValue) {\n      getValue = () => newValue;\n    },\n    enumerable: true,\n    configurable: true,\n  };\n}\n","import { Kind } from \"graphql\";\nimport type { FragmentDefinitionNode } from \"graphql\";\nimport type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"../core/index.js\";\nimport {\n  MapImpl,\n  SetImpl,\n  warnOnImproperCacheImplementation,\n} from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport equal from \"@wry/equality\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n} from \"../utilities/index.js\";\n\n/** @internal */\nexport function maskFragment<TData = unknown>(\n  data: TData,\n  document: TypedDocumentNode<TData> | DocumentNode,\n  cache: ApolloCache<unknown>,\n  fragmentName?: string\n): TData {\n  if (!cache.fragmentMatches) {\n    if (__DEV__) {\n      warnOnImproperCacheImplementation();\n    }\n\n    return data;\n  }\n\n  const fragments = document.definitions.filter(\n    (node): node is FragmentDefinitionNode =>\n      node.kind === Kind.FRAGMENT_DEFINITION\n  );\n\n  if (typeof fragmentName === \"undefined\") {\n    invariant(\n      fragments.length === 1,\n      `Found %s fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n      fragments.length\n    );\n    fragmentName = fragments[0].name.value;\n  }\n\n  const fragment = fragments.find(\n    (fragment) => fragment.name.value === fragmentName\n  );\n\n  invariant(\n    !!fragment,\n    `Could not find fragment with name \"%s\".`,\n    fragmentName\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  if (equal(data, {})) {\n    // Return early and skip the masking algorithm if we don't have any data\n    // yet. This can happen when cache.diff returns an empty object which is\n    // used from watchFragment.\n    return data;\n  }\n\n  return maskDefinition(data, fragment.selectionSet, {\n    operationType: \"fragment\",\n    operationName: fragment.name.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl(),\n  });\n}\n","import { Slot } from \"optimism\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { canUseWeakMap, canUseWeakSet } from \"../utilities/index.js\";\n\nexport const MapImpl = canUseWeakMap ? WeakMap : Map;\nexport const SetImpl = canUseWeakSet ? WeakSet : Set;\n\n// Contextual slot that allows us to disable accessor warnings on fields when in\n// migrate mode.\n/** @internal */\nexport const disableWarningsSlot = new Slot<boolean>();\n\nlet issuedWarning = false;\nexport function warnOnImproperCacheImplementation() {\n  if (!issuedWarning) {\n    issuedWarning = true;\n    invariant.warn(\n      \"The configured cache does not support data masking which effectively disables it. Please use a cache that supports data masking or disable data masking to silence this warning. Caches will be required to support the necessary data masking APIs in Apollo Client 4.0.\"\n    );\n  }\n}\n","import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nimport type { DocumentNode } from \"graphql\";\nimport { WeakCache } from \"@wry/caches\";\nimport { wrap } from \"optimism\";\nimport { cacheSizes } from \"../caching/index.js\";\n\nexport type DocumentTransformCacheKey = ReadonlyArray<unknown>;\n\ntype TransformFn = (document: DocumentNode) => DocumentNode;\n\ninterface DocumentTransformOptions {\n  /**\n   * Determines whether to cache the transformed GraphQL document. Caching can speed up repeated calls to the document transform for the same input document. Set to `false` to completely disable caching for the document transform. When disabled, this option takes precedence over the [`getCacheKey`](#getcachekey) option.\n   *\n   * The default value is `true`.\n   */\n  cache?: boolean;\n  /**\n   * Defines a custom cache key for a GraphQL document that will determine whether to re-run the document transform when given the same input GraphQL document. Returns an array that defines the cache key. Return `undefined` to disable caching for that GraphQL document.\n   *\n   * > **Note:** The items in the array may be any type, but also need to be referentially stable to guarantee a stable cache key.\n   *\n   * The default implementation of this function returns the `document` as the cache key.\n   */\n  getCacheKey?: (\n    document: DocumentNode\n  ) => DocumentTransformCacheKey | undefined;\n}\n\nfunction identity(document: DocumentNode) {\n  return document;\n}\n\nexport class DocumentTransform {\n  private readonly transform: TransformFn;\n  private cached: boolean;\n\n  private readonly resultCache =\n    canUseWeakSet ? new WeakSet<DocumentNode>() : new Set<DocumentNode>();\n\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  private getCacheKey(\n    document: DocumentNode\n  ): DocumentTransformCacheKey | undefined {\n    return [document];\n  }\n\n  static identity() {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, { cache: false });\n  }\n\n  static split(\n    predicate: (document: DocumentNode) => boolean,\n    left: DocumentTransform,\n    right: DocumentTransform = DocumentTransform.identity()\n  ) {\n    return Object.assign(\n      new DocumentTransform(\n        (document) => {\n          const documentTransform = predicate(document) ? left : right;\n\n          return documentTransform.transformDocument(document);\n        },\n        // Reasonably assume both `left` and `right` transforms handle their own caching\n        { cache: false }\n      ),\n      { left, right }\n    );\n  }\n\n  constructor(\n    transform: TransformFn,\n    options: DocumentTransformOptions = Object.create(null)\n  ) {\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n    this.cached = options.cache !== false;\n\n    this.resetCache();\n  }\n\n  /**\n   * Resets the internal cache of this transform, if it has one.\n   */\n  resetCache() {\n    if (this.cached) {\n      const stableCacheKeys = new Trie<WeakKey>(canUseWeakMap);\n      this.performWork = wrap(\n        DocumentTransform.prototype.performWork.bind(this),\n        {\n          makeCacheKey: (document) => {\n            const cacheKeys = this.getCacheKey(document);\n            if (cacheKeys) {\n              invariant(\n                Array.isArray(cacheKeys),\n                \"`getCacheKey` must return an array or undefined\"\n              );\n              return stableCacheKeys.lookupArray(cacheKeys);\n            }\n          },\n          max: cacheSizes[\"documentTransform.cache\"],\n          cache: WeakCache<any, any>,\n        }\n      );\n    }\n  }\n\n  private performWork(document: DocumentNode) {\n    checkDocument(document);\n    return this.transform(document);\n  }\n\n  transformDocument(document: DocumentNode) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    const transformedDocument = this.performWork(document);\n\n    this.resultCache.add(transformedDocument);\n\n    return transformedDocument;\n  }\n\n  concat(otherTransform: DocumentTransform): DocumentTransform {\n    return Object.assign(\n      new DocumentTransform(\n        (document) => {\n          return otherTransform.transformDocument(\n            this.transformDocument(document)\n          );\n        },\n        // Reasonably assume both transforms handle their own caching\n        { cache: false }\n      ),\n      {\n        left: this,\n        right: otherTransform,\n      }\n    );\n  }\n\n  /**\n   * @internal\n   * Used to iterate through all transforms that are concatenations or `split` links.\n   */\n  readonly left?: DocumentTransform;\n  /**\n   * @internal\n   * Used to iterate through all transforms that are concatenations or `split` links.\n   */\n  readonly right?: DocumentTransform;\n}\n","import type { ASTNode } from \"graphql\";\nimport { print as origPrint } from \"graphql\";\nimport {\n  AutoCleanedWeakCache,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../caching/index.js\";\nimport { registerGlobalCache } from \"../caching/getMemoryInternals.js\";\n\nlet printCache!: AutoCleanedWeakCache<ASTNode, string>;\nexport const print = Object.assign(\n  (ast: ASTNode) => {\n    let result = printCache.get(ast);\n\n    if (!result) {\n      result = origPrint(ast);\n      printCache.set(ast, result);\n    }\n    return result;\n  },\n  {\n    reset() {\n      printCache = new AutoCleanedWeakCache<ASTNode, string>(\n        cacheSizes.print || defaultCacheSizes.print\n      );\n    },\n  }\n);\nprint.reset();\n\nif (__DEV__) {\n  registerGlobalCache(\"print\", () => (printCache ? printCache.size : 0));\n}\n","import type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"../core/index.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n  getOperationDefinition,\n} from \"../utilities/index.js\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport {\n  MapImpl,\n  SetImpl,\n  warnOnImproperCacheImplementation,\n} from \"./utils.js\";\n\n/** @internal */\nexport function maskOperation<TData = unknown>(\n  data: TData,\n  document: DocumentNode | TypedDocumentNode<TData>,\n  cache: ApolloCache<unknown>\n): TData {\n  if (!cache.fragmentMatches) {\n    if (__DEV__) {\n      warnOnImproperCacheImplementation();\n    }\n\n    return data;\n  }\n\n  const definition = getOperationDefinition(document);\n\n  invariant(\n    definition,\n    \"Expected a parsed GraphQL document with a query, mutation, or subscription.\"\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  return maskDefinition(data, definition.selectionSet, {\n    operationType: definition.operation,\n    operationName: definition.name?.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl(),\n  });\n}\n","import { invariant } from \"../../utilities/globals/index.js\";\n\nimport {\n  argumentsObjectFromField,\n  DeepMerger,\n  isNonEmptyArray,\n  isNonNullObject,\n} from \"../../utilities/index.js\";\n\nimport { hasOwn, isArray } from \"./helpers.js\";\nimport type {\n  KeySpecifier,\n  KeyFieldsFunction,\n  KeyArgsFunction,\n} from \"./policies.js\";\n\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nconst specifierInfoCache: Record<\n  string,\n  {\n    paths?: string[][];\n    keyFieldsFn?: KeyFieldsFunction;\n    keyArgsFn?: KeyArgsFunction;\n  }\n> = Object.create(null);\n\nfunction lookupSpecifierInfo(spec: KeySpecifier) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  const cacheKey = JSON.stringify(spec);\n  return (\n    specifierInfoCache[cacheKey] ||\n    (specifierInfoCache[cacheKey] = Object.create(null))\n  );\n}\n\nexport function keyFieldsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyFieldsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyFieldsFn ||\n    (info.keyFieldsFn = (object, context) => {\n      const extract: typeof extractKey = (from, key) =>\n        context.readField(key, from);\n\n      const keyObject = (context.keyObject = collectSpecifierPaths(\n        specifier,\n        (schemaKeyPath) => {\n          let extracted = extractKeyPath(\n            context.storeObject,\n            schemaKeyPath,\n            // Using context.readField to extract paths from context.storeObject\n            // allows the extraction to see through Reference objects and respect\n            // custom read functions.\n            extract\n          );\n\n          if (\n            extracted === void 0 &&\n            object !== context.storeObject &&\n            hasOwn.call(object, schemaKeyPath[0])\n          ) {\n            // If context.storeObject fails to provide a value for the requested\n            // path, fall back to the raw result object, if it has a top-level key\n            // matching the first key in the path (schemaKeyPath[0]). This allows\n            // key fields included in the written data to be saved in the cache\n            // even if they are not selected explicitly in context.selectionSet.\n            // Not being mentioned by context.selectionSet is convenient here,\n            // since it means these extra fields cannot be affected by field\n            // aliasing, which is why we can use extractKey instead of\n            // context.readField for this extraction.\n            extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n          }\n\n          invariant(\n            extracted !== void 0,\n            `Missing field '%s' while extracting keyFields from %s`,\n            schemaKeyPath.join(\".\"),\n            object\n          );\n\n          return extracted;\n        }\n      ));\n\n      return `${context.typename}:${JSON.stringify(keyObject)}`;\n    })\n  );\n}\n\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyArgsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyArgsFn ||\n    (info.keyArgsFn = (args, { field, variables, fieldName }) => {\n      const collected = collectSpecifierPaths(specifier, (keyPath) => {\n        const firstKey = keyPath[0];\n        const firstChar = firstKey.charAt(0);\n\n        if (firstChar === \"@\") {\n          if (field && isNonEmptyArray(field.directives)) {\n            const directiveName = firstKey.slice(1);\n            // If the directive appears multiple times, only the first\n            // occurrence's arguments will be used. TODO Allow repetition?\n            // TODO Cache this work somehow, a la aliasMap?\n            const d = field.directives.find(\n              (d) => d.name.value === directiveName\n            );\n            // Fortunately argumentsObjectFromField works for DirectiveNode!\n            const directiveArgs = d && argumentsObjectFromField(d, variables);\n            // For directives without arguments (d defined, but directiveArgs ===\n            // null), the presence or absence of the directive still counts as\n            // part of the field key, so we return null in those cases. If no\n            // directive with this name was found for this field (d undefined and\n            // thus directiveArgs undefined), we return undefined, which causes\n            // this value to be omitted from the key object returned by\n            // collectSpecifierPaths.\n            return (\n              directiveArgs &&\n              extractKeyPath(\n                directiveArgs,\n                // If keyPath.length === 1, this code calls extractKeyPath with an\n                // empty path, which works because it uses directiveArgs as the\n                // extracted value.\n                keyPath.slice(1)\n              )\n            );\n          }\n          // If the key started with @ but there was no corresponding directive,\n          // we want to omit this value from the key object, not fall through to\n          // treating @whatever as a normal argument name.\n          return;\n        }\n\n        if (firstChar === \"$\") {\n          const variableName = firstKey.slice(1);\n          if (variables && hasOwn.call(variables, variableName)) {\n            const varKeyPath = keyPath.slice(0);\n            varKeyPath[0] = variableName;\n            return extractKeyPath(variables, varKeyPath);\n          }\n          // If the key started with $ but there was no corresponding variable, we\n          // want to omit this value from the key object, not fall through to\n          // treating $whatever as a normal argument name.\n          return;\n        }\n\n        if (args) {\n          return extractKeyPath(args, keyPath);\n        }\n      });\n\n      const suffix = JSON.stringify(collected);\n\n      // If no arguments were passed to this field, and it didn't have any other\n      // field key contributions from directives or variables, hide the empty\n      // :{} suffix from the field key. However, a field passed no arguments can\n      // still end up with a non-empty :{...} suffix if its key configuration\n      // refers to directives or variables.\n      if (args || suffix !== \"{}\") {\n        fieldName += \":\" + suffix;\n      }\n\n      return fieldName;\n    })\n  );\n}\n\nexport function collectSpecifierPaths(\n  specifier: KeySpecifier,\n  extractor: (path: string[]) => any\n): Record<string, any> {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  const merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce((collected, path) => {\n    let toMerge = extractor(path);\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (let i = path.length - 1; i >= 0; --i) {\n        toMerge = { [path[i]]: toMerge };\n      }\n      collected = merger.merge(collected, toMerge);\n    }\n    return collected;\n  }, Object.create(null));\n}\n\nexport function getSpecifierPaths(spec: KeySpecifier): string[][] {\n  const info = lookupSpecifierInfo(spec);\n\n  if (!info.paths) {\n    const paths: string[][] = (info.paths = []);\n    const currentPath: string[] = [];\n\n    spec.forEach((s, i) => {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach((p) => paths.push(currentPath.concat(p)));\n        currentPath.length = 0;\n      } else {\n        currentPath.push(s);\n        if (!isArray(spec[i + 1])) {\n          paths.push(currentPath.slice(0));\n          currentPath.length = 0;\n        }\n      }\n    });\n  }\n\n  return info.paths!;\n}\n\nfunction extractKey<TObj extends Record<string, any>, TKey extends string>(\n  object: TObj,\n  key: TKey\n): TObj[TKey] | undefined {\n  return object[key];\n}\n\nexport function extractKeyPath(\n  object: Record<string, any>,\n  path: string[],\n  extract?: typeof extractKey\n): any {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(\n    path.reduce(function reducer(obj, key): any {\n      return isArray(obj) ?\n          obj.map((child) => reducer(child, key))\n        : obj && extract!(obj, key);\n    }, object)\n  );\n}\n\nfunction normalize<T>(value: T): T {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize) as any;\n    }\n    return collectSpecifierPaths(Object.keys(value).sort(), (path) =>\n      extractKeyPath(value, path)\n    ) as T;\n  }\n  return value;\n}\n","import type { Observer } from \"./Observable.js\";\nimport { Observable } from \"./Observable.js\";\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\n/**\n * @deprecated `asyncMap` will be removed in Apollo Client 4.0. This function is\n * safe to use in Apollo Client 3.x.\n *\n * **Recommended now**\n *\n * No action needed\n *\n * **When migrating**\n *\n * Prefer to use RxJS's built in helpers. Convert promises into observables\n * using the [`from`](https://rxjs.dev/api/index/function/from) function.\n */\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | PromiseLike<R>,\n  catchFn?: (error: any) => R | PromiseLike<R>\n): Observable<R> {\n  return new Observable<R>((observer) => {\n    let promiseQueue = {\n      // Normally we would initialize promiseQueue to Promise.resolve(), but\n      // in this case, for backwards compatibility, we need to be careful to\n      // invoke the first callback synchronously.\n      then(callback: () => any) {\n        return new Promise((resolve) => resolve(callback()));\n      },\n    } as Promise<void>;\n\n    function makeCallback(\n      examiner: typeof mapFn | typeof catchFn,\n      key: \"next\" | \"error\"\n    ): (arg: any) => void {\n      return (arg) => {\n        if (examiner) {\n          const both = () =>\n            // If the observer is closed, we don't want to continue calling the\n            // mapping function - it's result will be swallowed anyways.\n            observer.closed ?\n              /* will be swallowed */ (0 as any)\n            : examiner(arg);\n\n          promiseQueue = promiseQueue.then(both, both).then(\n            (result) => observer.next(result),\n            (error) => observer.error(error)\n          );\n        } else {\n          observer[key](arg);\n        }\n      };\n    }\n\n    const handler: Observer<V> = {\n      next: makeCallback(mapFn, \"next\"),\n      error: makeCallback(catchFn, \"error\"),\n      complete() {\n        // no need to reassign `promiseQueue`, after `observer.complete`,\n        // the observer will be closed and short-circuit everything anyways\n        /*promiseQueue = */ promiseQueue.then(() => observer.complete());\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n","import { ApolloLink } from \"./ApolloLink.js\";\n\nexport const execute = ApolloLink.execute;\n","import { Observable } from \"../../utilities/index.js\";\n\n/**\n * @deprecated `fromError` will be removed in Apollo Client 4.0. This is safe\n * to use in 3.x.\n *\n * **Recommended now**\n *\n * No action needed\n *\n * **When upgrading**\n *\n * Use RxJS's [`throwError`](https://rxjs.dev/api/index/function/throwError) function.\n *\n * ```ts\n * const observable = throwError(() => new Error(...));\n * ```\n */\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>((observer) => {\n    observer.error(errorValue);\n  });\n}\n","import { ApolloLink } from \"./ApolloLink.js\";\n\nexport const from = ApolloLink.from;\n","import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { NormalizedCache, InMemoryCacheConfig } from \"./types.js\";\n\nimport type { KeyFieldsContext } from \"./policies.js\";\nimport type { FragmentRegistryAPI } from \"./fragmentRegistry.js\";\n\nimport type {\n  Reference,\n  StoreValue,\n  StoreObject,\n  FragmentMap,\n  FragmentMapFunction,\n} from \"../../utilities/index.js\";\nimport {\n  isReference,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n  isNonNullObject,\n  compact,\n  createFragmentMap,\n  getFragmentDefinitions,\n  isArray,\n} from \"../../utilities/index.js\";\n\nexport const { hasOwnProperty: hasOwn } = Object.prototype;\n\nexport function isNullish(value: any): value is null | undefined {\n  return value === null || value === void 0;\n}\n\nexport { isArray };\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n        !isNullish(id) ? { id }\n        : !isNullish(_id) ? { _id }\n        : void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n\n    if (!isNullish(id)) {\n      return `${__typename}:${\n        typeof id === \"number\" || typeof id === \"string\" ?\n          id\n        : JSON.stringify(id)\n      }`;\n    }\n  }\n}\n\nconst defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function shouldCanonizeResults(\n  config: Pick<InMemoryCacheConfig, \"canonizeResults\">\n): boolean {\n  const value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference\n): string | undefined {\n  return isReference(objectOrReference) ?\n      (store.get(objectOrReference.__ref, \"__typename\") as string)\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result) ?\n        result.every((item) =>\n          selectionSetMatchesResult(selectionSet, item, variables)\n        )\n      : selectionSet.selections.every((field) => {\n          if (isField(field) && shouldInclude(field, variables)) {\n            const key = resultKeyNameFromField(field);\n            return (\n              hasOwn.call(result, key) &&\n              (!field.selectionSet ||\n                selectionSetMatchesResult(\n                  field.selectionSet,\n                  result[key],\n                  variables\n                ))\n            );\n          }\n          // If the selection has been skipped with @skip(true) or\n          // @include(false), it should not count against the matching. If\n          // the selection is not a field, it must be a fragment (inline or\n          // named). We will determine if selectionSetMatchesResult for that\n          // fragment when we get to it, so for now we return true.\n          return true;\n        });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue\n): value is StoreObject {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n","import type { FetchResult } from \"../../link/core/index.js\";\nimport { isNonEmptyArray } from \"./arrays.js\";\nimport { isExecutionPatchIncrementalResult } from \"./incrementalResult.js\";\n\nexport function graphQLResultHasError<T>(result: FetchResult<T>): boolean {\n  const errors = getGraphQLErrorsFromResult(result);\n  return isNonEmptyArray(errors);\n}\n\nexport function getGraphQLErrorsFromResult<T>(result: FetchResult<T>) {\n  const graphQLErrors =\n    isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n\n  if (\n    isExecutionPatchIncrementalResult(result) &&\n    isNonEmptyArray(result.incremental)\n  ) {\n    result.incremental.forEach((incrementalResult) => {\n      if (incrementalResult.errors) {\n        graphQLErrors.push(...incrementalResult.errors);\n      }\n    });\n  }\n  return graphQLErrors;\n}\n","import type {\n  ExecutionPatchIncrementalResult,\n  ExecutionPatchInitialResult,\n  ExecutionPatchResult,\n  ApolloPayloadResult,\n  FetchResult,\n} from \"../../link/core/index.js\";\nimport { isNonNullObject } from \"./objects.js\";\nimport { isNonEmptyArray } from \"./arrays.js\";\nimport { DeepMerger } from \"./mergeDeep.js\";\n\nexport function isExecutionPatchIncrementalResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchIncrementalResult {\n  return \"incremental\" in value;\n}\n\nexport function isExecutionPatchInitialResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchInitialResult<T> {\n  return \"hasNext\" in value && \"data\" in value;\n}\n\nexport function isExecutionPatchResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchResult<T> {\n  return (\n    isExecutionPatchIncrementalResult(value) ||\n    isExecutionPatchInitialResult(value)\n  );\n}\n\n// This function detects an Apollo payload result before it is transformed\n// into a FetchResult via HttpLink; it cannot detect an ApolloPayloadResult\n// once it leaves the link chain.\nexport function isApolloPayloadResult(\n  value: unknown\n): value is ApolloPayloadResult {\n  return isNonNullObject(value) && \"payload\" in value;\n}\n\nexport function mergeIncrementalData<TData extends object>(\n  prevResult: TData,\n  result: ExecutionPatchResult<TData>\n) {\n  let mergedData = prevResult;\n  const merger = new DeepMerger();\n  if (\n    isExecutionPatchIncrementalResult(result) &&\n    isNonEmptyArray(result.incremental)\n  ) {\n    result.incremental.forEach(({ data, path }) => {\n      for (let i = path.length - 1; i >= 0; --i) {\n        const key = path[i];\n        const isNumericKey = !isNaN(+key);\n        const parent: Record<string | number, any> = isNumericKey ? [] : {};\n        parent[key] = data;\n        data = parent as typeof data;\n      }\n      mergedData = merger.merge(mergedData, data);\n    });\n  }\n  return mergedData as TData;\n}\n","import type { GraphQLRequest, Operation } from \"../core/index.js\";\nimport { getOperationName } from \"../../utilities/index.js\";\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // Best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== \"string\" ?\n        getOperationName(transformedOperation.query) || undefined\n      : \"\";\n  }\n\n  return transformedOperation as Operation;\n}\n","import { newInvariantError } from \"../../utilities/globals/index.js\";\n\nexport const checkFetcher = (fetcher: typeof fetch | undefined) => {\n  if (!fetcher && typeof fetch === \"undefined\") {\n    throw newInvariantError(`\n\"fetch\" has not been found globally and no fetcher has been \\\nconfigured. To fix this, install a fetch package (like \\\nhttps://www.npmjs.com/package/cross-fetch), instantiate the \\\nfetcher, and pass it into your HttpLink constructor. For example:\n\nimport fetch from 'cross-fetch';\nimport { ApolloClient, HttpLink } from '@apollo/client';\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: '/graphql', fetch })\n});\n    `);\n  }\n};\n","import { newInvariantError } from \"../../utilities/globals/index.js\";\nimport type { InvariantError } from \"../../utilities/globals/index.js\";\n\nexport type ClientParseError = InvariantError & {\n  parseError: Error;\n};\n\nexport const serializeFetchParameter = (p: any, label: string) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e: any) {\n    const parseError = newInvariantError(\n      `Network request failed. %s is not serializable: %s`,\n      label,\n      e.message\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n","import { newInvariantError } from \"../../utilities/globals/index.js\";\nimport type { GraphQLRequest } from \"../core/index.js\";\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    \"query\",\n    \"operationName\",\n    \"variables\",\n    \"extensions\",\n    \"context\",\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw newInvariantError(`illegal argument: %s`, key);\n    }\n  }\n\n  return operation;\n}\n","import { newInvariantError, invariant } from \"../../utilities/globals/index.js\";\n\nimport type { Observer } from \"../../utilities/index.js\";\nimport { Observable } from \"../../utilities/index.js\";\nimport type {\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n  GraphQLRequest,\n} from \"./types.js\";\nimport {\n  validateOperation,\n  createOperation,\n  transformOperation,\n} from \"../utils/index.js\";\nimport { warnDeprecated } from \"../../utilities/deprecation/index.js\";\n\nfunction passthrough(op: Operation, forward: NextLink) {\n  return (forward ? forward(op) : Observable.of()) as Observable<FetchResult>;\n}\n\nfunction toLink(handler: RequestHandler | ApolloLink) {\n  return typeof handler === \"function\" ? new ApolloLink(handler) : handler;\n}\n\nfunction isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport class ApolloLink {\n  public static empty(): ApolloLink {\n    return new ApolloLink(() => Observable.of());\n  }\n\n  public static from(links: (ApolloLink | RequestHandler)[]): ApolloLink {\n    if (links.length === 0) return ApolloLink.empty();\n    return links.map(toLink).reduce((x, y) => x.concat(y)) as ApolloLink;\n  }\n\n  public static split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler\n  ): ApolloLink {\n    const leftLink = toLink(left);\n    const rightLink = toLink(right || new ApolloLink(passthrough));\n\n    let ret: ApolloLink;\n    if (isTerminating(leftLink) && isTerminating(rightLink)) {\n      ret = new ApolloLink((operation) => {\n        return test(operation) ?\n            leftLink.request(operation) || Observable.of()\n          : rightLink.request(operation) || Observable.of();\n      });\n    } else {\n      ret = new ApolloLink((operation, forward) => {\n        return test(operation) ?\n            leftLink.request(operation, forward) || Observable.of()\n          : rightLink.request(operation, forward) || Observable.of();\n      });\n    }\n    return Object.assign(ret, { left: leftLink, right: rightLink });\n  }\n\n  public static execute(\n    link: ApolloLink,\n    operation: GraphQLRequest\n  ): Observable<FetchResult> {\n    return (\n      link.request(\n        createOperation(\n          operation.context,\n          transformOperation(validateOperation(operation))\n        )\n      ) || Observable.of()\n    );\n  }\n\n  public static concat(\n    first: ApolloLink | RequestHandler,\n    second: ApolloLink | RequestHandler\n  ) {\n    const firstLink = toLink(first);\n    if (isTerminating(firstLink)) {\n      invariant.warn(\n        `You are calling concat on a terminating link, which will have no effect %o`,\n        firstLink\n      );\n      return firstLink;\n    }\n    const nextLink = toLink(second);\n\n    let ret: ApolloLink;\n    if (isTerminating(nextLink)) {\n      ret = new ApolloLink(\n        (operation) =>\n          firstLink.request(\n            operation,\n            (op) => nextLink.request(op) || Observable.of()\n          ) || Observable.of()\n      );\n    } else {\n      ret = new ApolloLink((operation, forward) => {\n        return (\n          firstLink.request(operation, (op) => {\n            return nextLink.request(op, forward) || Observable.of();\n          }) || Observable.of()\n        );\n      });\n    }\n    return Object.assign(ret, { left: firstLink, right: nextLink });\n  }\n\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler\n  ): ApolloLink {\n    return this.concat(\n      ApolloLink.split(test, left, right || new ApolloLink(passthrough))\n    );\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return ApolloLink.concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink\n  ): Observable<FetchResult> | null {\n    throw newInvariantError(\"request is not implemented\");\n  }\n\n  /**\n   * @deprecated `onError` will be removed with Apollo Client 4.0. Please\n   * discontinue using this method.\n   */\n  protected onError(\n    error: any,\n    observer?: Observer<FetchResult>\n  ): false | void {\n    if (__DEV__) {\n      warnDeprecated(\"onError\", () => {\n        invariant.warn(\n          \"[ApolloLink] `onError` is deprecated and will be removed with Apollo Client 4.0. Please discontinue using it.\"\n        );\n      });\n    }\n    if (observer && observer.error) {\n      observer.error(error);\n      // Returning false indicates that observer.error does not need to be\n      // called again, since it was already called (on the previous line).\n      // Calling observer.error again would not cause any real problems,\n      // since only the first call matters, but custom onError functions\n      // might have other reasons for wanting to prevent the default\n      // behavior by returning false.\n      return false;\n    }\n    // Throw errors will be passed to observer.error.\n    throw error;\n  }\n\n  /**\n   * @deprecated `setOnError` will be removed with Apollo Client 4.0. Please\n   * discontinue using this method.\n   */\n  public setOnError(fn: ApolloLink[\"onError\"]): this {\n    if (__DEV__) {\n      invariant.warn(\n        \"[ApolloLink] `setOnError` is deprecated and will be removed with Apollo Client 4.0. Please discontinue using it.\"\n      );\n    }\n    this.onError = fn;\n    return this;\n  }\n\n  /**\n   * @internal\n   * Used to iterate through all links that are concatenations or `split` links.\n   */\n  readonly left?: ApolloLink;\n  /**\n   * @internal\n   * Used to iterate through all links that are concatenations or `split` links.\n   */\n  readonly right?: ApolloLink;\n\n  /**\n   * @internal\n   * Can be provided by a link that has an internal cache to report it's memory details.\n   */\n  getMemoryInternals?: () => unknown;\n}\n","import { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport type { Body } from \"./selectHttpOptionsAndBody.js\";\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nexport function rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams: string[] = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if (\"query\" in body) {\n    addQueryParam(\"query\", body.query!);\n  }\n  if (body.operationName) {\n    addQueryParam(\"operationName\", body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        \"Variables map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"variables\", serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        \"Extensions map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"extensions\", serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = \"\",\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf(\"#\");\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join(\"&\") + fragment;\n  return { newURI };\n}\n","import { Kind } from './kinds.mjs';\nexport function isDefinitionNode(node) {\n  return (\n    isExecutableDefinitionNode(node) ||\n    isTypeSystemDefinitionNode(node) ||\n    isTypeSystemExtensionNode(node)\n  );\n}\nexport function isExecutableDefinitionNode(node) {\n  return (\n    node.kind === Kind.OPERATION_DEFINITION ||\n    node.kind === Kind.FRAGMENT_DEFINITION\n  );\n}\nexport function isSelectionNode(node) {\n  return (\n    node.kind === Kind.FIELD ||\n    node.kind === Kind.FRAGMENT_SPREAD ||\n    node.kind === Kind.INLINE_FRAGMENT\n  );\n}\nexport function isValueNode(node) {\n  return (\n    node.kind === Kind.VARIABLE ||\n    node.kind === Kind.INT ||\n    node.kind === Kind.FLOAT ||\n    node.kind === Kind.STRING ||\n    node.kind === Kind.BOOLEAN ||\n    node.kind === Kind.NULL ||\n    node.kind === Kind.ENUM ||\n    node.kind === Kind.LIST ||\n    node.kind === Kind.OBJECT\n  );\n}\nexport function isConstValueNode(node) {\n  return (\n    isValueNode(node) &&\n    (node.kind === Kind.LIST\n      ? node.values.some(isConstValueNode)\n      : node.kind === Kind.OBJECT\n      ? node.fields.some((field) => isConstValueNode(field.value))\n      : node.kind !== Kind.VARIABLE)\n  );\n}\nexport function isTypeNode(node) {\n  return (\n    node.kind === Kind.NAMED_TYPE ||\n    node.kind === Kind.LIST_TYPE ||\n    node.kind === Kind.NON_NULL_TYPE\n  );\n}\nexport function isTypeSystemDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCHEMA_DEFINITION ||\n    isTypeDefinitionNode(node) ||\n    node.kind === Kind.DIRECTIVE_DEFINITION\n  );\n}\nexport function isTypeDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_DEFINITION ||\n    node.kind === Kind.OBJECT_TYPE_DEFINITION ||\n    node.kind === Kind.INTERFACE_TYPE_DEFINITION ||\n    node.kind === Kind.UNION_TYPE_DEFINITION ||\n    node.kind === Kind.ENUM_TYPE_DEFINITION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n  );\n}\nexport function isTypeSystemExtensionNode(node) {\n  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);\n}\nexport function isTypeExtensionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_EXTENSION ||\n    node.kind === Kind.OBJECT_TYPE_EXTENSION ||\n    node.kind === Kind.INTERFACE_TYPE_EXTENSION ||\n    node.kind === Kind.UNION_TYPE_EXTENSION ||\n    node.kind === Kind.ENUM_TYPE_EXTENSION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION\n  );\n}\n","import { responseIterator } from \"./responseIterator.js\";\nimport type { Operation } from \"../core/index.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nimport type { SubscriptionObserver } from \"zen-observable-ts\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>,\n>(response: Response, nextValue: (value: T) => void) {\n  if (TextDecoder === undefined) {\n    throw new Error(\n      \"TextDecoder must be defined in the environment: please import a polyfill.\"\n    );\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n  const delimiter = \"boundary=\";\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const boundaryVal =\n    contentType?.includes(delimiter) ?\n      contentType\n        ?.substring(contentType?.indexOf(delimiter) + delimiter.length)\n        .replace(/['\"]/g, \"\")\n        .replace(/\\;(.*)/gm, \"\")\n        .trim()\n    : \"-\";\n\n  const boundary = `\\r\\n--${boundaryVal}`;\n  let buffer = \"\";\n  const iterator = responseIterator(response);\n  let running = true;\n\n  while (running) {\n    const { value, done } = await iterator.next();\n    const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n    const searchFrom = buffer.length - boundary.length + 1;\n    running = !done;\n    buffer += chunk;\n    let bi = buffer.indexOf(boundary, searchFrom);\n\n    while (bi > -1) {\n      let message: string;\n      [message, buffer] = [\n        buffer.slice(0, bi),\n        buffer.slice(bi + boundary.length),\n      ];\n      const i = message.indexOf(\"\\r\\n\\r\\n\");\n      const headers = parseHeaders(message.slice(0, i));\n      const contentType = headers[\"content-type\"];\n      if (\n        contentType &&\n        contentType.toLowerCase().indexOf(\"application/json\") === -1\n      ) {\n        throw new Error(\n          \"Unsupported patch content type: application/json is required.\"\n        );\n      }\n      // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n      // this is going to be `JSON.parse`d there is no need.\n      const body = message.slice(i);\n\n      if (body) {\n        const result = parseJsonBody<T>(response, body);\n        if (\n          Object.keys(result).length > 1 ||\n          \"data\" in result ||\n          \"incremental\" in result ||\n          \"errors\" in result ||\n          \"payload\" in result\n        ) {\n          if (isApolloPayloadResult(result)) {\n            let next = {};\n            if (\"payload\" in result) {\n              if (Object.keys(result).length === 1 && result.payload === null) {\n                return;\n              }\n              next = { ...result.payload };\n            }\n            if (\"errors\" in result) {\n              next = {\n                ...next,\n                extensions: {\n                  ...(\"extensions\" in next ? next.extensions : (null as any)),\n                  [PROTOCOL_ERRORS_SYMBOL]: result.errors,\n                },\n              };\n            }\n            nextValue(next as T);\n          } else {\n            // for the last chunk with only `hasNext: false`\n            // we don't need to call observer.next as there is no data/errors\n            nextValue(result);\n          }\n        } else if (\n          // If the chunk contains only a \"hasNext: false\", we can call\n          // observer.complete() immediately.\n          Object.keys(result).length === 1 &&\n          \"hasNext\" in result &&\n          !result.hasNext\n        ) {\n          return;\n        }\n      }\n      bi = buffer.indexOf(boundary);\n    }\n  }\n}\n\nexport function parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nexport function parseJsonBody<T>(response: Response, bodyText: string): T {\n  if (response.status >= 300) {\n    // Network error\n    const getResult = (): Record<string, unknown> | string => {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(\n      response,\n      getResult(),\n      `Response not successful: Received status code ${response.status}`\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText) as T;\n  } catch (err) {\n    const parseError = err as ServerParseError;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\n\nexport function handleError(err: any, observer: SubscriptionObserver<any>) {\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next(err.result);\n  }\n\n  observer.error(err);\n}\n\nexport function parseAndCheckHttpResponse(operations: Operation | Operation[]) {\n  return (response: Response) =>\n    response\n      .text()\n      .then((bodyText) => parseJsonBody(response, bodyText))\n      .then((result: any) => {\n        if (\n          !Array.isArray(result) &&\n          !hasOwnProperty.call(result, \"data\") &&\n          !hasOwnProperty.call(result, \"errors\")\n        ) {\n          // Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations) ?\n                operations.map((op) => op.operationName)\n              : operations.operationName\n            }'.`\n          );\n        }\n        return result;\n      });\n}\n","import { invariant } from \"../../utilities/globals/index.js\";\nimport type { OptimisticDependencyFunction } from \"optimism\";\nimport { dep } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\n\nimport type {\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  isReference,\n  makeReference,\n  DeepMerger,\n  maybeDeepFreeze,\n  canUseWeakMap,\n  isNonNullObject,\n} from \"../../utilities/index.js\";\nimport type { NormalizedCache, NormalizedCacheObject } from \"./types.js\";\nimport { hasOwn, fieldNameFromStoreName } from \"./helpers.js\";\nimport type { Policies, StorageType } from \"./policies.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type {\n  SafeReadonly,\n  Modifier,\n  Modifiers,\n  ReadFieldOptions,\n  ToReferenceFunction,\n  CanReadFunction,\n  InvalidateModifier,\n  DeleteModifier,\n  ModifierDetails,\n} from \"../core/types/common.js\";\nimport type { DocumentNode, FieldNode, SelectionSetNode } from \"graphql\";\n\nconst DELETE: DeleteModifier = Object.create(null);\nconst delModifier: Modifier<any> = () => DELETE;\nconst INVALIDATE: InvalidateModifier = Object.create(null);\n\nexport abstract class EntityStore implements NormalizedCache {\n  protected data: NormalizedCacheObject = Object.create(null);\n\n  constructor(\n    public readonly policies: Policies,\n    public readonly group: CacheGroup\n  ) {}\n\n  public abstract addLayer(\n    layerId: string,\n    replay: (layer: EntityStore) => any\n  ): Layer;\n\n  public abstract removeLayer(layerId: string): EntityStore;\n\n  // Although the EntityStore class is abstract, it contains concrete\n  // implementations of the various NormalizedCache interface methods that\n  // are inherited by the Root and Layer subclasses.\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data };\n  }\n\n  public has(dataId: string): boolean {\n    return this.lookup(dataId, true) !== void 0;\n  }\n\n  public get(dataId: string, fieldName: string): StoreValue {\n    this.group.depend(dataId, fieldName);\n    if (hasOwn.call(this.data, dataId)) {\n      const storeObject = this.data[dataId];\n      if (storeObject && hasOwn.call(storeObject, fieldName)) {\n        return storeObject[fieldName];\n      }\n    }\n    if (\n      fieldName === \"__typename\" &&\n      hasOwn.call(this.policies.rootTypenamesById, dataId)\n    ) {\n      return this.policies.rootTypenamesById[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.get(dataId, fieldName);\n    }\n  }\n\n  protected lookup(\n    dataId: string,\n    dependOnExistence?: boolean\n  ): StoreObject | undefined {\n    // The has method (above) calls lookup with dependOnExistence = true, so\n    // that it can later be invalidated when we add or remove a StoreObject for\n    // this dataId. Any consumer who cares about the contents of the StoreObject\n    // should not rely on this dependency, since the contents could change\n    // without the object being added or removed.\n    if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n\n    if (hasOwn.call(this.data, dataId)) {\n      return this.data[dataId];\n    }\n\n    if (this instanceof Layer) {\n      return this.parent.lookup(dataId, dependOnExistence);\n    }\n\n    if (this.policies.rootTypenamesById[dataId]) {\n      return Object.create(null);\n    }\n  }\n\n  public merge(older: string | StoreObject, newer: StoreObject | string): void {\n    let dataId: string | undefined;\n\n    // Convert unexpected references to ID strings.\n    if (isReference(older)) older = older.__ref;\n    if (isReference(newer)) newer = newer.__ref;\n\n    const existing: StoreObject | undefined =\n      typeof older === \"string\" ? this.lookup((dataId = older)) : older;\n\n    const incoming: StoreObject | undefined =\n      typeof newer === \"string\" ? this.lookup((dataId = newer)) : newer;\n\n    // If newer was a string ID, but that ID was not defined in this store,\n    // then there are no fields to be merged, so we're done.\n    if (!incoming) return;\n\n    invariant(typeof dataId === \"string\", \"store.merge expects a string ID\");\n\n    const merged: StoreObject = new DeepMerger(storeObjectReconciler).merge(\n      existing,\n      incoming\n    );\n\n    // Even if merged === existing, existing may have come from a lower\n    // layer, so we always need to set this.data[dataId] on this level.\n    this.data[dataId] = merged;\n\n    if (merged !== existing) {\n      delete this.refs[dataId];\n      if (this.group.caching) {\n        const fieldsToDirty: Record<string, 1> = Object.create(null);\n\n        // If we added a new StoreObject where there was previously none, dirty\n        // anything that depended on the existence of this dataId, such as the\n        // EntityStore#has method.\n        if (!existing) fieldsToDirty.__exists = 1;\n\n        // Now invalidate dependents who called getFieldValue for any fields\n        // that are changing as a result of this merge.\n        Object.keys(incoming).forEach((storeFieldName) => {\n          if (\n            !existing ||\n            existing[storeFieldName] !== merged[storeFieldName]\n          ) {\n            // Always dirty the full storeFieldName, which may include\n            // serialized arguments following the fieldName prefix.\n            fieldsToDirty[storeFieldName] = 1;\n\n            // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n            // different from storeFieldName and this field does not have\n            // keyArgs configured, because that means the cache can't make\n            // any assumptions about how field values with the same field\n            // name but different arguments might be interrelated, so it\n            // must err on the side of invalidating all field values that\n            // share the same short fieldName, regardless of arguments.\n            const fieldName = fieldNameFromStoreName(storeFieldName);\n            if (\n              fieldName !== storeFieldName &&\n              !this.policies.hasKeyArgs(merged.__typename, fieldName)\n            ) {\n              fieldsToDirty[fieldName] = 1;\n            }\n\n            // If merged[storeFieldName] has become undefined, and this is the\n            // Root layer, actually delete the property from the merged object,\n            // which is guaranteed to have been created fresh in this method.\n            if (merged[storeFieldName] === void 0 && !(this instanceof Layer)) {\n              delete merged[storeFieldName];\n            }\n          }\n        });\n\n        if (\n          fieldsToDirty.__typename &&\n          !(existing && existing.__typename) &&\n          // Since we return default root __typename strings\n          // automatically from store.get, we don't need to dirty the\n          // ROOT_QUERY.__typename field if merged.__typename is equal\n          // to the default string (usually \"Query\").\n          this.policies.rootTypenamesById[dataId] === merged.__typename\n        ) {\n          delete fieldsToDirty.__typename;\n        }\n\n        Object.keys(fieldsToDirty).forEach((fieldName) =>\n          this.group.dirty(dataId as string, fieldName)\n        );\n      }\n    }\n  }\n\n  public modify(\n    dataId: string,\n    fields: Modifier<any> | Modifiers<Record<string, any>>\n  ): boolean {\n    const storeObject = this.lookup(dataId);\n\n    if (storeObject) {\n      const changedFields: Record<string, any> = Object.create(null);\n      let needToMerge = false;\n      let allDeleted = true;\n\n      const sharedDetails = {\n        DELETE,\n        INVALIDATE,\n        isReference,\n        toReference: this.toReference,\n        canRead: this.canRead,\n        readField: <V = StoreValue>(\n          fieldNameOrOptions: string | ReadFieldOptions,\n          from?: StoreObject | Reference\n        ) =>\n          this.policies.readField<V>(\n            typeof fieldNameOrOptions === \"string\" ?\n              {\n                fieldName: fieldNameOrOptions,\n                from: from || makeReference(dataId),\n              }\n            : fieldNameOrOptions,\n            { store: this }\n          ),\n      } satisfies Partial<ModifierDetails>;\n\n      Object.keys(storeObject).forEach((storeFieldName) => {\n        const fieldName = fieldNameFromStoreName(storeFieldName);\n        let fieldValue = storeObject[storeFieldName];\n        if (fieldValue === void 0) return;\n        const modify: Modifier<StoreValue> | undefined =\n          typeof fields === \"function\" ? fields : (\n            fields[storeFieldName] || fields[fieldName]\n          );\n        if (modify) {\n          let newValue =\n            modify === delModifier ? DELETE : (\n              modify(maybeDeepFreeze(fieldValue), {\n                ...sharedDetails,\n                fieldName,\n                storeFieldName,\n                storage: this.getStorage(dataId, storeFieldName),\n              })\n            );\n          if (newValue === INVALIDATE) {\n            this.group.dirty(dataId, storeFieldName);\n          } else {\n            if (newValue === DELETE) newValue = void 0;\n            if (newValue !== fieldValue) {\n              changedFields[storeFieldName] = newValue;\n              needToMerge = true;\n              fieldValue = newValue as StoreValue;\n\n              if (__DEV__) {\n                const checkReference = (ref: Reference) => {\n                  if (this.lookup(ref.__ref) === undefined) {\n                    invariant.warn(\n                      \"cache.modify: You are trying to write a Reference that is not part of the store: %o\\n\" +\n                        \"Please make sure to set the `mergeIntoStore` parameter to `true` when creating a Reference that is not part of the store yet:\\n\" +\n                        \"`toReference(object, true)`\",\n                      ref\n                    );\n                    return true;\n                  }\n                };\n                if (isReference(newValue)) {\n                  checkReference(newValue);\n                } else if (Array.isArray(newValue)) {\n                  // Warn about writing \"mixed\" arrays of Reference and non-Reference objects\n                  let seenReference: boolean = false;\n                  let someNonReference: unknown;\n                  for (const value of newValue) {\n                    if (isReference(value)) {\n                      seenReference = true;\n                      if (checkReference(value)) break;\n                    } else {\n                      // Do not warn on primitive values, since those could never be represented\n                      // by a reference. This is a valid (albeit uncommon) use case.\n                      if (typeof value === \"object\" && !!value) {\n                        const [id] = this.policies.identify(value);\n                        // check if object could even be referenced, otherwise we are not interested in it for this warning\n                        if (id) {\n                          someNonReference = value;\n                        }\n                      }\n                    }\n                    if (seenReference && someNonReference !== undefined) {\n                      invariant.warn(\n                        \"cache.modify: Writing an array with a mix of both References and Objects will not result in the Objects being normalized correctly.\\n\" +\n                          \"Please convert the object instance %o to a Reference before writing it to the cache by calling `toReference(object, true)`.\",\n                        someNonReference\n                      );\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (fieldValue !== void 0) {\n          allDeleted = false;\n        }\n      });\n\n      if (needToMerge) {\n        this.merge(dataId, changedFields);\n\n        if (allDeleted) {\n          if (this instanceof Layer) {\n            this.data[dataId] = void 0;\n          } else {\n            delete this.data[dataId];\n          }\n          this.group.dirty(dataId, \"__exists\");\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // If called with only one argument, removes the entire entity\n  // identified by dataId. If called with a fieldName as well, removes all\n  // fields of that entity whose names match fieldName according to the\n  // fieldNameFromStoreName helper function. If called with a fieldName\n  // and variables, removes all fields of that entity whose names match fieldName\n  // and whose arguments when cached exactly match the variables passed.\n  public delete(\n    dataId: string,\n    fieldName?: string,\n    args?: Record<string, any>\n  ) {\n    const storeObject = this.lookup(dataId);\n    if (storeObject) {\n      const typename = this.getFieldValue<string>(storeObject, \"__typename\");\n      const storeFieldName =\n        fieldName && args ?\n          this.policies.getStoreFieldName({ typename, fieldName, args })\n        : fieldName;\n      return this.modify(\n        dataId,\n        storeFieldName ?\n          {\n            [storeFieldName]: delModifier,\n          }\n        : delModifier\n      );\n    }\n    return false;\n  }\n\n  public evict(options: Cache.EvictOptions, limit: EntityStore): boolean {\n    let evicted = false;\n    if (options.id) {\n      if (hasOwn.call(this.data, options.id)) {\n        evicted = this.delete(options.id, options.fieldName, options.args);\n      }\n      if (this instanceof Layer && this !== limit) {\n        evicted = this.parent.evict(options, limit) || evicted;\n      }\n      // Always invalidate the field to trigger rereading of watched\n      // queries, even if no cache data was modified by the eviction,\n      // because queries may depend on computed fields with custom read\n      // functions, whose values are not stored in the EntityStore.\n      if (options.fieldName || evicted) {\n        this.group.dirty(options.id, options.fieldName || \"__exists\");\n      }\n    }\n    return evicted;\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public extract(): NormalizedCacheObject {\n    const obj = this.toObject();\n    const extraRootIds: string[] = [];\n    this.getRootIdSet().forEach((id) => {\n      if (!hasOwn.call(this.policies.rootTypenamesById, id)) {\n        extraRootIds.push(id);\n      }\n    });\n    if (extraRootIds.length) {\n      obj.__META = { extraRootIds: extraRootIds.sort() };\n    }\n    return obj;\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    Object.keys(this.data).forEach((dataId) => {\n      if (!(newData && hasOwn.call(newData, dataId))) {\n        this.delete(dataId);\n      }\n    });\n    if (newData) {\n      const { __META, ...rest } = newData;\n      Object.keys(rest).forEach((dataId) => {\n        this.merge(dataId, rest[dataId] as StoreObject);\n      });\n      if (__META) {\n        __META.extraRootIds.forEach(this.retain, this);\n      }\n    }\n  }\n\n  public abstract getStorage(\n    idOrObj: string | StoreObject,\n    ...storeFieldNames: (string | number)[]\n  ): StorageType;\n\n  // Maps root entity IDs to the number of times they have been retained, minus\n  // the number of times they have been released. Retained entities keep other\n  // entities they reference (even indirectly) from being garbage collected.\n  private rootIds: {\n    [rootId: string]: number;\n  } = Object.create(null);\n\n  public retain(rootId: string): number {\n    return (this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1);\n  }\n\n  public release(rootId: string): number {\n    if (this.rootIds[rootId] > 0) {\n      const count = --this.rootIds[rootId];\n      if (!count) delete this.rootIds[rootId];\n      return count;\n    }\n    return 0;\n  }\n\n  // Return a Set<string> of all the ID strings that have been retained by\n  // this layer/root *and* any layers/roots beneath it.\n  public getRootIdSet(ids = new Set<string>()) {\n    Object.keys(this.rootIds).forEach(ids.add, ids);\n    if (this instanceof Layer) {\n      this.parent.getRootIdSet(ids);\n    } else {\n      // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n      // always considered roots for garbage collection, regardless of\n      // their retainment counts in this.rootIds.\n      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n    }\n    return ids;\n  }\n\n  // The goal of garbage collection is to remove IDs from the Root layer of the\n  // store that are no longer reachable starting from any IDs that have been\n  // explicitly retained (see retain and release, above). Returns an array of\n  // dataId strings that were removed from the store.\n  public gc() {\n    const ids = this.getRootIdSet();\n    const snapshot = this.toObject();\n    ids.forEach((id) => {\n      if (hasOwn.call(snapshot, id)) {\n        // Because we are iterating over an ECMAScript Set, the IDs we add here\n        // will be visited in later iterations of the forEach loop only if they\n        // were not previously contained by the Set.\n        Object.keys(this.findChildRefIds(id)).forEach(ids.add, ids);\n        // By removing IDs from the snapshot object here, we protect them from\n        // getting removed from the root store layer below.\n        delete snapshot[id];\n      }\n    });\n    const idsToRemove = Object.keys(snapshot);\n    if (idsToRemove.length) {\n      let root: EntityStore = this;\n      while (root instanceof Layer) root = root.parent;\n      idsToRemove.forEach((id) => root.delete(id));\n    }\n    return idsToRemove;\n  }\n\n  // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n  private refs: {\n    [dataId: string]: Record<string, true>;\n  } = Object.create(null);\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    if (!hasOwn.call(this.refs, dataId)) {\n      const found = (this.refs[dataId] = Object.create(null));\n      const root = this.data[dataId];\n      if (!root) return found;\n\n      const workSet = new Set<Record<string | number, any>>([root]);\n      // Within the store, only arrays and objects can contain child entity\n      // references, so we can prune the traversal using this predicate:\n      workSet.forEach((obj) => {\n        if (isReference(obj)) {\n          found[obj.__ref] = true;\n          // In rare cases, a { __ref } Reference object may have other fields.\n          // This often indicates a mismerging of References with StoreObjects,\n          // but garbage collection should not be fooled by a stray __ref\n          // property in a StoreObject (ignoring all the other fields just\n          // because the StoreObject looks like a Reference). To avoid this\n          // premature termination of findChildRefIds recursion, we fall through\n          // to the code below, which will handle any other properties of obj.\n        }\n        if (isNonNullObject(obj)) {\n          Object.keys(obj).forEach((key) => {\n            const child = obj[key];\n            // No need to add primitive values to the workSet, since they cannot\n            // contain reference objects.\n            if (isNonNullObject(child)) {\n              workSet.add(child);\n            }\n          });\n        }\n      });\n    }\n    return this.refs[dataId];\n  }\n\n  // Used to compute cache keys specific to this.group.\n  /** overload for `InMemoryCache.maybeBroadcastWatch` */\n  public makeCacheKey(\n    document: DocumentNode,\n    callback: Cache.WatchCallback<any>,\n    details: string\n  ): object;\n  /** overload for `StoreReader.executeSelectionSet` */\n  public makeCacheKey(\n    selectionSet: SelectionSetNode,\n    parent: string /* = ( Reference.__ref ) */ | StoreObject,\n    varString: string | undefined,\n    canonizeResults: boolean\n  ): object;\n  /** overload for `StoreReader.executeSubSelectedArray` */\n  public makeCacheKey(\n    field: FieldNode,\n    array: readonly any[],\n    varString: string | undefined\n  ): object;\n  /** @deprecated This is only meant for internal usage,\n   * in your own code please use a `Trie` instance instead. */\n  public makeCacheKey(...args: any[]): object;\n  public makeCacheKey() {\n    return this.group.keyMaker.lookupArray(arguments);\n  }\n\n  // Bound function that can be passed around to provide easy access to fields\n  // of Reference objects as well as ordinary objects.\n  public getFieldValue = <T = StoreValue>(\n    objectOrReference: StoreObject | Reference | undefined,\n    storeFieldName: string\n  ) =>\n    maybeDeepFreeze(\n      isReference(objectOrReference) ?\n        this.get(objectOrReference.__ref, storeFieldName)\n      : objectOrReference && objectOrReference[storeFieldName]\n    ) as SafeReadonly<T>;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  public canRead: CanReadFunction = (objOrRef) => {\n    return isReference(objOrRef) ?\n        this.has(objOrRef.__ref)\n      : typeof objOrRef === \"object\";\n  };\n\n  // Bound function that converts an id or an object with a __typename and\n  // primary key fields to a Reference object. If called with a Reference object,\n  // that same Reference object is returned. Pass true for mergeIntoStore to persist\n  // an object into the store.\n  public toReference: ToReferenceFunction = (objOrIdOrRef, mergeIntoStore) => {\n    if (typeof objOrIdOrRef === \"string\") {\n      return makeReference(objOrIdOrRef);\n    }\n\n    if (isReference(objOrIdOrRef)) {\n      return objOrIdOrRef;\n    }\n\n    const [id] = this.policies.identify(objOrIdOrRef);\n\n    if (id) {\n      const ref = makeReference(id);\n      if (mergeIntoStore) {\n        this.merge(id, objOrIdOrRef);\n      }\n      return ref;\n    }\n  };\n}\n\nexport type FieldValueGetter = EntityStore[\"getFieldValue\"];\n\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nclass CacheGroup {\n  private d: OptimisticDependencyFunction<string> | null = null;\n\n  // Used by the EntityStore#makeCacheKey method to compute cache keys\n  // specific to this CacheGroup.\n  public keyMaker!: Trie<object>;\n\n  constructor(\n    public readonly caching: boolean,\n    private parent: CacheGroup | null = null\n  ) {\n    this.resetCaching();\n  }\n\n  public resetCaching() {\n    this.d = this.caching ? dep<string>() : null;\n    this.keyMaker = new Trie(canUseWeakMap);\n  }\n\n  public depend(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d(makeDepKey(dataId, storeFieldName));\n      const fieldName = fieldNameFromStoreName(storeFieldName);\n      if (fieldName !== storeFieldName) {\n        // Fields with arguments that contribute extra identifying\n        // information to the fieldName (thus forming the storeFieldName)\n        // depend not only on the full storeFieldName but also on the\n        // short fieldName, so the field can be invalidated using either\n        // level of specificity.\n        this.d(makeDepKey(dataId, fieldName));\n      }\n      if (this.parent) {\n        this.parent.depend(dataId, storeFieldName);\n      }\n    }\n  }\n\n  public dirty(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d.dirty(\n        makeDepKey(dataId, storeFieldName),\n        // When storeFieldName === \"__exists\", that means the entity identified\n        // by dataId has either disappeared from the cache or was newly added,\n        // so the result caching system would do well to \"forget everything it\n        // knows\" about that object. To achieve that kind of invalidation, we\n        // not only dirty the associated result cache entry, but also remove it\n        // completely from the dependency graph. For the optimism implementation\n        // details, see https://github.com/benjamn/optimism/pull/195.\n        storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\"\n      );\n    }\n  }\n}\n\nfunction makeDepKey(dataId: string, storeFieldName: string) {\n  // Since field names cannot have '#' characters in them, this method\n  // of joining the field name and the ID should be unambiguous, and much\n  // cheaper than JSON.stringify([dataId, fieldName]).\n  return storeFieldName + \"#\" + dataId;\n}\n\nexport function maybeDependOnExistenceOfEntity(\n  store: NormalizedCache,\n  entityId: string\n) {\n  if (supportsResultCaching(store)) {\n    // We use this pseudo-field __exists elsewhere in the EntityStore code to\n    // represent changes in the existence of the entity object identified by\n    // entityId. This dependency gets reliably dirtied whenever an object with\n    // this ID is deleted (or newly created) within this group, so any result\n    // cache entries (for example, StoreReader#executeSelectionSet results) that\n    // depend on __exists for this entityId will get dirtied as well, leading to\n    // the eventual recomputation (instead of reuse) of those result objects the\n    // next time someone reads them from the cache.\n    store.group.depend(entityId, \"__exists\");\n  }\n}\n\nexport namespace EntityStore {\n  // Refer to this class as EntityStore.Root outside this namespace.\n  export class Root extends EntityStore {\n    constructor({\n      policies,\n      resultCaching = true,\n      seed,\n    }: {\n      policies: Policies;\n      resultCaching?: boolean;\n      seed?: NormalizedCacheObject;\n    }) {\n      super(policies, new CacheGroup(resultCaching));\n      if (seed) this.replace(seed);\n    }\n\n    public readonly stump = new Stump(this);\n\n    public addLayer(\n      layerId: string,\n      replay: (layer: EntityStore) => any\n    ): Layer {\n      // Adding an optimistic Layer on top of the Root actually adds the Layer\n      // on top of the Stump, so the Stump always comes between the Root and\n      // any Layer objects that we've added.\n      return this.stump.addLayer(layerId, replay);\n    }\n\n    public removeLayer(): Root {\n      // Never remove the root layer.\n      return this;\n    }\n\n    public readonly storageTrie = new Trie<StorageType>(canUseWeakMap);\n    public getStorage(): StorageType {\n      return this.storageTrie.lookupArray(arguments);\n    }\n  }\n}\n\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nclass Layer extends EntityStore {\n  constructor(\n    public readonly id: string,\n    public readonly parent: EntityStore,\n    public readonly replay: (layer: EntityStore) => any,\n    public readonly group: CacheGroup\n  ) {\n    super(parent.policies, group);\n    replay(this);\n  }\n\n  public addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer {\n    return new Layer(layerId, this, replay, this.group);\n  }\n\n  public removeLayer(layerId: string): EntityStore {\n    // Remove all instances of the given id, not just the first one.\n    const parent = this.parent.removeLayer(layerId);\n\n    if (layerId === this.id) {\n      if (this.group.caching) {\n        // Dirty every ID we're removing. Technically we might be able to avoid\n        // dirtying fields that have values in higher layers, but we don't have\n        // easy access to higher layers here, and we're about to recreate those\n        // layers anyway (see parent.addLayer below).\n        Object.keys(this.data).forEach((dataId) => {\n          const ownStoreObject = this.data[dataId];\n          const parentStoreObject = parent[\"lookup\"](dataId);\n          if (!parentStoreObject) {\n            // The StoreObject identified by dataId was defined in this layer\n            // but will be undefined in the parent layer, so we can delete the\n            // whole entity using this.delete(dataId). Since we're about to\n            // throw this layer away, the only goal of this deletion is to dirty\n            // the removed fields.\n            this.delete(dataId);\n          } else if (!ownStoreObject) {\n            // This layer had an entry for dataId but it was undefined, which\n            // means the entity was deleted in this layer, and it's about to\n            // become undeleted when we remove this layer, so we need to dirty\n            // all fields that are about to be reexposed.\n            this.group.dirty(dataId, \"__exists\");\n            Object.keys(parentStoreObject).forEach((storeFieldName) => {\n              this.group.dirty(dataId, storeFieldName);\n            });\n          } else if (ownStoreObject !== parentStoreObject) {\n            // If ownStoreObject is not exactly the same as parentStoreObject,\n            // dirty any fields whose values will change as a result of this\n            // removal.\n            Object.keys(ownStoreObject).forEach((storeFieldName) => {\n              if (\n                !equal(\n                  ownStoreObject[storeFieldName],\n                  parentStoreObject[storeFieldName]\n                )\n              ) {\n                this.group.dirty(dataId, storeFieldName);\n              }\n            });\n          }\n        });\n      }\n\n      return parent;\n    }\n\n    // No changes are necessary if the parent chain remains identical.\n    if (parent === this.parent) return this;\n\n    // Recreate this layer on top of the new parent.\n    return parent.addLayer(this.id, this.replay);\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    const fromParent = this.parent.findChildRefIds(dataId);\n    return hasOwn.call(this.data, dataId) ?\n        {\n          ...fromParent,\n          ...super.findChildRefIds(dataId),\n        }\n      : fromParent;\n  }\n\n  public getStorage(): StorageType {\n    let p: EntityStore = this.parent;\n    while ((p as Layer).parent) p = (p as Layer).parent;\n    return p.getStorage.apply(\n      p,\n      // @ts-expect-error\n      arguments\n    );\n  }\n}\n\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nclass Stump extends Layer {\n  constructor(root: EntityStore.Root) {\n    super(\n      \"EntityStore.Stump\",\n      root,\n      () => {},\n      new CacheGroup(root.group.caching, root.group)\n    );\n  }\n\n  public removeLayer() {\n    // Never remove the Stump layer.\n    return this;\n  }\n\n  public merge(older: string | StoreObject, newer: string | StoreObject) {\n    // We never want to write any data into the Stump, so we forward any merge\n    // calls to the Root instead. Another option here would be to throw an\n    // exception, but the toReference(object, true) function can sometimes\n    // trigger Stump writes (which used to be Root writes, before the Stump\n    // concept was introduced).\n    return this.parent.merge(older, newer);\n  }\n}\n\nfunction storeObjectReconciler(\n  existingObject: StoreObject,\n  incomingObject: StoreObject,\n  property: string | number\n): StoreValue {\n  const existingValue = existingObject[property];\n  const incomingValue = incomingObject[property];\n  // Wherever there is a key collision, prefer the incoming value, unless\n  // it is deeply equal to the existing value. It's worth checking deep\n  // equality here (even though blindly returning incoming would be\n  // logically correct) because preserving the referential identity of\n  // existing data can prevent needless rereading and rerendering.\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\n\nexport function supportsResultCaching(store: any): store is EntityStore {\n  // When result caching is disabled, store.depend will be null.\n  return !!(store instanceof EntityStore && store.group.caching);\n}\n","import { Trie } from \"@wry/trie\";\nimport {\n  canUseWeakMap,\n  canUseWeakSet,\n  isNonNullObject as isObjectOrArray,\n} from \"../../utilities/index.js\";\nimport { isArray } from \"./helpers.js\";\n\nfunction shallowCopy<T>(value: T): T {\n  if (isObjectOrArray(value)) {\n    return isArray(value) ?\n        (value.slice(0) as any as T)\n      : { __proto__: Object.getPrototypeOf(value), ...value };\n  }\n  return value;\n}\n\n// When programmers talk about the \"canonical form\" of an object, they\n// usually have the following meaning in mind, which I've copied from\n// https://en.wiktionary.org/wiki/canonical_form:\n//\n// 1. A standard or normal presentation of a mathematical entity [or\n//    object]. A canonical form is an element of a set of representatives\n//    of equivalence classes of forms such that there is a function or\n//    procedure which projects every element of each equivalence class\n//    onto that one element, the canonical form of that equivalence\n//    class. The canonical form is expected to be simpler than the rest of\n//    the forms in some way.\n//\n// That's a long-winded way of saying any two objects that have the same\n// canonical form may be considered equivalent, even if they are !==,\n// which usually means the objects are structurally equivalent (deeply\n// equal), but don't necessarily use the same memory.\n//\n// Like a literary or musical canon, this ObjectCanon class represents a\n// collection of unique canonical items (JavaScript objects), with the\n// important property that canon.admit(a) === canon.admit(b) if a and b\n// are deeply equal to each other. In terms of the definition above, the\n// canon.admit method is the \"function or procedure which projects every\"\n// object \"onto that one element, the canonical form.\"\n//\n// In the worst case, the canonicalization process may involve looking at\n// every property in the provided object tree, so it takes the same order\n// of time as deep equality checking. Fortunately, already-canonicalized\n// objects are returned immediately from canon.admit, so the presence of\n// canonical subtrees tends to speed up canonicalization.\n//\n// Since consumers of canonical objects can check for deep equality in\n// constant time, canonicalizing cache results can massively improve the\n// performance of application code that skips re-rendering unchanged\n// results, such as \"pure\" UI components in a framework like React.\n//\n// Of course, since canonical objects may be shared widely between\n// unrelated consumers, it's important to think of them as immutable, even\n// though they are not actually frozen with Object.freeze in production,\n// due to the extra performance overhead that comes with frozen objects.\n//\n// Custom scalar objects whose internal class name is neither Array nor\n// Object can be included safely in the admitted tree, but they will not\n// be replaced with a canonical version (to put it another way, they are\n// assumed to be canonical already).\n//\n// If we ignore custom objects, no detection of cycles or repeated object\n// references is currently required by the StoreReader class, since\n// GraphQL result objects are JSON-serializable trees (and thus contain\n// neither cycles nor repeated subtrees), so we can avoid the complexity\n// of keeping track of objects we've already seen during the recursion of\n// the admit method.\n//\n// In the future, we may consider adding additional cases to the switch\n// statement to handle other common object types, such as \"[object Date]\"\n// objects, as needed.\nexport class ObjectCanon {\n  // Set of all canonical objects this ObjectCanon has admitted, allowing\n  // canon.admit to return previously-canonicalized objects immediately.\n  private known = new (canUseWeakSet ? WeakSet : Set)<object>();\n\n  // Efficient storage/lookup structure for canonical objects.\n  private pool = new Trie<{\n    array?: any[];\n    object?: Record<string, any>;\n    keys?: SortedKeysInfo;\n  }>(canUseWeakMap);\n\n  public isKnown(value: any): boolean {\n    return isObjectOrArray(value) && this.known.has(value);\n  }\n\n  // Make the ObjectCanon assume this value has already been\n  // canonicalized.\n  private passes = new WeakMap<object, object>();\n  public pass<T>(value: T): T;\n  public pass(value: any) {\n    if (isObjectOrArray(value)) {\n      const copy = shallowCopy(value);\n      this.passes.set(copy, value);\n      return copy;\n    }\n    return value;\n  }\n\n  // Returns the canonical version of value.\n  public admit<T>(value: T): T;\n  public admit(value: any) {\n    if (isObjectOrArray(value)) {\n      const original = this.passes.get(value);\n      if (original) return original;\n\n      const proto = Object.getPrototypeOf(value);\n      switch (proto) {\n        case Array.prototype: {\n          if (this.known.has(value)) return value;\n          const array: any[] = (value as any[]).map(this.admit, this);\n          // Arrays are looked up in the Trie using their recursively\n          // canonicalized elements, and the known version of the array is\n          // preserved as node.array.\n          const node = this.pool.lookupArray(array);\n          if (!node.array) {\n            this.known.add((node.array = array));\n            // Since canonical arrays may be shared widely between\n            // unrelated consumers, it's important to regard them as\n            // immutable, even if they are not frozen in production.\n            if (__DEV__) {\n              Object.freeze(array);\n            }\n          }\n          return node.array;\n        }\n\n        case null:\n        case Object.prototype: {\n          if (this.known.has(value)) return value;\n          const proto = Object.getPrototypeOf(value);\n          const array = [proto];\n          const keys = this.sortedKeys(value);\n          array.push(keys.json);\n          const firstValueIndex = array.length;\n          keys.sorted.forEach((key) => {\n            array.push(this.admit((value as any)[key]));\n          });\n          // Objects are looked up in the Trie by their prototype (which\n          // is *not* recursively canonicalized), followed by a JSON\n          // representation of their (sorted) keys, followed by the\n          // sequence of recursively canonicalized values corresponding to\n          // those keys. To keep the final results unambiguous with other\n          // sequences (such as arrays that just happen to contain [proto,\n          // keys.json, value1, value2, ...]), the known version of the\n          // object is stored as node.object.\n          const node = this.pool.lookupArray(array);\n          if (!node.object) {\n            const obj = (node.object = Object.create(proto));\n            this.known.add(obj);\n            keys.sorted.forEach((key, i) => {\n              obj[key] = array[firstValueIndex + i];\n            });\n            // Since canonical objects may be shared widely between\n            // unrelated consumers, it's important to regard them as\n            // immutable, even if they are not frozen in production.\n            if (__DEV__) {\n              Object.freeze(obj);\n            }\n          }\n          return node.object;\n        }\n      }\n    }\n    return value;\n  }\n\n  // It's worthwhile to cache the sorting of arrays of strings, since the\n  // same initial unsorted arrays tend to be encountered many times.\n  // Fortunately, we can reuse the Trie machinery to look up the sorted\n  // arrays in linear time (which is faster than sorting large arrays).\n  private sortedKeys(obj: object) {\n    const keys = Object.keys(obj);\n    const node = this.pool.lookupArray(keys);\n    if (!node.keys) {\n      keys.sort();\n      const json = JSON.stringify(keys);\n      if (!(node.keys = this.keysByJSON.get(json))) {\n        this.keysByJSON.set(json, (node.keys = { sorted: keys, json }));\n      }\n    }\n    return node.keys;\n  }\n  // Arrays that contain the same elements in a different order can share\n  // the same SortedKeysInfo object, to save memory.\n  private keysByJSON = new Map<string, SortedKeysInfo>();\n\n  // This has to come last because it depends on keysByJSON.\n  public readonly empty = this.admit({});\n}\n\ntype SortedKeysInfo = {\n  sorted: string[];\n  json: string;\n};\n","import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from \"graphql\";\nimport { wrap } from \"optimism\";\n\nimport type {\n  StoreObject,\n  Reference,\n  DeepPartial,\n  NoInfer,\n} from \"../../utilities/index.js\";\nimport {\n  Observable,\n  cacheSizes,\n  defaultCacheSizes,\n  getFragmentDefinition,\n  getFragmentQueryDocument,\n  mergeDeepArray,\n} from \"../../utilities/index.js\";\nimport type { DataProxy } from \"./types/DataProxy.js\";\nimport type { Cache } from \"./types/Cache.js\";\nimport { WeakCache } from \"@wry/caches\";\nimport { getApolloCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nimport type {\n  OperationVariables,\n  TypedDocumentNode,\n} from \"../../core/types.js\";\nimport type { MissingTree } from \"./types/common.js\";\nimport { equalByQuery } from \"../../core/equalByQuery.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { maskFragment } from \"../../masking/index.js\";\nimport type {\n  FragmentType,\n  MaybeMasked,\n  Unmasked,\n} from \"../../masking/index.js\";\nimport {\n  muteDeprecations,\n  warnRemovedOption,\n} from \"../../utilities/deprecation/index.js\";\n\nexport type Transaction<T> = (c: ApolloCache<T>) => void;\n\n/**\n * Watched fragment options.\n */\nexport interface WatchFragmentOptions<TData, TVars> {\n  /**\n   * A GraphQL fragment document parsed into an AST with the `gql`\n   * template literal.\n   *\n   * @docGroup 1. Required options\n   */\n  fragment: DocumentNode | TypedDocumentNode<TData, TVars>;\n  /**\n   * An object containing a `__typename` and primary key fields\n   * (such as `id`) identifying the entity object from which the fragment will\n   * be retrieved, or a `{ __ref: \"...\" }` reference, or a `string` ID\n   * (uncommon).\n   *\n   * @docGroup 1. Required options\n   */\n  from: StoreObject | Reference | FragmentType<NoInfer<TData>> | string;\n  /**\n   * Any variables that the GraphQL fragment may depend on.\n   *\n   * @docGroup 2. Cache options\n   */\n  variables?: TVars;\n  /**\n   * The name of the fragment defined in the fragment document.\n   *\n   * Required if the fragment document includes more than one fragment,\n   * optional otherwise.\n   *\n   * @docGroup 2. Cache options\n   */\n  fragmentName?: string;\n  /**\n   * If `true`, `watchFragment` returns optimistic results.\n   *\n   * The default value is `true`.\n   *\n   * @docGroup 2. Cache options\n   */\n  optimistic?: boolean;\n}\n\n/**\n * Watched fragment results.\n */\nexport type WatchFragmentResult<TData> =\n  | {\n      data: MaybeMasked<TData>;\n      complete: true;\n      missing?: never;\n    }\n  | {\n      data: DeepPartial<MaybeMasked<TData>>;\n      complete: false;\n      missing: MissingTree;\n    };\n\nexport abstract class ApolloCache<TSerialized> implements DataProxy {\n  public readonly assumeImmutableResults: boolean = false;\n\n  // required to implement\n  // core API\n  public abstract read<TData = any, TVariables = any>(\n    query: Cache.ReadOptions<TVariables, TData>\n  ): Unmasked<TData> | null;\n  public abstract write<TData = any, TVariables = any>(\n    write: Cache.WriteOptions<TData, TVariables>\n  ): Reference | undefined;\n  public abstract diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T>;\n  public abstract watch<TData = any, TVariables = any>(\n    watch: Cache.WatchOptions<TData, TVariables>\n  ): () => void;\n\n  // Empty the cache and restart all current watches (unless\n  // options.discardWatches is true).\n  public abstract reset(options?: Cache.ResetOptions): Promise<void>;\n\n  // Remove whole objects from the cache by passing just options.id, or\n  // specific fields by passing options.field and/or options.args. If no\n  // options.args are provided, all fields matching options.field (even\n  // those with arguments) will be removed. Returns true iff any data was\n  // removed from the cache.\n  public abstract evict(options: Cache.EvictOptions): boolean;\n\n  // initializer / offline / ssr API\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public abstract restore(\n    serializedState: TSerialized\n  ): ApolloCache<TSerialized>;\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public abstract extract(optimistic?: boolean): TSerialized;\n\n  // Optimistic API\n\n  public abstract removeOptimistic(id: string): void;\n\n  // Data masking API\n\n  // Used by data masking to determine if an inline fragment with a type\n  // condition matches a given typename.\n  //\n  // If not implemented by a cache subclass, data masking will effectively be\n  // disabled since we will not be able to accurately determine if a given type\n  // condition for a union or interface matches a particular type.\n  public fragmentMatches?(\n    fragment: InlineFragmentNode,\n    typename: string\n  ): boolean;\n\n  // Function used to lookup a fragment when a fragment definition is not part\n  // of the GraphQL document. This is useful for caches, such as InMemoryCache,\n  // that register fragments ahead of time so they can be referenced by name.\n  public lookupFragment(fragmentName: string): FragmentDefinitionNode | null {\n    return null;\n  }\n\n  // Transactional API\n\n  // The batch method is intended to replace/subsume both performTransaction\n  // and recordOptimisticTransaction, but performTransaction came first, so we\n  // provide a default batch implementation that's just another way of calling\n  // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n  // override the batch method to do more interesting things with its options.\n  public batch<U>(options: Cache.BatchOptions<this, U>): U {\n    const optimisticId =\n      typeof options.optimistic === \"string\" ? options.optimistic\n      : options.optimistic === false ? null\n      : void 0;\n    let updateResult: U;\n    this.performTransaction(\n      () => (updateResult = options.update(this)),\n      optimisticId\n    );\n    return updateResult!;\n  }\n\n  public abstract performTransaction(\n    transaction: Transaction<TSerialized>,\n    // Although subclasses may implement recordOptimisticTransaction\n    // however they choose, the default implementation simply calls\n    // performTransaction with a string as the second argument, allowing\n    // performTransaction to handle both optimistic and non-optimistic\n    // (broadcast-batching) transactions. Passing null for optimisticId is\n    // also allowed, and indicates that performTransaction should apply\n    // the transaction non-optimistically (ignoring optimistic data).\n    optimisticId?: string | null\n  ): void;\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<TSerialized>,\n    optimisticId: string\n  ) {\n    this.performTransaction(transaction, optimisticId);\n  }\n\n  // Optional API\n\n  // Called once per input document, allowing the cache to make static changes\n  // to the query, such as adding __typename fields.\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  // Called before each ApolloLink request, allowing the cache to make dynamic\n  // changes to the query, such as filling in missing fragment definitions.\n  public transformForLink(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  public identify(object: StoreObject | Reference): string | undefined {\n    return;\n  }\n\n  public gc(): string[] {\n    return [];\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    return false;\n  }\n\n  // DataProxy API\n  public readQuery<QueryType, TVariables = any>(\n    options: Cache.ReadQueryOptions<QueryType, TVariables>,\n    optimistic = !!options.optimistic\n  ): Unmasked<QueryType> | null {\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"cache.readQuery\");\n    }\n\n    return muteDeprecations(\"canonizeResults\", () =>\n      this.read({\n        ...options,\n        rootId: options.id || \"ROOT_QUERY\",\n        optimistic,\n      })\n    );\n  }\n\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  public watchFragment<TData = any, TVars = OperationVariables>(\n    options: WatchFragmentOptions<TData, TVars>\n  ): Observable<WatchFragmentResult<TData>> {\n    const {\n      fragment,\n      fragmentName,\n      from,\n      optimistic = true,\n      ...otherOptions\n    } = options;\n    const query = this.getFragmentDoc(fragment, fragmentName);\n    // While our TypeScript types do not allow for `undefined` as a valid\n    // `from`, its possible `useFragment` gives us an `undefined` since it\n    // calls` cache.identify` and provides that value to `from`. We are\n    // adding this fix here however to ensure those using plain JavaScript\n    // and using `cache.identify` themselves will avoid seeing the obscure\n    // warning.\n    const id =\n      typeof from === \"undefined\" || typeof from === \"string\" ?\n        from\n      : this.identify(from);\n    const dataMasking = !!(options as any)[Symbol.for(\"apollo.dataMasking\")];\n\n    if (__DEV__) {\n      const actualFragmentName =\n        fragmentName || getFragmentDefinition(fragment).name.value;\n\n      if (!id) {\n        invariant.warn(\n          \"Could not identify object passed to `from` for '%s' fragment, either because the object is non-normalized or the key fields are missing. If you are masking this object, please ensure the key fields are requested by the parent object.\",\n          actualFragmentName\n        );\n      }\n    }\n\n    const diffOptions: Cache.DiffOptions<TData, TVars> = {\n      ...otherOptions,\n      returnPartialData: true,\n      id,\n      query,\n      optimistic,\n    };\n\n    let latestDiff: DataProxy.DiffResult<TData> | undefined;\n\n    return new Observable((observer) => {\n      return this.watch<TData, TVars>({\n        ...diffOptions,\n        immediate: true,\n        callback: (diff) => {\n          const data =\n            dataMasking ?\n              maskFragment(diff.result, fragment, this, fragmentName)\n            : diff.result;\n\n          if (\n            // Always ensure we deliver the first result\n            latestDiff &&\n            equalByQuery(\n              query,\n              { data: latestDiff.result },\n              { data },\n              // TODO: Fix the type on WatchFragmentOptions so that TVars\n              // extends OperationVariables\n              options.variables as OperationVariables\n            )\n          ) {\n            return;\n          }\n\n          const result = {\n            data,\n            complete: !!diff.complete,\n          } as WatchFragmentResult<TData>;\n\n          if (diff.missing) {\n            result.missing = mergeDeepArray(\n              diff.missing.map((error) => error.missing)\n            );\n          }\n\n          latestDiff = { ...diff, result: data };\n          observer.next(result);\n        },\n      });\n    });\n  }\n\n  // Make sure we compute the same (===) fragment query document every\n  // time we receive the same fragment in readFragment.\n  private getFragmentDoc = wrap(getFragmentQueryDocument, {\n    max:\n      cacheSizes[\"cache.fragmentQueryDocuments\"] ||\n      defaultCacheSizes[\"cache.fragmentQueryDocuments\"],\n    cache: WeakCache,\n  });\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: Cache.ReadFragmentOptions<FragmentType, TVariables>,\n    optimistic = !!options.optimistic\n  ): Unmasked<FragmentType> | null {\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"cache.readFragment\");\n    }\n\n    return muteDeprecations(\"canonizeResults\", () =>\n      this.read({\n        ...options,\n        query: this.getFragmentDoc(options.fragment, options.fragmentName),\n        rootId: options.id,\n        optimistic,\n      })\n    );\n  }\n\n  public writeQuery<TData = any, TVariables = any>({\n    id,\n    data,\n    ...options\n  }: Cache.WriteQueryOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        dataId: id || \"ROOT_QUERY\",\n        result: data,\n      })\n    );\n  }\n\n  public writeFragment<TData = any, TVariables = any>({\n    id,\n    data,\n    fragment,\n    fragmentName,\n    ...options\n  }: Cache.WriteFragmentOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        query: this.getFragmentDoc(fragment, fragmentName),\n        dataId: id,\n        result: data,\n      })\n    );\n  }\n\n  public updateQuery<TData = any, TVariables = any>(\n    options: Cache.UpdateQueryOptions<TData, TVariables>,\n    update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void\n  ): Unmasked<TData> | null {\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"cache.updateQuery\");\n    }\n\n    return this.batch({\n      update(cache) {\n        const value = muteDeprecations(\"canonizeResults\", () =>\n          cache.readQuery<TData, TVariables>(options)\n        );\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeQuery<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  public updateFragment<TData = any, TVariables = any>(\n    options: Cache.UpdateFragmentOptions<TData, TVariables>,\n    update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void\n  ): Unmasked<TData> | null {\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"cache.updateFragment\");\n    }\n\n    return this.batch({\n      update(cache) {\n        const value = muteDeprecations(\"canonizeResults\", () =>\n          cache.readFragment<TData, TVariables>(options)\n        );\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeFragment<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  /**\n   * @experimental\n   * @internal\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   */\n  public getMemoryInternals?: typeof getApolloCacheMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}\n","import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\n\nimport type { DocumentNode, FieldNode, SelectionSetNode } from \"graphql\";\nimport { Kind } from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\n\nimport type {\n  Reference,\n  StoreObject,\n  FragmentMap,\n  FragmentMapFunction,\n} from \"../../utilities/index.js\";\nimport {\n  isField,\n  resultKeyNameFromField,\n  isReference,\n  makeReference,\n  shouldInclude,\n  addTypenameToDocument,\n  getDefaultValues,\n  getMainDefinition,\n  getQueryDefinition,\n  getFragmentFromSelection,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  DeepMerger,\n  isNonNullObject,\n  canUseWeakMap,\n  compact,\n  canonicalStringify,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../../utilities/index.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type {\n  DiffQueryAgainstStoreOptions,\n  InMemoryCacheConfig,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport {\n  maybeDependOnExistenceOfEntity,\n  supportsResultCaching,\n} from \"./entityStore.js\";\nimport {\n  isArray,\n  extractFragmentContext,\n  getTypenameFromStoreObject,\n  shouldCanonizeResults,\n} from \"./helpers.js\";\nimport type { Policies } from \"./policies.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { MissingTree } from \"../core/types/common.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { ObjectCanon } from \"./object-canon.js\";\n\nexport type VariableMap = { [name: string]: any };\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#canonizeResults:member} */\n  canonizeResults: boolean;\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n}\n\nexport type ExecResult<R = any> = {\n  result: R;\n  missing?: MissingTree;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: readonly any[];\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\nexport interface StoreReaderConfig {\n  cache: InMemoryCache;\n  addTypename?: boolean;\n  resultCacheMaxSize?: number;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#canonizeResults:member} */\n  canonizeResults?: boolean;\n  canon?: ObjectCanon;\n  fragments?: InMemoryCacheConfig[\"fragments\"];\n}\n\n// Arguments type after keyArgs translation.\ntype ExecSelectionSetKeyArgs = [\n  SelectionSetNode,\n  StoreObject | Reference,\n  ReadMergeModifyContext,\n  boolean,\n];\n\nfunction execSelectionSetKeyArgs(\n  options: ExecSelectionSetOptions\n): ExecSelectionSetKeyArgs {\n  return [\n    options.selectionSet,\n    options.objectOrReference,\n    options.context,\n    // We split out this property so we can pass different values\n    // independently without modifying options.context itself.\n    options.context.canonizeResults,\n  ];\n}\n\nexport class StoreReader {\n  // cached version of executeSelectionSet\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    ExecSelectionSetKeyArgs\n  >;\n\n  // cached version of executeSubSelectedArray\n  private executeSubSelectedArray: OptimisticWrapperFunction<\n    [ExecSubSelectedArrayOptions],\n    ExecResult<any>,\n    [ExecSubSelectedArrayOptions]\n  >;\n\n  private config: {\n    cache: InMemoryCache;\n    addTypename: boolean;\n    resultCacheMaxSize?: number;\n    canonizeResults: boolean;\n    fragments?: InMemoryCacheConfig[\"fragments\"];\n  };\n\n  private knownResults = new (canUseWeakMap ? WeakMap : Map)<\n    Record<string, any>,\n    SelectionSetNode\n  >();\n\n  public canon: ObjectCanon;\n  public resetCanon() {\n    this.canon = new ObjectCanon();\n  }\n\n  constructor(config: StoreReaderConfig) {\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config),\n    });\n\n    this.canon = config.canon || new ObjectCanon();\n\n    // memoized functions in this class will be \"garbage-collected\"\n    // by recreating the whole `StoreReader` in\n    // `InMemoryCache.resetResultsCache`\n    // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n    this.executeSelectionSet = wrap(\n      (options) => {\n        const { canonizeResults } = options.context;\n\n        const peekArgs = execSelectionSetKeyArgs(options);\n\n        // Negate this boolean option so we can find out if we've already read\n        // this result using the other boolean value.\n        peekArgs[3] = !canonizeResults;\n\n        const other = this.executeSelectionSet.peek(...peekArgs);\n\n        if (other) {\n          if (canonizeResults) {\n            return {\n              ...other,\n              // If we previously read this result without canonizing it, we can\n              // reuse that result simply by canonizing it now.\n              result: this.canon.admit(other.result),\n            };\n          }\n          // If we previously read this result with canonization enabled, we can\n          // return that canonized result as-is.\n          return other;\n        }\n\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n\n        // Finally, if we didn't find any useful previous results, run the real\n        // execSelectionSetImpl method with the given options.\n        return this.execSelectionSetImpl(options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.executeSelectionSet\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"],\n        keyArgs: execSelectionSetKeyArgs,\n        // Note that the parameters of makeCacheKey are determined by the\n        // array returned by keyArgs.\n        makeCacheKey(selectionSet, parent, context, canonizeResults) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(\n              selectionSet,\n              isReference(parent) ? parent.__ref : parent,\n              context.varString,\n              canonizeResults\n            );\n          }\n        },\n      }\n    );\n\n    this.executeSubSelectedArray = wrap(\n      (options: ExecSubSelectedArrayOptions) => {\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n        return this.execSubSelectedArrayImpl(options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] ||\n          defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"],\n        makeCacheKey({ field, array, context }) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(field, array, context.varString);\n          }\n        },\n      }\n    );\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = \"ROOT_QUERY\",\n    variables,\n    returnPartialData = true,\n    canonizeResults = this.config.canonizeResults,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables!,\n    };\n\n    const rootRef = makeReference(rootId);\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: canonicalStringify(variables),\n        canonizeResults,\n        ...extractFragmentContext(query, this.config.fragments),\n      },\n    });\n\n    let missing: MissingFieldError[] | undefined;\n    if (execResult.missing) {\n      // For backwards compatibility we still report an array of\n      // MissingFieldError objects, even though there will only ever be at most\n      // one of them, now that all missing field error messages are grouped\n      // together in the execResult.missing tree.\n      missing = [\n        new MissingFieldError(\n          firstMissing(execResult.missing)!,\n          execResult.missing,\n          query,\n          variables\n        ),\n      ];\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing,\n    };\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext\n  ): boolean {\n    if (\n      supportsResultCaching(context.store) &&\n      this.knownResults.get(result) === selectionSet\n    ) {\n      const latest = this.executeSelectionSet.peek(\n        selectionSet,\n        parent,\n        context,\n        // If result is canonical, then it could only have been previously\n        // cached by the canonizing version of executeSelectionSet, so we can\n        // avoid checking both possibilities here.\n        this.canon.isKnown(result)\n      );\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    enclosingRef,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (\n      isReference(objectOrReference) &&\n      !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n      !context.store.has(objectOrReference.__ref)\n    ) {\n      return {\n        result: this.canon.empty,\n        missing: `Dangling reference to missing ${objectOrReference.__ref} object`,\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const typename = store.getFieldValue<string>(\n      objectOrReference,\n      \"__typename\"\n    );\n\n    const objectsToMerge: Record<string, any>[] = [];\n    let missing: MissingTree | undefined;\n    const missingMerger = new DeepMerger();\n\n    if (\n      this.config.addTypename &&\n      typeof typename === \"string\" &&\n      !policies.rootIdsByTypename[typename]\n    ) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function handleMissing<T>(result: ExecResult<T>, resultName: string): T {\n      if (result.missing) {\n        missing = missingMerger.merge(missing, {\n          [resultName]: result.missing,\n        });\n      }\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach((selection) => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField(\n          {\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables,\n            from: objectOrReference,\n          },\n          context\n        );\n\n        const resultName = resultKeyNameFromField(selection);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, {\n              [resultName]: `Can't find field '${selection.name.value}' on ${\n                isReference(objectOrReference) ?\n                  objectOrReference.__ref + \" object\"\n                : \"object \" + JSON.stringify(objectOrReference, null, 2)\n              }`,\n            });\n          }\n        } else if (isArray(fieldValue)) {\n          if (fieldValue.length > 0) {\n            fieldValue = handleMissing(\n              this.executeSubSelectedArray({\n                field: selection,\n                array: fieldValue,\n                enclosingRef,\n                context,\n              }),\n              resultName\n            );\n          }\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(\n            this.executeSelectionSet({\n              selectionSet: selection.selectionSet,\n              objectOrReference: fieldValue as StoreObject | Reference,\n              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n              context,\n            }),\n            resultName\n          );\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.lookupFragment\n        );\n\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(`No fragment named %s`, selection.name.value);\n        }\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    const result = mergeDeepArray(objectsToMerge);\n    const finalResult: ExecResult = { result, missing };\n    const frozen =\n      context.canonizeResults ?\n        this.canon.admit(finalResult)\n        // Since this.canon is normally responsible for freezing results (only in\n        // development), freeze them manually if canonization is disabled.\n      : maybeDeepFreeze(finalResult);\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n\n    return frozen;\n  }\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    enclosingRef,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingTree | undefined;\n    let missingMerger = new DeepMerger<MissingTree[]>();\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, { [i]: childResult.missing });\n      }\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(\n          this.executeSubSelectedArray({\n            field,\n            array: item,\n            enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(\n          this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            objectOrReference: item,\n            enclosingRef: isReference(item) ? item : enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      return item;\n    });\n\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing,\n    };\n  }\n}\n\nfunction firstMissing(tree: MissingTree): string | undefined {\n  try {\n    JSON.stringify(tree, (_, value) => {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result as string;\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach((value) => {\n      if (isNonNullObject(value)) {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type %s returned for query field %s`,\n          getTypenameFromStoreObject(store, value),\n          field.name.value\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n","import type { ASTNode } from \"graphql\";\nimport { print } from \"../../utilities/index.js\";\n\nimport type { Operation } from \"../core/index.js\";\n\nexport interface Printer {\n  (node: ASTNode, originalPrint: typeof print): string;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: typeof fetch;\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * If set to true, header names won't be automatically normalized to\n   * lowercase. This allows for non-http-spec-compliant servers that might\n   * expect capitalized header names.\n   */\n  preserveHeaderCase?: boolean;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n\n  /**\n   * If set to true, use the HTTP GET method for query operations. Mutations\n   * will still use the method specified in fetchOptions.method (which defaults\n   * to POST).\n   */\n  useGETForQueries?: boolean;\n\n  /**\n   * If set to true, the default behavior of stripping unused variables\n   * from the request will be disabled.\n   *\n   * Unused variables are likely to trigger server-side validation errors,\n   * per https://spec.graphql.org/draft/#sec-All-Variables-Used, but this\n   * includeUnusedVariables option can be useful if your server deviates\n   * from the GraphQL specification by not strictly enforcing that rule.\n   */\n  includeUnusedVariables?: boolean;\n  /**\n   * A function to substitute for the default query print function. Can be\n   * used to apply changes to the results of the print function.\n   */\n  print?: Printer;\n}\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n  preserveHeaderCase?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: Record<string, string>;\n  credentials?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n  preserveHeaderCase: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: \"*/*\",\n  // The content-type header describes the type of the body of the request, and\n  // so it typically only is sent with requests that actually have bodies. One\n  // could imagine that Apollo Client would remove this header when constructing\n  // a GET request (which has no body), but we historically have not done that.\n  // This means that browsers will preflight all Apollo Client requests (even\n  // GET requests). Apollo Server's CSRF prevention feature (introduced in\n  // AS3.7) takes advantage of this fact and does not block requests with this\n  // header. If you want to drop this header from GET requests, then you should\n  // probably replace it with a `apollo-require-preflight` header, or servers\n  // with CSRF prevention enabled might block your GET request. See\n  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf\n  // for more details.\n  \"content-type\": \"application/json\",\n};\n\nconst defaultOptions = {\n  method: \"POST\",\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const defaultPrinter: Printer = (ast, printer) => printer(ast);\n\nexport function selectHttpOptionsAndBody(\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) {\n  configs.unshift(fallbackConfig);\n  return selectHttpOptionsAndBodyInternal(\n    operation,\n    defaultPrinter,\n    ...configs\n  );\n}\n\nexport function selectHttpOptionsAndBodyInternal(\n  operation: Operation,\n  printer: Printer,\n  ...configs: HttpConfig[]\n) {\n  let options = {} as HttpConfig & Record<string, any>;\n  let http = {} as HttpQueryOptions;\n\n  configs.forEach((config) => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n\n    if (config.credentials) {\n      options.credentials = config.credentials;\n    }\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  if (options.headers) {\n    options.headers = removeDuplicateHeaders(\n      options.headers,\n      http.preserveHeaderCase\n    );\n  }\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = printer(query, print);\n\n  return {\n    options,\n    body,\n  };\n}\n\n// Remove potential duplicate header names, preserving last (by insertion order).\n// This is done to prevent unintentionally duplicating a header instead of\n// overwriting it (See #8447 and #8449).\nfunction removeDuplicateHeaders(\n  headers: Record<string, string>,\n  preserveHeaderCase: boolean | undefined\n): typeof headers {\n  // If we're not preserving the case, just remove duplicates w/ normalization.\n  if (!preserveHeaderCase) {\n    const normalizedHeaders: Record<string, string> = {};\n    Object.keys(Object(headers)).forEach((name) => {\n      normalizedHeaders[name.toLowerCase()] = headers[name];\n    });\n    return normalizedHeaders;\n  }\n\n  // If we are preserving the case, remove duplicates w/ normalization,\n  // preserving the original name.\n  // This allows for non-http-spec-compliant servers that expect intentionally\n  // capitalized header names (See #6741).\n  const headerData: Record<string, { originalName: string; value: string }> =\n    {};\n  Object.keys(Object(headers)).forEach((name) => {\n    headerData[name.toLowerCase()] = {\n      originalName: name,\n      value: headers[name],\n    };\n  });\n\n  const normalizedHeaders: Record<string, string> = {};\n  Object.keys(headerData).forEach((name) => {\n    normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n  });\n  return normalizedHeaders;\n}\n","import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"rehackt\";\nimport type * as ReactTypes from \"react\";\n\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { getApolloContext } from \"./ApolloContext.js\";\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: ReactTypes.ReactNode | ReactTypes.ReactNode[] | null;\n}\n\nexport const ApolloProvider: ReactTypes.FC<ApolloProviderProps<any>> = ({\n  client,\n  children,\n}) => {\n  const ApolloContext = getApolloContext();\n  const parentContext = React.useContext(ApolloContext);\n\n  const context = React.useMemo(() => {\n    return {\n      ...parentContext,\n      client: client || parentContext.client,\n    };\n  }, [parentContext, client]);\n\n  invariant(\n    context.client,\n    \"ApolloProvider was not passed a client instance. Make \" +\n      'sure you pass in your client via the \"client\" prop.'\n  );\n\n  return (\n    <ApolloContext.Provider value={context}>{children}</ApolloContext.Provider>\n  );\n};\n","import { invariant } from \"../../utilities/globals/index.js\";\n\nimport type { DefinitionNode } from \"graphql\";\n\nimport { ApolloLink } from \"../core/index.js\";\nimport { Observable, hasDirectives } from \"../../utilities/index.js\";\nimport { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport { selectURI } from \"./selectURI.js\";\nimport {\n  handleError,\n  readMultipartBody,\n  parseAndCheckHttpResponse,\n} from \"./parseAndCheckHttpResponse.js\";\nimport { checkFetcher } from \"./checkFetcher.js\";\nimport type { HttpOptions } from \"./selectHttpOptionsAndBody.js\";\nimport {\n  selectHttpOptionsAndBodyInternal,\n  defaultPrinter,\n  fallbackHttpConfig,\n} from \"./selectHttpOptionsAndBody.js\";\nimport { rewriteURIForGET } from \"./rewriteURIForGET.js\";\nimport { fromError, filterOperationVariables } from \"../utils/index.js\";\nimport {\n  maybe,\n  getMainDefinition,\n  removeClientSetsFromDocument,\n} from \"../../utilities/index.js\";\n\nconst backupFetch = maybe(() => fetch);\n\nexport const createHttpLink = (linkOptions: HttpOptions = {}) => {\n  let {\n    uri = \"/graphql\",\n    // use default global fetch if nothing passed in\n    fetch: preferredFetch,\n    print = defaultPrinter,\n    includeExtensions,\n    preserveHeaderCase,\n    useGETForQueries,\n    includeUnusedVariables = false,\n    ...requestOptions\n  } = linkOptions;\n\n  if (__DEV__) {\n    // Make sure at least one of preferredFetch, window.fetch, or backupFetch is\n    // defined, so requests won't fail at runtime.\n    checkFetcher(preferredFetch || backupFetch);\n  }\n\n  const linkConfig = {\n    http: { includeExtensions, preserveHeaderCase },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink((operation) => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    const clientAwarenessHeaders: {\n      \"apollographql-client-name\"?: string;\n      \"apollographql-client-version\"?: string;\n    } = {};\n\n    if (context.clientAwareness) {\n      const { name, version } = context.clientAwareness;\n      if (name) {\n        clientAwarenessHeaders[\"apollographql-client-name\"] = name;\n      }\n      if (version) {\n        clientAwarenessHeaders[\"apollographql-client-version\"] = version;\n      }\n    }\n\n    const contextHeaders = { ...clientAwarenessHeaders, ...context.headers };\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders,\n    };\n\n    if (hasDirectives([\"client\"], operation.query)) {\n      if (__DEV__) {\n        invariant.warn(\n          \"[HttpLink]: Apollo Client 4.0 will no longer remove `@client` fields from queries sent through the link chain. Please open an issue if this warning is displayed under standard usage.\"\n        );\n      }\n      const transformedQuery = removeClientSetsFromDocument(operation.query);\n\n      if (!transformedQuery) {\n        return fromError(\n          new Error(\n            \"HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`.\"\n          )\n        );\n      }\n\n      operation.query = transformedQuery;\n    }\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBodyInternal(\n      operation,\n      print,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig\n    );\n\n    if (body.variables && !includeUnusedVariables) {\n      body.variables = filterOperationVariables(\n        body.variables,\n        operation.query\n      );\n    }\n\n    let controller: AbortController | undefined;\n    if (!options.signal && typeof AbortController !== \"undefined\") {\n      controller = new AbortController();\n      options.signal = controller.signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === \"OperationDefinition\" && d.operation === \"mutation\";\n    };\n    const definitionIsSubscription = (d: DefinitionNode) => {\n      return d.kind === \"OperationDefinition\" && d.operation === \"subscription\";\n    };\n    const isSubscription = definitionIsSubscription(\n      getMainDefinition(operation.query)\n    );\n    // does not match custom directives beginning with @defer\n    const hasDefer = hasDirectives([\"defer\"], operation.query);\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = \"GET\";\n    }\n\n    if (hasDefer || isSubscription) {\n      options.headers = options.headers || {};\n      let acceptHeader = \"multipart/mixed;\";\n      // Omit defer-specific headers if the user attempts to defer a selection\n      // set on a subscription and log a warning.\n      if (isSubscription && hasDefer) {\n        invariant.warn(\"Multipart-subscriptions do not support @defer\");\n      }\n\n      if (isSubscription) {\n        acceptHeader +=\n          \"boundary=graphql;subscriptionSpec=1.0,application/json\";\n      } else if (hasDefer) {\n        acceptHeader += \"deferSpec=20220824,application/json\";\n      }\n      options.headers.accept = acceptHeader;\n    }\n\n    if (options.method === \"GET\") {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, \"Payload\");\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable((observer) => {\n      // Prefer linkOptions.fetch (preferredFetch) if provided, and otherwise\n      // fall back to the *current* global window.fetch function (see issue\n      // #7832), or (if all else fails) the backupFetch function we saved when\n      // this module was first evaluated. This last option protects against the\n      // removal of window.fetch, which is unlikely but not impossible.\n      const currentFetch = preferredFetch || maybe(() => fetch) || backupFetch;\n\n      const observerNext = observer.next.bind(observer);\n      currentFetch!(chosenURI, options)\n        .then((response) => {\n          operation.setContext({ response });\n          const ctype = response.headers?.get(\"content-type\");\n\n          if (ctype !== null && /^multipart\\/mixed/i.test(ctype)) {\n            return readMultipartBody(response, observerNext);\n          } else {\n            return parseAndCheckHttpResponse(operation)(response).then(\n              observerNext\n            );\n          }\n        })\n        .then(() => {\n          controller = undefined;\n          observer.complete();\n        })\n        .catch((err) => {\n          controller = undefined;\n          handleError(err, observer);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n","import type {\n  Observer,\n  ObservableSubscription,\n  Subscriber,\n} from \"./Observable.js\";\nimport { Observable } from \"./Observable.js\";\nimport { iterateObserversSafely } from \"./iteration.js\";\nimport { fixObservableSubclass } from \"./subclassing.js\";\n\ntype MaybeAsync<T> = T | PromiseLike<T>;\n\nfunction isPromiseLike<T>(value: MaybeAsync<T>): value is PromiseLike<T> {\n  return value && typeof (value as any).then === \"function\";\n}\n\n// Any individual Source<T> can be an Observable<T> or a promise for one.\ntype Source<T> = MaybeAsync<Observable<T>>;\n\nexport type ConcastSourcesIterable<T> = Iterable<Source<T>>;\nexport type ConcastSourcesArray<T> = Array<Source<T>>;\n\n// A Concast<T> observable concatenates the given sources into a single\n// non-overlapping sequence of Ts, automatically unwrapping any promises,\n// and broadcasts the T elements of that sequence to any number of\n// subscribers, all without creating a bunch of intermediary Observable\n// wrapper objects.\n//\n// Even though any number of observers can subscribe to the Concast, each\n// source observable is guaranteed to receive at most one subscribe call,\n// and the results are multicast to all observers.\n//\n// In addition to broadcasting every next/error message to this.observers,\n// the Concast stores the most recent message using this.latest, so any\n// new observers can immediately receive the latest message, even if it\n// was originally delivered in the past. This behavior means we can assume\n// every active observer in this.observers has received the same most\n// recent message.\n//\n// With the exception of this.latest replay, a Concast is a \"hot\"\n// observable in the sense that it does not replay past results from the\n// beginning of time for each new observer.\n//\n// Could we have used some existing RxJS class instead? Concast<T> is\n// similar to a BehaviorSubject<T>, because it is multicast and redelivers\n// the latest next/error message to new subscribers. Unlike Subject<T>,\n// Concast<T> does not expose an Observer<T> interface (this.handlers is\n// intentionally private), since Concast<T> gets its inputs from the\n// concatenated sources. If we ever switch to RxJS, there may be some\n// value in reusing their code, but for now we use zen-observable, which\n// does not contain any Subject implementations.\nexport class Concast<T> extends Observable<T> {\n  // Active observers receiving broadcast messages. Thanks to this.latest,\n  // we can assume all observers in this Set have received the same most\n  // recent message, though possibly at different times in the past.\n  private observers = new Set<Observer<T>>();\n\n  // This property starts off undefined to indicate the initial\n  // subscription has not yet begun, then points to each source\n  // subscription in turn, and finally becomes null after the sources have\n  // been exhausted. After that, it stays null.\n  private sub?: ObservableSubscription | null;\n\n  // Not only can the individual elements of the iterable be promises, but\n  // also the iterable itself can be wrapped in a promise.\n  constructor(sources: MaybeAsync<ConcastSourcesIterable<T>> | Subscriber<T>) {\n    super((observer) => {\n      this.addObserver(observer);\n      return () => this.removeObserver(observer);\n    });\n\n    // Suppress rejection warnings for this.promise, since it's perfectly\n    // acceptable to pay no attention to this.promise if you're consuming\n    // the results through the normal observable API.\n    this.promise.catch((_) => {});\n\n    // If someone accidentally tries to create a Concast using a subscriber\n    // function, recover by creating an Observable from that subscriber and\n    // using it as the source.\n    if (typeof sources === \"function\") {\n      sources = [new Observable(sources)];\n    }\n\n    if (isPromiseLike(sources)) {\n      sources.then((iterable) => this.start(iterable), this.handlers.error);\n    } else {\n      this.start(sources);\n    }\n  }\n\n  // A consumable array of source observables, incrementally consumed each time\n  // this.handlers.complete is called. This private field is not initialized\n  // until the concast.start method is called, which can happen asynchronously\n  // if a Promise is passed to the Concast constructor, so undefined is a\n  // possible value for this.sources before concast.start is called.\n  private sources: Source<T>[] | undefined;\n\n  private start(sources: ConcastSourcesIterable<T>) {\n    if (this.sub !== void 0) return;\n\n    // In practice, sources is most often simply an Array of observables.\n    // TODO Consider using sources[Symbol.iterator]() to take advantage\n    // of the laziness of non-Array iterables.\n    this.sources = Array.from(sources);\n\n    // Calling this.handlers.complete() kicks off consumption of the first\n    // source observable. It's tempting to do this step lazily in\n    // addObserver, but this.promise can be accessed without calling\n    // addObserver, so consumption needs to begin eagerly.\n    this.handlers.complete();\n  }\n\n  private deliverLastMessage(observer: Observer<T>) {\n    if (this.latest) {\n      const nextOrError = this.latest[0];\n      const method = observer[nextOrError];\n      if (method) {\n        method.call(observer, this.latest[1]);\n      }\n      // If the subscription is already closed, and the last message was\n      // a 'next' message, simulate delivery of the final 'complete'\n      // message again.\n      if (this.sub === null && nextOrError === \"next\" && observer.complete) {\n        observer.complete();\n      }\n    }\n  }\n\n  public addObserver(observer: Observer<T>) {\n    if (!this.observers.has(observer)) {\n      // Immediately deliver the most recent message, so we can always\n      // be sure all observers have the latest information.\n      this.deliverLastMessage(observer);\n      this.observers.add(observer);\n    }\n  }\n\n  public removeObserver(observer: Observer<T>) {\n    if (this.observers.delete(observer) && this.observers.size < 1) {\n      // In case there are still any listeners in this.nextResultListeners, and\n      // no error or completion has been broadcast yet, make sure those\n      // observers have a chance to run and then remove themselves from\n      // this.observers.\n      this.handlers.complete();\n    }\n  }\n\n  // Any Concast object can be trivially converted to a Promise, without\n  // having to create a new wrapper Observable. This promise provides an\n  // easy way to observe the final state of the Concast.\n  private resolve!: (result?: T | PromiseLike<T>) => void;\n  private reject!: (reason: any) => void;\n  public readonly promise = new Promise<T | undefined>((resolve, reject) => {\n    this.resolve = resolve;\n    this.reject = reject;\n  });\n\n  // Name and argument of the most recently invoked observer method, used\n  // to deliver latest results immediately to new observers.\n  private latest?: [\"next\", T] | [\"error\", any];\n\n  // Bound handler functions that can be reused for every internal\n  // subscription.\n  private handlers = {\n    next: (result: T) => {\n      if (this.sub !== null) {\n        this.latest = [\"next\", result];\n        this.notify(\"next\", result);\n        iterateObserversSafely(this.observers, \"next\", result);\n      }\n    },\n\n    error: (error: any) => {\n      const { sub } = this;\n      if (sub !== null) {\n        // Delay unsubscribing from the underlying subscription slightly,\n        // so that immediately subscribing another observer can keep the\n        // subscription active.\n        if (sub) setTimeout(() => sub.unsubscribe());\n        this.sub = null;\n        this.latest = [\"error\", error];\n        this.reject(error);\n        this.notify(\"error\", error);\n        iterateObserversSafely(this.observers, \"error\", error);\n      }\n    },\n\n    complete: () => {\n      const { sub, sources = [] } = this;\n      if (sub !== null) {\n        // If complete is called before concast.start, this.sources may be\n        // undefined, so we use a default value of [] for sources. That works\n        // here because it falls into the if (!value) {...} block, which\n        // appropriately terminates the Concast, even if this.sources might\n        // eventually have been initialized to a non-empty array.\n        const value = sources.shift();\n        if (!value) {\n          if (sub) setTimeout(() => sub.unsubscribe());\n          this.sub = null;\n          if (this.latest && this.latest[0] === \"next\") {\n            this.resolve(this.latest[1]);\n          } else {\n            this.resolve();\n          }\n          this.notify(\"complete\");\n          // We do not store this.latest = [\"complete\"], because doing so\n          // discards useful information about the previous next (or\n          // error) message. Instead, if new observers subscribe after\n          // this Concast has completed, they will receive the final\n          // 'next' message (unless there was an error) immediately\n          // followed by a 'complete' message (see addObserver).\n          iterateObserversSafely(this.observers, \"complete\");\n        } else if (isPromiseLike(value)) {\n          value.then(\n            (obs) => (this.sub = obs.subscribe(this.handlers)),\n            this.handlers.error\n          );\n        } else {\n          this.sub = value.subscribe(this.handlers);\n        }\n      }\n    },\n  };\n\n  private nextResultListeners = new Set<NextResultListener>();\n\n  private notify(\n    method: Parameters<NextResultListener>[0],\n    arg?: Parameters<NextResultListener>[1]\n  ) {\n    const { nextResultListeners } = this;\n    if (nextResultListeners.size) {\n      // Replacing this.nextResultListeners first ensures it does not grow while\n      // we are iterating over it, potentially leading to infinite loops.\n      this.nextResultListeners = new Set();\n      nextResultListeners.forEach((listener) => listener(method, arg));\n    }\n  }\n\n  // We need a way to run callbacks just *before* the next result (or error or\n  // completion) is delivered by this Concast, so we can be sure any code that\n  // runs as a result of delivering that result/error observes the effects of\n  // running the callback(s). It was tempting to reuse the Observer type instead\n  // of introducing NextResultListener, but that messes with the sizing and\n  // maintenance of this.observers, and ends up being more code overall.\n  beforeNext(callback: NextResultListener) {\n    let called = false;\n    this.nextResultListeners.add((method, arg) => {\n      if (!called) {\n        called = true;\n        callback(method, arg);\n      }\n    });\n  }\n\n  // A public way to abort observation and broadcast.\n  public cancel = (reason: any) => {\n    this.reject(reason);\n    this.sources = [];\n    this.handlers.error(reason);\n  };\n}\n\ntype NextResultListener = (\n  method: \"next\" | \"error\" | \"complete\",\n  arg?: any\n) => any;\n\n// Necessary because the Concast constructor has a different signature\n// than the Observable constructor.\nfixObservableSubclass(Concast);\n","import type { DocumentNode, GraphQLFormattedError } from \"graphql\";\nimport { equal } from \"@wry/equality\";\n\nimport type { Cache, ApolloCache } from \"../cache/index.js\";\nimport { DeepMerger } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/index.js\";\nimport type { WatchQueryOptions, ErrorPolicy } from \"./watchQueryOptions.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport {\n  isNonEmptyArray,\n  graphQLResultHasError,\n  canUseWeakMap,\n} from \"../utilities/index.js\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nimport type { ApolloError } from \"../errors/index.js\";\nimport type { QueryManager } from \"./QueryManager.js\";\nimport type { Unmasked } from \"../masking/index.js\";\nimport { muteDeprecations } from \"../utilities/deprecation/index.js\";\n\nexport type QueryStoreValue = Pick<\n  QueryInfo,\n  \"variables\" | \"networkStatus\" | \"networkError\" | \"graphQLErrors\"\n>;\n\nexport const enum CacheWriteBehavior {\n  FORBID,\n  OVERWRITE,\n  MERGE,\n}\n\nconst destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)<\n  ApolloCache<any>,\n  number\n>();\n\nfunction wrapDestructiveCacheMethod(\n  cache: ApolloCache<any>,\n  methodName: \"evict\" | \"modify\" | \"reset\"\n) {\n  const original = cache[methodName];\n  if (typeof original === \"function\") {\n    // @ts-expect-error this is just too generic to be typed correctly\n    cache[methodName] = function () {\n      destructiveMethodCounts.set(\n        cache,\n        // The %1e15 allows the count to wrap around to 0 safely every\n        // quadrillion evictions, so there's no risk of overflow. To be\n        // clear, this is more of a pedantic principle than something\n        // that matters in any conceivable practical scenario.\n        (destructiveMethodCounts.get(cache)! + 1) % 1e15\n      );\n      // @ts-expect-error this is just too generic to be typed correctly\n      return original.apply(this, arguments);\n    };\n  }\n}\n\n// A QueryInfo object represents a single query managed by the\n// QueryManager, which tracks all QueryInfo objects by queryId in its\n// this.queries Map. QueryInfo objects store the latest results and errors\n// for the given query, and are responsible for reporting those results to\n// the corresponding ObservableQuery, via the QueryInfo.notify method.\n// Results are reported asynchronously whenever setDiff marks the\n// QueryInfo object as dirty, though a call to the QueryManager's\n// broadcastQueries method may trigger the notification before it happens\n// automatically. This class used to be a simple interface type without\n// any field privacy or meaningful methods, which is why it still has so\n// many public fields. The effort to lock down and simplify the QueryInfo\n// interface is ongoing, and further improvements are welcome.\nexport class QueryInfo {\n  document: DocumentNode | null = null;\n  lastRequestId = 1;\n  variables?: Record<string, any>;\n  networkStatus?: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLFormattedError>;\n  stopped = false;\n\n  private cancelWatch?: () => void;\n  private cache: ApolloCache<any>;\n\n  constructor(\n    queryManager: QueryManager<any>,\n    public readonly queryId = queryManager.generateQueryId()\n  ) {\n    const cache = (this.cache = queryManager.cache);\n\n    // Track how often cache.evict is called, since we want eviction to\n    // override the feud-stopping logic in the markResult method, by\n    // causing shouldWrite to return true. Wrapping the cache.evict method\n    // is a bit of a hack, but it saves us from having to make eviction\n    // counting an official part of the ApolloCache API.\n    if (!destructiveMethodCounts.has(cache)) {\n      destructiveMethodCounts.set(cache, 0);\n      wrapDestructiveCacheMethod(cache, \"evict\");\n      wrapDestructiveCacheMethod(cache, \"modify\");\n      wrapDestructiveCacheMethod(cache, \"reset\");\n    }\n  }\n\n  public init(query: {\n    document: DocumentNode;\n    variables: Record<string, any> | undefined;\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus?: NetworkStatus;\n    observableQuery?: ObservableQuery<any, any>;\n    lastRequestId?: number;\n  }): this {\n    let networkStatus = query.networkStatus || NetworkStatus.loading;\n    if (\n      this.variables &&\n      this.networkStatus !== NetworkStatus.loading &&\n      !equal(this.variables, query.variables)\n    ) {\n      networkStatus = NetworkStatus.setVariables;\n    }\n\n    if (!equal(query.variables, this.variables)) {\n      this.lastDiff = void 0;\n      // Ensure we don't continue to receive cache updates for old variables\n      this.cancel();\n    }\n\n    Object.assign(this, {\n      document: query.document,\n      variables: query.variables,\n      networkError: null,\n      graphQLErrors: this.graphQLErrors || [],\n      networkStatus,\n    });\n\n    if (query.observableQuery) {\n      this.setObservableQuery(query.observableQuery);\n    }\n\n    if (query.lastRequestId) {\n      this.lastRequestId = query.lastRequestId;\n    }\n\n    return this;\n  }\n\n  resetDiff() {\n    this.lastDiff = void 0;\n  }\n\n  getDiff(): Cache.DiffResult<any> {\n    const options = this.getDiffOptions();\n\n    if (this.lastDiff && equal(options, this.lastDiff.options)) {\n      return this.lastDiff.diff;\n    }\n\n    this.updateWatch(this.variables);\n\n    const oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return { complete: false };\n    }\n\n    const diff = muteDeprecations(\"canonizeResults\", () =>\n      this.cache.diff(options)\n    );\n    this.updateLastDiff(diff, options);\n    return diff;\n  }\n\n  private lastDiff?: {\n    diff: Cache.DiffResult<any>;\n    options: Cache.DiffOptions;\n  };\n\n  private updateLastDiff(\n    diff: Cache.DiffResult<any> | null,\n    options?: Cache.DiffOptions\n  ) {\n    this.lastDiff =\n      diff ?\n        {\n          diff,\n          options: options || this.getDiffOptions(),\n        }\n      : void 0;\n  }\n\n  private getDiffOptions(variables = this.variables): Cache.DiffOptions {\n    return {\n      query: this.document!,\n      variables,\n      returnPartialData: true,\n      optimistic: true,\n      canonizeResults: this.observableQuery?.options.canonizeResults,\n    };\n  }\n\n  setDiff(diff: Cache.DiffResult<any> | null) {\n    const oldDiff = this.lastDiff && this.lastDiff.diff;\n\n    // If we are trying to deliver an incomplete cache result, we avoid\n    // reporting it if the query has errored, otherwise we let the broadcast try\n    // and repair the partial result by refetching the query. This check avoids\n    // a situation where a query that errors and another succeeds with\n    // overlapping data does not report the partial data result to the errored\n    // query.\n    //\n    // See https://github.com/apollographql/apollo-client/issues/11400 for more\n    // information on this issue.\n    if (\n      diff &&\n      !diff.complete &&\n      muteDeprecations(\n        \"getLastError\",\n        () => this.observableQuery?.getLastError()\n      )\n    ) {\n      return;\n    }\n\n    this.updateLastDiff(diff);\n\n    if (!equal(oldDiff && oldDiff.result, diff && diff.result)) {\n      this.observableQuery?.[\"scheduleNotify\"]();\n    }\n  }\n\n  public readonly observableQuery: ObservableQuery<any, any> | null = null;\n  setObservableQuery(oq: ObservableQuery<any, any> | null) {\n    if (oq === this.observableQuery) return;\n    (this as any).observableQuery = oq;\n    if (oq) {\n      oq[\"queryInfo\"] = this;\n    }\n  }\n\n  public stop() {\n    if (!this.stopped) {\n      this.stopped = true;\n\n      // Cancel the pending notify timeout\n      this.observableQuery?.[\"resetNotifications\"]();\n      this.cancel();\n\n      const oq = this.observableQuery;\n      if (oq) oq.stopPolling();\n    }\n  }\n\n  private cancel() {\n    this.cancelWatch?.();\n    this.cancelWatch = void 0;\n  }\n\n  private lastWatch?: Cache.WatchOptions;\n\n  private updateWatch(variables = this.variables) {\n    const oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return;\n    }\n\n    const watchOptions: Cache.WatchOptions = {\n      // Although this.getDiffOptions returns Cache.DiffOptions instead of\n      // Cache.WatchOptions, all the overlapping options should be the same, so\n      // we can reuse getDiffOptions here, for consistency.\n      ...this.getDiffOptions(variables),\n      watcher: this,\n      callback: (diff) => this.setDiff(diff),\n    };\n\n    if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {\n      this.cancel();\n      this.cancelWatch = this.cache.watch((this.lastWatch = watchOptions));\n    }\n  }\n\n  private lastWrite?: {\n    result: FetchResult<any>;\n    variables: WatchQueryOptions[\"variables\"];\n    dmCount: number | undefined;\n  };\n\n  public resetLastWrite() {\n    this.lastWrite = void 0;\n  }\n\n  private shouldWrite(\n    result: FetchResult<any>,\n    variables: WatchQueryOptions[\"variables\"]\n  ) {\n    const { lastWrite } = this;\n    return !(\n      lastWrite &&\n      // If cache.evict has been called since the last time we wrote this\n      // data into the cache, there's a chance writing this result into\n      // the cache will repair what was evicted.\n      lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&\n      equal(variables, lastWrite.variables) &&\n      equal(result.data, lastWrite.result.data)\n    );\n  }\n\n  public markResult<T>(\n    result: FetchResult<T>,\n    document: DocumentNode,\n    options: Pick<\n      WatchQueryOptions,\n      \"variables\" | \"fetchPolicy\" | \"errorPolicy\"\n    >,\n    cacheWriteBehavior: CacheWriteBehavior\n  ) {\n    const merger = new DeepMerger();\n    const graphQLErrors =\n      isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n\n    // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n    // requests. To allow future notify timeouts, diff and dirty are reset as well.\n    this.observableQuery?.[\"resetNotifications\"]();\n\n    if (\"incremental\" in result && isNonEmptyArray(result.incremental)) {\n      const mergedData = mergeIncrementalData(this.getDiff().result, result);\n      result.data = mergedData;\n\n      // Detect the first chunk of a deferred query and merge it with existing\n      // cache data. This ensures a `cache-first` fetch policy that returns\n      // partial cache data or a `cache-and-network` fetch policy that already\n      // has full data in the cache does not complain when trying to merge the\n      // initial deferred server data with existing cache data.\n    } else if (\"hasNext\" in result && result.hasNext) {\n      const diff = this.getDiff();\n      result.data = merger.merge(diff.result, result.data);\n    }\n\n    this.graphQLErrors = graphQLErrors;\n\n    if (options.fetchPolicy === \"no-cache\") {\n      this.updateLastDiff(\n        { result: result.data, complete: true },\n        this.getDiffOptions(options.variables)\n      );\n    } else if (cacheWriteBehavior !== CacheWriteBehavior.FORBID) {\n      if (shouldWriteResult(result, options.errorPolicy)) {\n        // Using a transaction here so we have a chance to read the result\n        // back from the cache before the watch callback fires as a result\n        // of writeQuery, so we can store the new diff quietly and ignore\n        // it when we receive it redundantly from the watch callback.\n        this.cache.performTransaction((cache) => {\n          if (this.shouldWrite(result, options.variables)) {\n            cache.writeQuery({\n              query: document,\n              data: result.data as Unmasked<T>,\n              variables: options.variables,\n              overwrite: cacheWriteBehavior === CacheWriteBehavior.OVERWRITE,\n            });\n\n            this.lastWrite = {\n              result,\n              variables: options.variables,\n              dmCount: destructiveMethodCounts.get(this.cache),\n            };\n          } else {\n            // If result is the same as the last result we received from\n            // the network (and the variables match too), avoid writing\n            // result into the cache again. The wisdom of skipping this\n            // cache write is far from obvious, since any cache write\n            // could be the one that puts the cache back into a desired\n            // state, fixing corruption or missing data. However, if we\n            // always write every network result into the cache, we enable\n            // feuds between queries competing to update the same data in\n            // incompatible ways, which can lead to an endless cycle of\n            // cache broadcasts and useless network requests. As with any\n            // feud, eventually one side must step back from the brink,\n            // letting the other side(s) have the last word(s). There may\n            // be other points where we could break this cycle, such as\n            // silencing the broadcast for cache.writeQuery (not a good\n            // idea, since it just delays the feud a bit) or somehow\n            // avoiding the network request that just happened (also bad,\n            // because the server could return useful new data). All\n            // options considered, skipping this cache write seems to be\n            // the least damaging place to break the cycle, because it\n            // reflects the intuition that we recently wrote this exact\n            // result into the cache, so the cache *should* already/still\n            // contain this data. If some other query has clobbered that\n            // data in the meantime, that's too bad, but there will be no\n            // winners if every query blindly reverts to its own version\n            // of the data. This approach also gives the network a chance\n            // to return new data, which will be written into the cache as\n            // usual, notifying only those queries that are directly\n            // affected by the cache updates, as usual. In the future, an\n            // even more sophisticated cache could perhaps prevent or\n            // mitigate the clobbering somehow, but that would make this\n            // particular cache write even less important, and thus\n            // skipping it would be even safer than it is today.\n            if (this.lastDiff && this.lastDiff.diff.complete) {\n              // Reuse data from the last good (complete) diff that we\n              // received, when possible.\n              result.data = this.lastDiff.diff.result;\n              return;\n            }\n            // If the previous this.diff was incomplete, fall through to\n            // re-reading the latest data with cache.diff, below.\n          }\n\n          const diffOptions = this.getDiffOptions(options.variables);\n          const diff = muteDeprecations(\"canonizeResults\", () =>\n            cache.diff<T>(diffOptions)\n          );\n\n          // In case the QueryManager stops this QueryInfo before its\n          // results are delivered, it's important to avoid restarting the\n          // cache watch when markResult is called. We also avoid updating\n          // the watch if we are writing a result that doesn't match the current\n          // variables to avoid race conditions from broadcasting the wrong\n          // result.\n          if (!this.stopped && equal(this.variables, options.variables)) {\n            // Any time we're about to update this.diff, we need to make\n            // sure we've started watching the cache.\n            this.updateWatch(options.variables);\n          }\n\n          // If we're allowed to write to the cache, and we can read a\n          // complete result from the cache, update result.data to be the\n          // result from the cache, rather than the raw network result.\n          // Set without setDiff to avoid triggering a notify call, since\n          // we have other ways of notifying for this result.\n          this.updateLastDiff(diff, diffOptions);\n          if (diff.complete) {\n            result.data = diff.result;\n          }\n        });\n      } else {\n        this.lastWrite = void 0;\n      }\n    }\n  }\n\n  public markReady() {\n    this.networkError = null;\n    return (this.networkStatus = NetworkStatus.ready);\n  }\n\n  public markError(error: ApolloError) {\n    this.networkStatus = NetworkStatus.error;\n    this.lastWrite = void 0;\n\n    this.observableQuery?.[\"resetNotifications\"]();\n\n    if (error.graphQLErrors) {\n      this.graphQLErrors = error.graphQLErrors;\n    }\n\n    if (error.networkError) {\n      this.networkError = error.networkError;\n    }\n\n    return error;\n  }\n}\n\nexport function shouldWriteResult<T>(\n  result: FetchResult<T>,\n  errorPolicy: ErrorPolicy = \"none\"\n) {\n  const ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n  let writeWithErrors = !graphQLResultHasError(result);\n  if (!writeWithErrors && ignoreErrors && result.data) {\n    writeWithErrors = true;\n  }\n  return writeWithErrors;\n}\n","import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\n\nimport type {\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n} from \"graphql\";\n\nimport type {\n  FragmentMap,\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  storeKeyNameFromField,\n  argumentsObjectFromField,\n  isReference,\n  getStoreKeyName,\n  isNonNullObject,\n  stringifyForDisplay,\n} from \"../../utilities/index.js\";\nimport type {\n  IdGetter,\n  MergeInfo,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport {\n  hasOwn,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  selectionSetMatchesResult,\n  TypeOrFieldNameRegExp,\n  defaultDataIdFromObject,\n  isArray,\n} from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type {\n  SafeReadonly,\n  FieldSpecifier,\n  ToReferenceFunction,\n  ReadFieldFunction,\n  ReadFieldOptions,\n  CanReadFunction,\n} from \"../core/types/common.js\";\nimport type { WriteContext } from \"./writeToStore.js\";\n\nimport {\n  keyArgsFnFromSpecifier,\n  keyFieldsFnFromSpecifier,\n} from \"./key-extractor.js\";\nimport { disableWarningsSlot } from \"../../masking/index.js\";\n\nexport type TypePolicies = {\n  [__typename: string]: TypePolicy;\n};\n\n// TypeScript 3.7 will allow recursive type aliases, so this should work:\n// type KeySpecifier = (string | KeySpecifier)[]\nexport type KeySpecifier = ReadonlyArray<string | KeySpecifier>;\n\nexport type KeyFieldsContext = {\n  // The __typename of the incoming object, even if the __typename field was\n  // aliased to another name in the raw result object. May be undefined when\n  // dataIdFromObject is called for objects without __typename fields.\n  typename: string | undefined;\n\n  // The object to be identified, after processing to remove aliases and\n  // normalize identifiable child objects with references.\n  storeObject: StoreObject;\n\n  // Handy tool for reading additional fields from context.storeObject, either\n  // readField(\"fieldName\") to read storeObject[fieldName], or readField(\"name\",\n  // objectOrReference) to read from another object or Reference. If you read a\n  // field with a read function, that function will be invoked.\n  readField: ReadFieldFunction;\n\n  // If you are writing a custom keyFields function, and you plan to use the raw\n  // result object passed as the first argument, you may also need access to the\n  // selection set and available fragments for this object, just in case any\n  // fields have aliases. Since this logic is tricky to get right, and these\n  // context properties are not even always provided (for example, they are\n  // omitted when calling cache.identify(object), where object is assumed to be\n  // a StoreObject), we recommend you use context.storeObject (which has already\n  // been de-aliased) and context.readField (which can read from references as\n  // well as objects) instead of the raw result object in your keyFields\n  // functions, or just rely on the internal implementation of keyFields:[...]\n  // syntax to get these details right for you.\n  selectionSet?: SelectionSetNode;\n  fragmentMap?: FragmentMap;\n\n  // Internal. May be set by the KeyFieldsFunction to report fields that were\n  // involved in computing the ID. Never passed in by the caller.\n  keyObject?: Record<string, any>;\n};\n\nexport type KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: KeyFieldsContext\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\ntype KeyFieldsResult = Exclude<ReturnType<KeyFieldsFunction>, KeySpecifier>;\n\n// TODO Should TypePolicy be a generic type, with a TObject or TEntity\n// type parameter?\nexport type TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names or a function that returns an arbitrary string.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // Allows defining a merge function (or merge:true/false shorthand) to\n  // be used for merging objects of this type wherever they appear, unless\n  // the parent field also defines a merge function/boolean (that is,\n  // parent field merge functions take precedence over type policy merge\n  // functions). In many cases, defining merge:true for a given type\n  // policy can save you from specifying merge:true for all the field\n  // policies where that type might be encountered.\n  merge?: FieldMergeFunction | boolean;\n\n  // In the rare event that your schema happens to use a different\n  // __typename for the root Query, Mutation, and/or Schema types, you can\n  // express your deviant preferences by enabling one of these options.\n  queryType?: true;\n  mutationType?: true;\n  subscriptionType?: true;\n\n  fields?: {\n    [fieldName: string]: FieldPolicy<any> | FieldReadFunction<any>;\n  };\n};\n\nexport type KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  }\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\nexport type FieldPolicy<\n  // The internal representation used to store the field's data in the\n  // cache. Must be JSON-serializable if you plan to serialize the result\n  // of cache.extract() using JSON.\n  TExisting = any,\n  // The type of the incoming parameter passed to the merge function,\n  // typically matching the GraphQL response format, but with Reference\n  // objects substituted for any identifiable child objects. Often the\n  // same as TExisting, but not necessarily.\n  TIncoming = TExisting,\n  // The type that the read function actually returns, using TExisting\n  // data and options.args as input. Usually the same as TIncoming.\n  TReadResult = TIncoming,\n  // Allows FieldFunctionOptions definition to be overwritten by the\n  // developer\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult, TOptions>;\n  merge?: FieldMergeFunction<TExisting, TIncoming, TOptions> | boolean;\n};\n\nexport type StorageType = Record<string, any>;\n\nfunction argsFromFieldSpecifier(spec: FieldSpecifier) {\n  return (\n    spec.args !== void 0 ? spec.args\n    : spec.field ? argumentsObjectFromField(spec.field, spec.variables)\n    : null\n  );\n}\n\nexport interface FieldFunctionOptions<\n  TArgs = Record<string, any>,\n  TVars = Record<string, any>,\n> {\n  args: TArgs | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The full field key used internally, including serialized key arguments.\n  storeFieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  variables?: TVars;\n\n  // Utilities for dealing with { __ref } objects.\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: StorageType;\n\n  cache: InMemoryCache;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField: ReadFieldFunction;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead: CanReadFunction;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects: MergeObjectsFunction;\n}\n\ntype MergeObjectsFunction = <T extends StoreObject | Reference>(\n  existing: T,\n  incoming: T\n) => T;\n\nexport type FieldReadFunction<\n  TExisting = any,\n  TReadResult = TExisting,\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = (\n  // When reading a field, one often needs to know about any existing\n  // value stored for that field. If the field is read before any value\n  // has been written to the cache, this existing parameter will be\n  // undefined, which makes it easy to use a default parameter expression\n  // to supply the initial value. This parameter is positional (rather\n  // than one of the named options) because that makes it possible for the\n  // developer to annotate it with a type, without also having to provide\n  // a whole new type for the options object.\n  existing: SafeReadonly<TExisting> | undefined,\n  options: TOptions\n) => TReadResult | undefined;\n\nexport type FieldMergeFunction<\n  TExisting = any,\n  TIncoming = TExisting,\n  // Passing the whole FieldFunctionOptions makes the current definition\n  // independent from its implementation\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = (\n  existing: SafeReadonly<TExisting> | undefined,\n  // The incoming parameter needs to be positional as well, for the same\n  // reasons discussed in FieldReadFunction above.\n  incoming: SafeReadonly<TIncoming>,\n  options: TOptions\n) => SafeReadonly<TExisting>;\n\nconst nullKeyFieldsFn: KeyFieldsFunction = () => void 0;\nconst simpleKeyArgsFn: KeyArgsFunction = (_args, context) => context.fieldName;\n\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn: FieldMergeFunction<any> = (\n  existing,\n  incoming,\n  { mergeObjects }\n) => mergeObjects(existing, incoming);\nconst mergeFalseFn: FieldMergeFunction<any> = (_, incoming) => incoming;\n\nexport type PossibleTypesMap = {\n  [supertype: string]: string[];\n};\n\ntype InternalFieldPolicy = {\n  typename: string;\n  keyFn?: KeyArgsFunction;\n  read?: FieldReadFunction<any>;\n  merge?: FieldMergeFunction<any>;\n};\n\nexport class Policies {\n  private typePolicies: {\n    [__typename: string]: {\n      keyFn?: KeyFieldsFunction;\n      merge?: FieldMergeFunction<any>;\n      fields: {\n        [fieldName: string]: InternalFieldPolicy;\n      };\n    };\n  } = Object.create(null);\n\n  private toBeAdded: {\n    [__typename: string]: TypePolicy[];\n  } = Object.create(null);\n\n  // Map from subtype names to sets of supertype names. Note that this\n  // representation inverts the structure of possibleTypes (whose keys are\n  // supertypes and whose values are arrays of subtypes) because it tends\n  // to be much more efficient to search upwards than downwards.\n  private supertypeMap = new Map<string, Set<string>>();\n\n  // Any fuzzy subtypes specified by possibleTypes will be converted to\n  // RegExp objects and recorded here. Every key of this map can also be\n  // found in supertypeMap. In many cases this Map will be empty, which\n  // means no fuzzy subtype checking will happen in fragmentMatches.\n  private fuzzySubtypes = new Map<string, RegExp>();\n\n  public readonly cache: InMemoryCache;\n\n  public readonly rootIdsByTypename: Record<string, string> =\n    Object.create(null);\n  public readonly rootTypenamesById: Record<string, string> =\n    Object.create(null);\n\n  public readonly usingPossibleTypes = false;\n\n  constructor(\n    private config: {\n      cache: InMemoryCache;\n      dataIdFromObject?: KeyFieldsFunction;\n      possibleTypes?: PossibleTypesMap;\n      typePolicies?: TypePolicies;\n    }\n  ) {\n    this.config = {\n      dataIdFromObject: defaultDataIdFromObject,\n      ...config,\n    };\n\n    this.cache = this.config.cache;\n\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  public identify(\n    object: StoreObject,\n    partialContext?: Partial<KeyFieldsContext>\n  ): [string?, StoreObject?] {\n    const policies = this;\n\n    const typename =\n      (partialContext &&\n        (partialContext.typename || partialContext.storeObject?.__typename)) ||\n      object.__typename;\n\n    // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    // Default context.storeObject to object if not otherwise provided.\n    const storeObject =\n      (partialContext && partialContext.storeObject) || object;\n\n    const context: KeyFieldsContext = {\n      ...partialContext,\n      typename,\n      storeObject,\n      readField:\n        (partialContext && partialContext.readField) ||\n        function () {\n          const options = normalizeReadFieldOptions(arguments, storeObject);\n          return policies.readField(options, {\n            store: policies.cache[\"data\"],\n            variables: options.variables,\n          });\n        },\n    };\n\n    let id: KeyFieldsResult;\n\n    const policy = typename && this.getTypePolicy(typename);\n    let keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\n\n    disableWarningsSlot.withValue(true, () => {\n      while (keyFn) {\n        const specifierOrId = keyFn({ ...object, ...storeObject }, context);\n        if (isArray(specifierOrId)) {\n          keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n        } else {\n          id = specifierOrId;\n          break;\n        }\n      }\n    });\n\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n\n  public addTypePolicies(typePolicies: TypePolicies) {\n    Object.keys(typePolicies).forEach((typename) => {\n      const { queryType, mutationType, subscriptionType, ...incoming } =\n        typePolicies[typename];\n\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) this.setRootTypename(\"Query\", typename);\n      if (mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(this.toBeAdded, typename)) {\n        this.toBeAdded[typename].push(incoming);\n      } else {\n        this.toBeAdded[typename] = [incoming];\n      }\n    });\n  }\n\n  private updateTypePolicy(\n    typename: string,\n    incoming: TypePolicy,\n    existingFieldPolicies: Record<string, InternalFieldPolicy>\n  ) {\n    const existing = this.getTypePolicy(typename);\n    const { keyFields, fields } = incoming;\n\n    function setMerge(\n      existing: { merge?: FieldMergeFunction | boolean },\n      merge?: FieldMergeFunction | boolean\n    ) {\n      existing.merge =\n        typeof merge === \"function\" ? merge\n          // Pass merge:true as a shorthand for a merge implementation\n          // that returns options.mergeObjects(existing, incoming).\n        : merge === true ? mergeTrueFn\n          // Pass merge:false to make incoming always replace existing\n          // without any warnings about data clobbering.\n        : merge === false ? mergeFalseFn\n        : existing.merge;\n    }\n\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n\n    existing.keyFn =\n      // Pass false to disable normalization for this typename.\n      keyFields === false ? nullKeyFieldsFn\n        // Pass an array of strings to use those fields to compute a\n        // composite ID for objects of this typename.\n      : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n        // Pass a function to take full control over identification.\n      : typeof keyFields === \"function\" ? keyFields\n        // Leave existing.keyFn unchanged if above cases fail.\n      : existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach((fieldName) => {\n        let existing = existingFieldPolicies[fieldName] as\n          | InternalFieldPolicy\n          | undefined;\n        // Field policy inheritance is atomic/shallow: you can't inherit a\n        // field policy and then override just its read function, since read\n        // and merge functions often need to cooperate, so changing only one\n        // of them would be a recipe for inconsistency.\n        // So here we avoid merging an inherited field policy with an updated one.\n        if (!existing || existing?.typename !== typename) {\n          existing = existingFieldPolicies[fieldName] = { typename };\n        }\n        const incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          const { keyArgs, read, merge } = incoming;\n\n          existing.keyFn =\n            // Pass false to disable argument-based differentiation of\n            // field identities.\n            keyArgs === false ? simpleKeyArgsFn\n              // Pass an array of strings to use named arguments to\n              // compute a composite identity for the field.\n            : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n              // Pass a function to take full control over field identity.\n            : typeof keyArgs === \"function\" ? keyArgs\n              // Leave existing.keyFn unchanged if above cases fail.\n            : existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  }\n\n  private setRootTypename(\n    which: \"Query\" | \"Mutation\" | \"Subscription\",\n    typename: string = which\n  ) {\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(\n        !old || old === which,\n        `Cannot change root %s __typename more than once`,\n        which\n      );\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n\n  public addPossibleTypes(possibleTypes: PossibleTypesMap) {\n    (this.usingPossibleTypes as boolean) = true;\n    Object.keys(possibleTypes).forEach((supertype) => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach((subtype) => {\n        this.getSupertypeSet(subtype, true)!.add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n\n  private getTypePolicy(typename: string): Policies[\"typePolicies\"][string] {\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      const policy: Policies[\"typePolicies\"][string] = (this.typePolicies[\n        typename\n      ] = Object.create(null));\n      policy.fields = Object.create(null);\n\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its properties can\n      // still be updated directly using addTypePolicies, but future changes to\n      // inherited supertype policies will not be reflected in this subtype\n      // policy, because this code runs at most once per typename.\n      let supertypes = this.supertypeMap.get(typename);\n      if (!supertypes && this.fuzzySubtypes.size) {\n        // To make the inheritance logic work for unknown typename strings that\n        // may have fuzzy supertypes, we give this typename an empty supertype\n        // set and then populate it with any fuzzy supertypes that match.\n        supertypes = this.getSupertypeSet(typename, true)!;\n        // This only works for typenames that are directly matched by a fuzzy\n        // supertype. What if there is an intermediate chain of supertypes?\n        // While possible, that situation can only be solved effectively by\n        // specifying the intermediate relationships via possibleTypes, manually\n        // and in a non-fuzzy way.\n        this.fuzzySubtypes.forEach((regExp, fuzzy) => {\n          if (regExp.test(typename)) {\n            // The fuzzy parameter is just the original string version of regExp\n            // (not a valid __typename string), but we can look up the\n            // associated supertype(s) in this.supertypeMap.\n            const fuzzySupertypes = this.supertypeMap.get(fuzzy);\n            if (fuzzySupertypes) {\n              fuzzySupertypes.forEach((supertype) =>\n                supertypes!.add(supertype)\n              );\n            }\n          }\n        });\n      }\n      if (supertypes && supertypes.size) {\n        supertypes.forEach((supertype) => {\n          const { fields, ...rest } = this.getTypePolicy(supertype);\n          Object.assign(policy, rest);\n          Object.assign(policy.fields, fields);\n        });\n      }\n    }\n\n    const inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach((policy) => {\n        this.updateTypePolicy(\n          typename,\n          policy,\n          this.typePolicies[typename].fields\n        );\n      });\n    }\n\n    return this.typePolicies[typename];\n  }\n\n  private getFieldPolicy(\n    typename: string | undefined,\n    fieldName: string\n  ): InternalFieldPolicy | undefined {\n    if (typename) {\n      return this.getTypePolicy(typename).fields[fieldName];\n    }\n  }\n\n  private getSupertypeSet(\n    subtype: string,\n    createIfMissing: boolean\n  ): Set<string> | undefined {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, (supertypeSet = new Set<string>()));\n    }\n    return supertypeSet;\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string | undefined,\n    result?: Record<string, any>,\n    variables?: Record<string, any>\n  ): boolean {\n    if (!fragment.typeCondition) return true;\n\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true)!;\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = (subtype: string) => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (\n          supertypeSet &&\n          supertypeSet.size &&\n          workQueue.indexOf(supertypeSet) < 0\n        ) {\n          workQueue.push(supertypeSet);\n        }\n      };\n\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              invariant.warn(\n                `Inferring subtype %s of supertype %s`,\n                typename,\n                supertype\n              );\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue);\n\n        if (\n          needToCheckFuzzySubtypes &&\n          // Start checking fuzzy subtypes only after exhausting all\n          // non-fuzzy subtypes (after the final iteration of the loop).\n          i === workQueue.length - 1 &&\n          // We could wait to compare fragment.selectionSet to result\n          // after we verify the supertype, but this check is often less\n          // expensive than that search, and we will have to do the\n          // comparison anyway whenever we find a potential match.\n          selectionSetMatchesResult(fragment.selectionSet, result!, variables)\n        ) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public hasKeyArgs(typename: string | undefined, fieldName: string) {\n    const policy = this.getFieldPolicy(typename, fieldName);\n    return !!(policy && policy.keyFn);\n  }\n\n  public getStoreFieldName(fieldSpec: FieldSpecifier): string {\n    const { typename, fieldName } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName);\n    let storeFieldName: Exclude<ReturnType<KeyArgsFunction>, KeySpecifier>;\n\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context: Parameters<KeyArgsFunction>[1] = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables,\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName =\n        fieldSpec.field ?\n          storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n        : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName\n      : fieldName + \":\" + storeFieldName;\n  }\n\n  public readField<V = StoreValue>(\n    options: ReadFieldOptions,\n    context: ReadMergeModifyContext\n  ): SafeReadonly<V> | undefined {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue<string>(\n        objectOrReference,\n        \"__typename\"\n      );\n      if (typename) options.typename = typename;\n    }\n\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue<V>(\n      objectOrReference,\n      storeFieldName\n    );\n    const policy = this.getFieldPolicy(options.typename, fieldName);\n    const read = policy && policy.read;\n\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(\n        this,\n        objectOrReference,\n        options,\n        context,\n        context.store.getStorage(\n          isReference(objectOrReference) ?\n            objectOrReference.__ref\n          : objectOrReference,\n          storeFieldName\n        )\n      );\n\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(this.cache, read, [\n        existing,\n        readOptions,\n      ]) as SafeReadonly<V>;\n    }\n\n    return existing;\n  }\n\n  public getReadFunction(\n    typename: string | undefined,\n    fieldName: string\n  ): FieldReadFunction | undefined {\n    const policy = this.getFieldPolicy(typename, fieldName);\n    return policy && policy.read;\n  }\n\n  public getMergeFunction(\n    parentTypename: string | undefined,\n    fieldName: string,\n    childTypename: string | undefined\n  ): FieldMergeFunction | undefined {\n    let policy:\n      | Policies[\"typePolicies\"][string]\n      | Policies[\"typePolicies\"][string][\"fields\"][string]\n      | undefined = this.getFieldPolicy(parentTypename, fieldName);\n    let merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  }\n\n  public runMergeFunction(\n    existing: StoreValue,\n    incoming: StoreValue,\n    { field, typename, merge }: MergeInfo,\n    context: WriteContext,\n    storage?: StorageType\n  ) {\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(context.store)(\n        existing as StoreObject,\n        incoming as StoreObject\n      );\n    }\n\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    return merge(\n      existing,\n      incoming,\n      makeFieldFunctionOptions(\n        this,\n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0,\n        {\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        },\n        context,\n        storage || Object.create(null)\n      )\n    );\n  }\n}\n\nfunction makeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier,\n  context: ReadMergeModifyContext,\n  storage: StorageType\n): FieldFunctionOptions {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const { toReference, canRead } = context.store;\n\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n    readField<T>() {\n      return policies.readField<T>(\n        normalizeReadFieldOptions(arguments, objectOrReference, variables),\n        context\n      );\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store),\n  };\n}\n\nexport function normalizeReadFieldOptions(\n  readFieldArgs: IArguments,\n  objectOrReference: StoreObject | Reference | undefined,\n  variables?: ReadMergeModifyContext[\"variables\"]\n): ReadFieldOptions {\n  const { 0: fieldNameOrOptions, 1: from, length: argc } = readFieldArgs;\n\n  let options: ReadFieldOptions;\n\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference,\n    };\n  } else {\n    options = { ...fieldNameOrOptions };\n    // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n\n  if (__DEV__ && options.from === void 0) {\n    invariant.warn(\n      `Undefined 'from' passed to readField with arguments %s`,\n      stringifyForDisplay(Array.from(readFieldArgs))\n    );\n  }\n\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n\n  return options;\n}\n\nfunction makeMergeObjectsFunction(\n  store: NormalizedCache\n): MergeObjectsFunction {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw newInvariantError(\"Cannot automatically merge arrays\");\n    }\n\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      const eType = store.getFieldValue(existing, \"__typename\");\n      const iType = store.getFieldValue(incoming, \"__typename\");\n      const typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (\n        storeValueIsStoreObject(existing) &&\n        storeValueIsStoreObject(incoming)\n      ) {\n        return { ...existing, ...incoming };\n      }\n    }\n\n    return incoming;\n  };\n}\n","import type { VariableDefinitionNode, DocumentNode } from \"graphql\";\nimport { visit } from \"graphql\";\n\nexport function filterOperationVariables(\n  variables: Record<string, any>,\n  query: DocumentNode\n) {\n  const result = { ...variables };\n  const unusedNames = new Set(Object.keys(variables));\n  visit(query, {\n    Variable(node, _key, parent) {\n      // A variable type definition at the top level of a query is not\n      // enough to silence server-side errors about the variable being\n      // unused, so variable definitions do not count as usage.\n      // https://spec.graphql.org/draft/#sec-All-Variables-Used\n      if (\n        parent &&\n        (parent as VariableDefinitionNode).kind !== \"VariableDefinition\"\n      ) {\n        unusedNames.delete(node.name.value);\n      }\n    },\n  });\n  unusedNames.forEach((name) => {\n    delete result![name];\n  });\n  return result;\n}\n","import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport type { SelectionSetNode, FieldNode } from \"graphql\";\nimport { Kind } from \"graphql\";\n\nimport type {\n  FragmentMap,\n  FragmentMapFunction,\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  getFragmentFromSelection,\n  getDefaultValues,\n  getOperationDefinition,\n  getTypenameFromResult,\n  makeReference,\n  isField,\n  resultKeyNameFromField,\n  isReference,\n  shouldInclude,\n  cloneDeep,\n  addTypenameToDocument,\n  isNonEmptyArray,\n  argumentsObjectFromField,\n  canonicalStringify,\n} from \"../../utilities/index.js\";\n\nimport type {\n  NormalizedCache,\n  ReadMergeModifyContext,\n  MergeTree,\n  InMemoryCacheConfig,\n} from \"./types.js\";\nimport {\n  isArray,\n  makeProcessedFieldsMerger,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  extractFragmentContext,\n} from \"./helpers.js\";\nimport type { StoreReader } from \"./readFromStore.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { EntityStore } from \"./entityStore.js\";\nimport type { Cache } from \"../../core/index.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\nimport type { ReadFieldFunction } from \"../core/types/common.js\";\n\nexport interface WriteContext extends ReadMergeModifyContext {\n  readonly written: {\n    [dataId: string]: SelectionSetNode[];\n  };\n  readonly fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n  // General-purpose deep-merge function for use during writes.\n  merge<T>(existing: T, incoming: T): T;\n  // If true, merge functions will be called with undefined existing data.\n  overwrite: boolean;\n  incomingById: Map<\n    string,\n    {\n      storeObject: StoreObject;\n      mergeTree?: MergeTree;\n      fieldNodeSet: Set<FieldNode>;\n    }\n  >;\n  // Directive metadata for @client and @defer. We could use a bitfield for this\n  // information to save some space, and use that bitfield number as the keys in\n  // the context.flavors Map.\n  clientOnly: boolean;\n  deferred: boolean;\n  flavors: Map<string, FlavorableWriteContext>;\n}\n\ntype FlavorableWriteContext = Pick<\n  WriteContext,\n  \"clientOnly\" | \"deferred\" | \"flavors\"\n>;\n\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor<TContext extends FlavorableWriteContext>(\n  context: TContext,\n  clientOnly: TContext[\"clientOnly\"],\n  deferred: TContext[\"deferred\"]\n): TContext {\n  const key = `${clientOnly}${deferred}`;\n  let flavored = context.flavors.get(key);\n  if (!flavored) {\n    context.flavors.set(\n      key,\n      (flavored =\n        context.clientOnly === clientOnly && context.deferred === deferred ?\n          context\n        : {\n            ...context,\n            clientOnly,\n            deferred,\n          })\n    );\n  }\n  return flavored as TContext;\n}\n\ninterface ProcessSelectionSetOptions {\n  dataId?: string;\n  result: Record<string, any>;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n  mergeTree: MergeTree;\n}\n\nexport class StoreWriter {\n  constructor(\n    public readonly cache: InMemoryCache,\n    private reader?: StoreReader,\n    private fragments?: InMemoryCacheConfig[\"fragments\"]\n  ) {}\n\n  public writeToStore(\n    store: NormalizedCache,\n    { query, result, dataId, variables, overwrite }: Cache.WriteOptions\n  ): Reference | undefined {\n    const operationDefinition = getOperationDefinition(query)!;\n    const merger = makeProcessedFieldsMerger();\n\n    variables = {\n      ...getDefaultValues(operationDefinition),\n      ...variables!,\n    };\n\n    const context: WriteContext = {\n      store,\n      written: Object.create(null),\n      merge<T>(existing: T, incoming: T) {\n        return merger.merge(existing, incoming) as T;\n      },\n      variables,\n      varString: canonicalStringify(variables),\n      ...extractFragmentContext(query, this.fragments),\n      overwrite: !!overwrite,\n      incomingById: new Map(),\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map(),\n    };\n\n    const ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: { map: new Map() },\n      context,\n    });\n\n    if (!isReference(ref)) {\n      throw newInvariantError(`Could not identify object %s`, result);\n    }\n\n    // So far, the store has not been modified, so now it's time to process\n    // context.incomingById and merge those incoming fields into context.store.\n    context.incomingById.forEach(\n      ({ storeObject, mergeTree, fieldNodeSet }, dataId) => {\n        const entityRef = makeReference(dataId);\n\n        if (mergeTree && mergeTree.map.size) {\n          const applied = this.applyMerges(\n            mergeTree,\n            entityRef,\n            storeObject,\n            context\n          );\n          if (isReference(applied)) {\n            // Assume References returned by applyMerges have already been merged\n            // into the store. See makeMergeObjectsFunction in policies.ts for an\n            // example of how this can happen.\n            return;\n          }\n          // Otherwise, applyMerges returned a StoreObject, whose fields we should\n          // merge into the store (see store.merge statement below).\n          storeObject = applied;\n        }\n\n        if (__DEV__ && !context.overwrite) {\n          const fieldsWithSelectionSets: Record<string, true> =\n            Object.create(null);\n          fieldNodeSet.forEach((field) => {\n            if (field.selectionSet) {\n              fieldsWithSelectionSets[field.name.value] = true;\n            }\n          });\n\n          const hasSelectionSet = (storeFieldName: string) =>\n            fieldsWithSelectionSets[fieldNameFromStoreName(storeFieldName)] ===\n            true;\n\n          const hasMergeFunction = (storeFieldName: string) => {\n            const childTree = mergeTree && mergeTree.map.get(storeFieldName);\n            return Boolean(childTree && childTree.info && childTree.info.merge);\n          };\n\n          Object.keys(storeObject).forEach((storeFieldName) => {\n            // If a merge function was defined for this field, trust that it\n            // did the right thing about (not) clobbering data. If the field\n            // has no selection set, it's a scalar field, so it doesn't need\n            // a merge function (even if it's an object, like JSON data).\n            if (\n              hasSelectionSet(storeFieldName) &&\n              !hasMergeFunction(storeFieldName)\n            ) {\n              warnAboutDataLoss(\n                entityRef,\n                storeObject,\n                storeFieldName,\n                context.store\n              );\n            }\n          });\n        }\n\n        store.merge(dataId, storeObject);\n      }\n    );\n\n    // Any IDs written explicitly to the cache will be retained as\n    // reachable root IDs for garbage collection purposes. Although this\n    // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n    // retainment counts are effectively ignored because cache.gc() always\n    // includes them in its root ID set.\n    store.retain(ref.__ref);\n\n    return ref;\n  }\n\n  private processSelectionSet({\n    dataId,\n    result,\n    selectionSet,\n    context,\n    // This object allows processSelectionSet to report useful information\n    // to its callers without explicitly returning that information.\n    mergeTree,\n  }: ProcessSelectionSetOptions): StoreObject | Reference {\n    const { policies } = this.cache;\n\n    // This variable will be repeatedly updated using context.merge to\n    // accumulate all fields that need to be written into the store.\n    let incoming: StoreObject = Object.create(null);\n\n    // If typename was not passed in, infer it. Note that typename is\n    // always passed in for tricky-to-infer cases such as \"Query\" for\n    // ROOT_QUERY.\n    const typename: string | undefined =\n      (dataId && policies.rootTypenamesById[dataId]) ||\n      getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n      (dataId && (context.store.get(dataId, \"__typename\") as string));\n\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n\n    // This readField function will be passed as context.readField in the\n    // KeyFieldsContext object created within policies.identify (called below).\n    // In addition to reading from the existing context.store (thanks to the\n    // policies.readField(options, context) line at the very bottom), this\n    // version of readField can read from Reference objects that are currently\n    // pending in context.incomingById, which is important whenever keyFields\n    // need to be extracted from a child object that processSelectionSet has\n    // turned into a Reference.\n    const readField: ReadFieldFunction = function (this: void) {\n      const options = normalizeReadFieldOptions(\n        arguments,\n        incoming,\n        context.variables\n      );\n\n      if (isReference(options.from)) {\n        const info = context.incomingById.get(options.from.__ref);\n        if (info) {\n          const result = policies.readField(\n            {\n              ...options,\n              from: info.storeObject,\n            },\n            context\n          );\n\n          if (result !== void 0) {\n            return result;\n          }\n        }\n      }\n\n      return policies.readField(options, context);\n    };\n\n    const fieldNodeSet = new Set<FieldNode>();\n\n    this.flattenFields(\n      selectionSet,\n      result,\n      // This WriteContext will be the default context value for fields returned\n      // by the flattenFields method, but some fields may be assigned a modified\n      // context, depending on the presence of @client and other directives.\n      context,\n      typename\n    ).forEach((context, field) => {\n      const resultFieldKey = resultKeyNameFromField(field);\n      const value = result[resultFieldKey];\n\n      fieldNodeSet.add(field);\n\n      if (value !== void 0) {\n        const storeFieldName = policies.getStoreFieldName({\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        });\n\n        const childTree = getChildMergeTree(mergeTree, storeFieldName);\n\n        let incomingValue = this.processFieldValue(\n          value,\n          field,\n          // Reset context.clientOnly and context.deferred to their default\n          // values before processing nested selection sets.\n          field.selectionSet ?\n            getContextFlavor(context, false, false)\n          : context,\n          childTree\n        );\n\n        // To determine if this field holds a child object with a merge function\n        // defined in its type policy (see PR #7070), we need to figure out the\n        // child object's __typename.\n        let childTypename: string | undefined;\n\n        // The field's value can be an object that has a __typename only if the\n        // field has a selection set. Otherwise incomingValue is scalar.\n        if (\n          field.selectionSet &&\n          (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))\n        ) {\n          childTypename = readField<string>(\"__typename\", incomingValue);\n        }\n\n        const merge = policies.getMergeFunction(\n          typename,\n          field.name.value,\n          childTypename\n        );\n\n        if (merge) {\n          childTree.info = {\n            // TODO Check compatibility against any existing childTree.field?\n            field,\n            typename,\n            merge,\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n\n        incoming = context.merge(incoming, {\n          [storeFieldName]: incomingValue,\n        });\n      } else if (\n        __DEV__ &&\n        !context.clientOnly &&\n        !context.deferred &&\n        !addTypenameToDocument.added(field) &&\n        // If the field has a read function, it may be a synthetic field or\n        // provide a default value, so its absence from the written data should\n        // not be cause for alarm.\n        !policies.getReadFunction(typename, field.name.value)\n      ) {\n        invariant.error(\n          `Missing field '%s' while writing result %o`,\n          resultKeyNameFromField(field),\n          result\n        );\n      }\n    });\n\n    // Identify the result object, even if dataId was already provided,\n    // since we always need keyObject below.\n    try {\n      const [id, keyObject] = policies.identify(result, {\n        typename,\n        selectionSet,\n        fragmentMap: context.fragmentMap,\n        storeObject: incoming,\n        readField,\n      });\n\n      // If dataId was not provided, fall back to the id just generated by\n      // policies.identify.\n      dataId = dataId || id;\n\n      // Write any key fields that were used during identification, even if\n      // they were not mentioned in the original query.\n      if (keyObject) {\n        // TODO Reverse the order of the arguments?\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      // If dataId was provided, tolerate failure of policies.identify.\n      if (!dataId) throw e;\n    }\n\n    if (\"string\" === typeof dataId) {\n      const dataRef = makeReference(dataId);\n\n      // Avoid processing the same entity object using the same selection\n      // set more than once. We use an array instead of a Set since most\n      // entity IDs will be written using only one selection set, so the\n      // size of this array is likely to be very small, meaning indexOf is\n      // likely to be faster than Set.prototype.has.\n      const sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n\n      // If we're about to write a result object into the store, but we\n      // happen to know that the exact same (===) result object would be\n      // returned if we were to reread the result with the same inputs,\n      // then we can skip the rest of the processSelectionSet work for\n      // this object, and immediately return a Reference to it.\n      if (\n        this.reader &&\n        this.reader.isFresh(result, dataRef, selectionSet, context)\n      ) {\n        return dataRef;\n      }\n\n      const previous = context.incomingById.get(dataId);\n      if (previous) {\n        previous.storeObject = context.merge(previous.storeObject, incoming);\n        previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);\n        fieldNodeSet.forEach((field) => previous.fieldNodeSet.add(field));\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          // Save a reference to mergeTree only if it is not empty, because\n          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n          // reused for entirely different parts of the result tree.\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet,\n        });\n      }\n\n      return dataRef;\n    }\n\n    return incoming;\n  }\n\n  private processFieldValue(\n    value: any,\n    field: FieldNode,\n    context: WriteContext,\n    mergeTree: MergeTree\n  ): StoreValue {\n    if (!field.selectionSet || value === null) {\n      // In development, we need to clone scalar values so that they can be\n      // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n      // it's cheaper to store the scalar values directly in the cache.\n      return __DEV__ ? cloneDeep(value) : value;\n    }\n\n    if (isArray(value)) {\n      return value.map((item, i) => {\n        const value = this.processFieldValue(\n          item,\n          field,\n          context,\n          getChildMergeTree(mergeTree, i)\n        );\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context,\n      mergeTree,\n    });\n  }\n\n  // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n  // some additions for tracking @client and @defer directives.\n  private flattenFields<\n    TContext extends Pick<\n      WriteContext,\n      | \"clientOnly\"\n      | \"deferred\"\n      | \"flavors\"\n      | \"fragmentMap\"\n      | \"lookupFragment\"\n      | \"variables\"\n    >,\n  >(\n    selectionSet: SelectionSetNode,\n    result: Record<string, any>,\n    context: TContext,\n    typename = getTypenameFromResult(result, selectionSet, context.fragmentMap)\n  ): Map<FieldNode, TContext> {\n    const fieldMap = new Map<FieldNode, TContext>();\n    const { policies } = this.cache;\n\n    const limitingTrie = new Trie<{\n      // Tracks whether (selectionSet, clientOnly, deferred) has been flattened\n      // before. The GraphQL specification only uses the fragment name for\n      // skipping previously visited fragments, but the top-level fragment\n      // selection set corresponds 1:1 with the fagment name (and is slightly\n      // easier too work with), and we need to consider clientOnly and deferred\n      // values as well, potentially revisiting selection sets that were\n      // previously visited with different inherited configurations of those\n      // directives.\n      visited?: boolean;\n    }>(false); // No need for WeakMap, since limitingTrie does not escape.\n\n    (function flatten(\n      this: void,\n      selectionSet: SelectionSetNode,\n      inheritedContext: TContext\n    ) {\n      const visitedNode = limitingTrie.lookup(\n        selectionSet,\n        // Because we take inheritedClientOnly and inheritedDeferred into\n        // consideration here (in addition to selectionSet), it's possible for\n        // the same selection set to be flattened more than once, if it appears\n        // in the query with different @client and/or @directive configurations.\n        inheritedContext.clientOnly,\n        inheritedContext.deferred\n      );\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n\n      selectionSet.selections.forEach((selection) => {\n        if (!shouldInclude(selection, context.variables)) return;\n\n        let { clientOnly, deferred } = inheritedContext;\n        if (\n          // Since the presence of @client or @defer on this field can only\n          // cause clientOnly or deferred to become true, we can skip the\n          // forEach loop if both clientOnly and deferred are already true.\n          !(clientOnly && deferred) &&\n          isNonEmptyArray(selection.directives)\n        ) {\n          selection.directives.forEach((dir) => {\n            const name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n            if (name === \"defer\") {\n              const args = argumentsObjectFromField(dir, context.variables);\n              // The @defer directive takes an optional args.if boolean\n              // argument, similar to @include(if: boolean). Note that\n              // @defer(if: false) does not make context.deferred false, but\n              // instead behaves as if there was no @defer directive.\n              if (!args || (args as { if?: boolean }).if !== false) {\n                deferred = true;\n              }\n              // TODO In the future, we may want to record args.label using\n              // context.deferred, if a label is specified.\n            }\n          });\n        }\n\n        if (isField(selection)) {\n          const existing = fieldMap.get(selection);\n          if (existing) {\n            // If this field has been visited along another recursive path\n            // before, the final context should have clientOnly or deferred set\n            // to true only if *all* paths have the directive (hence the &&).\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n\n          fieldMap.set(\n            selection,\n            getContextFlavor(context, clientOnly, deferred)\n          );\n        } else {\n          const fragment = getFragmentFromSelection(\n            selection,\n            context.lookupFragment\n          );\n\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw newInvariantError(\n              `No fragment named %s`,\n              selection.name.value\n            );\n          }\n\n          if (\n            fragment &&\n            policies.fragmentMatches(\n              fragment,\n              typename,\n              result,\n              context.variables\n            )\n          ) {\n            flatten(\n              fragment.selectionSet,\n              getContextFlavor(context, clientOnly, deferred)\n            );\n          }\n        }\n      });\n    })(selectionSet, context);\n\n    return fieldMap;\n  }\n\n  private applyMerges<T extends StoreValue>(\n    mergeTree: MergeTree,\n    existing: StoreValue,\n    incoming: T,\n    context: WriteContext,\n    getStorageArgs?: Parameters<EntityStore[\"getStorage\"]>\n  ): T | Reference {\n    if (mergeTree.map.size && !isReference(incoming)) {\n      const e: StoreObject | Reference | undefined =\n        // Items in the same position in different arrays are not\n        // necessarily related to each other, so when incoming is an array\n        // we process its elements as if there was no existing data.\n        (\n          !isArray(incoming) &&\n          // Likewise, existing must be either a Reference or a StoreObject\n          // in order for its fields to be safe to merge with the fields of\n          // the incoming object.\n          (isReference(existing) || storeValueIsStoreObject(existing))\n        ) ?\n          existing\n        : void 0;\n\n      // This narrowing is implied by mergeTree.map.size > 0 and\n      // !isReference(incoming), though TypeScript understandably cannot\n      // hope to infer this type.\n      const i = incoming as StoreObject | StoreValue[];\n\n      // The options.storage objects provided to read and merge functions\n      // are derived from the identity of the parent object plus a\n      // sequence of storeFieldName strings/numbers identifying the nested\n      // field name path of each field value to be merged.\n      if (e && !getStorageArgs) {\n        getStorageArgs = [isReference(e) ? e.__ref : e];\n      }\n\n      // It's possible that applying merge functions to this subtree will\n      // not change the incoming data, so this variable tracks the fields\n      // that did change, so we can create a new incoming object when (and\n      // only when) at least one incoming field has changed. We use a Map\n      // to preserve the type of numeric keys.\n      let changedFields: Map<string | number, StoreValue> | undefined;\n\n      const getValue = (\n        from: typeof e | typeof i,\n        name: string | number\n      ): StoreValue => {\n        return (\n          isArray(from) ?\n            typeof name === \"number\" ?\n              from[name]\n            : void 0\n          : context.store.getFieldValue(from, String(name))\n        );\n      };\n\n      mergeTree.map.forEach((childTree, storeFieldName) => {\n        const eVal = getValue(e, storeFieldName);\n        const iVal = getValue(i, storeFieldName);\n        // If we have no incoming data, leave any existing data untouched.\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        const aVal = this.applyMerges(\n          childTree,\n          eVal,\n          iVal,\n          context,\n          getStorageArgs\n        );\n        if (aVal !== iVal) {\n          changedFields = changedFields || new Map();\n          changedFields.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n\n      if (changedFields) {\n        // Shallow clone i so we can add changed fields to it.\n        incoming = (isArray(i) ? i.slice(0) : { ...i }) as T;\n        changedFields.forEach((value, name) => {\n          (incoming as any)[name] = value;\n        });\n      }\n    }\n\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(\n        existing,\n        incoming,\n        mergeTree.info,\n        context,\n        getStorageArgs && context.store.getStorage(...getStorageArgs)\n      );\n    }\n\n    return incoming;\n  }\n}\n\nconst emptyMergeTreePool: MergeTree[] = [];\n\nfunction getChildMergeTree(\n  { map }: MergeTree,\n  name: string | number\n): MergeTree {\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || { map: new Map() });\n  }\n  return map.get(name)!;\n}\n\nfunction mergeMergeTrees(\n  left: MergeTree | undefined,\n  right: MergeTree | undefined\n): MergeTree {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left!;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n\n  const info =\n    left.info && right.info ?\n      {\n        ...left.info,\n        ...right.info,\n      }\n    : left.info || right.info;\n\n  const needToMergeMaps = left.map.size && right.map.size;\n  const map =\n    needToMergeMaps ? new Map()\n    : left.map.size ? left.map\n    : right.map;\n\n  const merged = { info, map };\n\n  if (needToMergeMaps) {\n    const remainingRightKeys = new Set(right.map.keys());\n\n    left.map.forEach((leftTree, key) => {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys.delete(key);\n    });\n\n    remainingRightKeys.forEach((key) => {\n      merged.map.set(\n        key,\n        mergeMergeTrees(right.map.get(key), left.map.get(key))\n      );\n    });\n  }\n\n  return merged;\n}\n\nfunction mergeTreeIsEmpty(tree: MergeTree | undefined): boolean {\n  return !tree || !(tree.info || tree.map.size);\n}\n\nfunction maybeRecycleChildMergeTree({ map }: MergeTree, name: string | number) {\n  const childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\n\nconst warnings = new Set<string>();\n\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(\n  existingRef: Reference,\n  incomingObj: StoreObject,\n  storeFieldName: string,\n  store: NormalizedCache\n) {\n  const getChild = (objOrRef: StoreObject | Reference): StoreObject | false => {\n    const child = store.getFieldValue<StoreObject>(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  const existing = getChild(existingRef);\n  if (!existing) return;\n\n  const incoming = getChild(incomingObj);\n  if (!incoming) return;\n\n  // It's always safe to replace a reference, since it refers to data\n  // safely stored elsewhere.\n  if (isReference(existing)) return;\n\n  // If the values are structurally equivalent, we do not need to worry\n  // about incoming replacing existing.\n  if (equal(existing, incoming)) return;\n\n  // If we're replacing every key of the existing object, then the\n  // existing data would be overwritten even if the objects were\n  // normalized, so warning would not be helpful here.\n  if (\n    Object.keys(existing).every(\n      (key) => store.getFieldValue(incoming, key) !== void 0\n    )\n  ) {\n    return;\n  }\n\n  const parentType =\n    store.getFieldValue<string>(existingRef, \"__typename\") ||\n    store.getFieldValue<string>(incomingObj, \"__typename\");\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const typeDotName = `${parentType}.${fieldName}`;\n  // Avoid warning more than once for the same type and field name.\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n\n  const childTypenames: string[] = [];\n  // Arrays do not have __typename fields, and always need a custom merge\n  // function, even if their elements are normalized entities.\n  if (!isArray(existing) && !isArray(incoming)) {\n    [existing, incoming].forEach((child) => {\n      const typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  invariant.warn(\n    `Cache data may be lost when replacing the %s field of a %s object.\n\nThis could cause additional (usually avoidable) network requests to fetch data that were otherwise cached.\n\nTo address this problem (which is not a bug in Apollo Client), %sdefine a custom merge function for the %s field, so InMemoryCache can safely merge these objects:\n\n  existing: %o\n  incoming: %o\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n`,\n    fieldName,\n    parentType,\n    childTypenames.length ?\n      \"either ensure all objects of type \" +\n        childTypenames.join(\" and \") +\n        \" have an ID or a custom merge function, or \"\n    : \"\",\n    typeDotName,\n    { ...existing },\n    { ...incoming }\n  );\n}\n","import { invariant } from \"../utilities/globals/index.js\";\n\nimport type {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n  DirectiveNode,\n  FragmentSpreadNode,\n  ExecutableDefinitionNode,\n} from \"graphql\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\n\nimport type { ApolloCache } from \"../cache/index.js\";\nimport type { FragmentMap, StoreObject } from \"../utilities/index.js\";\nimport {\n  argumentsObjectFromField,\n  buildQueryFromSelectionSet,\n  createFragmentMap,\n  getFragmentDefinitions,\n  getMainDefinition,\n  hasDirectives,\n  isField,\n  isInlineFragment,\n  mergeDeep,\n  mergeDeepArray,\n  removeClientSetsFromDocument,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport type { Resolvers, OperationVariables } from \"./types.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  }\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n  selectionsToResolve: Set<SelectionNode>;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client?: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher?: FragmentMatcher;\n  private selectionsToResolveCache = new WeakMap<\n    ExecutableDefinitionNode,\n    Set<SelectionNode>\n  >();\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach((resolverGroup) => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers\n      ).then((localResult) => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher | undefined {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives([\"client\"], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return removeClientSetsFromDocument(document);\n  }\n\n  public prepareContext(context?: Record<string, any>) {\n    const { cache } = this;\n    return {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey(obj: StoreObject) {\n        return cache.identify(obj);\n      },\n    };\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables<TVars extends OperationVariables>(\n    document: DocumentNode,\n    variables: TVars = {} as TVars,\n    context = {}\n  ): /* returns at least the variables that were passed in */ Promise<TVars> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables\n      ).then((data) => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === \"client\" && node.arguments) {\n            forceResolvers = node.arguments.some(\n              (arg) =>\n                arg.name.value === \"always\" &&\n                arg.value.kind === \"BooleanValue\" &&\n                arg.value.value === true\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false\n  ) {\n    const mainDefinition = getMainDefinition(\n      document\n    ) as OperationDefinitionNode;\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n    const selectionsToResolve = this.collectSelectionsToResolve(\n      mainDefinition,\n      fragmentMap\n    );\n\n    const definitionOperation = mainDefinition.operation;\n\n    const defaultOperationType =\n      definitionOperation ?\n        definitionOperation.charAt(0).toUpperCase() +\n        definitionOperation.slice(1)\n      : \"Query\";\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      selectionsToResolve,\n      onlyRunForcedResolvers,\n    };\n    const isClientFieldDescendant = false;\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      isClientFieldDescendant,\n      rootValue,\n      execContext\n    ).then((result) => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    isClientFieldDescendant: boolean,\n    rootValue: TData,\n    execContext: ExecContext\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (\n        !isClientFieldDescendant &&\n        !execContext.selectionsToResolve.has(selection)\n      ) {\n        // Skip selections without @client directives\n        // (still processing if one of the ancestors or one of the child fields has @client directive)\n        return;\n      }\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(\n          selection,\n          isClientFieldDescendant,\n          rootValue,\n          execContext\n        ).then((fieldResult) => {\n          if (typeof fieldResult !== \"undefined\") {\n            resultsToMerge.push({\n              [resultKeyNameFromField(selection)]: fieldResult,\n            } as TData);\n          }\n        });\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named %s`, selection.name.value);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            isClientFieldDescendant,\n            rootValue,\n            execContext\n          ).then((fragmentResult) => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function () {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    rootValue: any,\n    execContext: ExecContext\n  ): Promise<any> {\n    if (!rootValue) {\n      return null;\n    }\n\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(\n            // In case the resolve function accesses reactive variables,\n            // set cacheSlot to the current cache instance.\n            cacheSlot.withValue(this.cache, resolve, [\n              rootValue,\n              argumentsObjectFromField(field, variables),\n              execContext.context,\n              { field, fragmentMap: execContext.fragmentMap },\n            ])\n          );\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach((directive) => {\n          if (directive.name.value === \"export\" && directive.arguments) {\n            directive.arguments.forEach((arg) => {\n              if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      const isClientField =\n        field.directives?.some((d) => d.name.value === \"client\") ?? false;\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(\n          field,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    result: any[],\n    execContext: ExecContext\n  ): any {\n    return Promise.all(\n      result.map((item) => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(\n            field,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(\n            field.selectionSet,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n      })\n    );\n  }\n\n  // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n  private collectSelectionsToResolve(\n    mainDefinition: OperationDefinitionNode,\n    fragmentMap: FragmentMap\n  ): Set<SelectionNode> {\n    const isSingleASTNode = (\n      node: ASTNode | readonly ASTNode[]\n    ): node is ASTNode => !Array.isArray(node);\n    const selectionsToResolveCache = this.selectionsToResolveCache;\n\n    function collectByDefinition(\n      definitionNode: ExecutableDefinitionNode\n    ): Set<SelectionNode> {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        const matches = new Set<SelectionNode>();\n        selectionsToResolveCache.set(definitionNode, matches);\n\n        visit(definitionNode, {\n          Directive(node: DirectiveNode, _, __, ___, ancestors) {\n            if (node.name.value === \"client\") {\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread(spread: FragmentSpreadNode, _, __, ___, ancestors) {\n            const fragment = fragmentMap[spread.name.value];\n            invariant(fragment, `No fragment named %s`, spread.name.value);\n\n            const fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n              matches.add(spread);\n              fragmentSelections.forEach((selection) => {\n                matches.add(selection);\n              });\n            }\n          },\n        });\n      }\n      return selectionsToResolveCache.get(definitionNode)!;\n    }\n    return collectByDefinition(mainDefinition);\n  }\n}\n","import { invariant } from \"../../utilities/globals/index.js\";\n\n// Make builtins like Map and Set safe to use with non-extensible objects.\nimport \"./fixPolyfills.js\";\n\nimport type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\nimport { equal } from \"@wry/equality\";\n\nimport { ApolloCache } from \"../core/cache.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport type { StoreObject, Reference } from \"../../utilities/index.js\";\nimport {\n  addTypenameToDocument,\n  isReference,\n  DocumentTransform,\n  canonicalStringify,\n  print,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../../utilities/index.js\";\nimport type { InMemoryCacheConfig, NormalizedCacheObject } from \"./types.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache, recallCache } from \"./reactiveVars.js\";\nimport { Policies } from \"./policies.js\";\nimport { hasOwn, normalizeConfig, shouldCanonizeResults } from \"./helpers.js\";\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { getInMemoryCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nimport {\n  muteDeprecations,\n  warnRemovedOption,\n} from \"../../utilities/deprecation/index.js\";\n\ntype BroadcastOptions = Pick<\n  Cache.BatchOptions<InMemoryCache>,\n  \"optimistic\" | \"onWatchUpdated\"\n>;\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data!: EntityStore;\n  private optimisticData!: EntityStore;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n\n  private storeReader!: StoreReader;\n  private storeWriter!: StoreWriter;\n  private addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n\n  private maybeBroadcastWatch!: OptimisticWrapperFunction<\n    [Cache.WatchOptions, BroadcastOptions?],\n    any,\n    [Cache.WatchOptions]\n  >;\n\n  // Override the default value, since InMemoryCache result objects are frozen\n  // in development and expected to remain logically immutable in production.\n  public readonly assumeImmutableResults = true;\n\n  // Dynamically imported code can augment existing typePolicies or\n  // possibleTypes by calling cache.policies.addTypePolicies or\n  // cache.policies.addPossibletypes.\n  public readonly policies: Policies;\n\n  public readonly makeVar = makeVar;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n\n    if (__DEV__) {\n      warnRemovedOption(\n        config,\n        \"addTypename\",\n        \"InMemoryCache\",\n        \"Please remove the `addTypename` option when initializing `InMemoryCache`.\"\n      );\n      warnRemovedOption(\n        config,\n        \"canonizeResults\",\n        \"InMemoryCache\",\n        \"Please remove the `canonizeResults` option when initializing `InMemoryCache`.\"\n      );\n    }\n\n    this.config = normalizeConfig(config);\n    this.addTypename = !!this.config.addTypename;\n\n    this.policies = new Policies({\n      cache: this,\n      dataIdFromObject: this.config.dataIdFromObject,\n      possibleTypes: this.config.possibleTypes,\n      typePolicies: this.config.typePolicies,\n    });\n\n    this.init();\n  }\n\n  private init() {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    const rootStore = (this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching,\n    }));\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = rootStore.stump;\n\n    this.resetResultCache();\n  }\n\n  private resetResultCache(resetResultIdentities?: boolean) {\n    const previousReader = this.storeReader;\n    const { fragments } = this.config;\n\n    this.addTypenameTransform.resetCache();\n    fragments?.resetCaches();\n\n    // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n    this.storeWriter = new StoreWriter(\n      this,\n      (this.storeReader = new StoreReader({\n        cache: this,\n        addTypename: this.addTypename,\n        resultCacheMaxSize: this.config.resultCacheMaxSize,\n        canonizeResults: shouldCanonizeResults(this.config),\n        canon:\n          resetResultIdentities ? void 0 : (\n            previousReader && previousReader.canon\n          ),\n        fragments,\n      })),\n      fragments\n    );\n\n    this.maybeBroadcastWatch = wrap(\n      (c: Cache.WatchOptions, options?: BroadcastOptions) => {\n        return this.broadcastWatch(c, options);\n      },\n      {\n        max:\n          this.config.resultCacheMaxSize ||\n          cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] ||\n          defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"],\n        makeCacheKey: (c: Cache.WatchOptions) => {\n          // Return a cache key (thus enabling result caching) only if we're\n          // currently using a data store that can track cache dependencies.\n          const store = c.optimistic ? this.optimisticData : this.data;\n          if (supportsResultCaching(store)) {\n            const { optimistic, id, variables } = c;\n            return store.makeCacheKey(\n              c.query,\n              // Different watches can have the same query, optimistic\n              // status, rootId, and variables, but if their callbacks are\n              // different, the (identical) result needs to be delivered to\n              // each distinct callback. The easiest way to achieve that\n              // separation is to include c.callback in the cache key for\n              // maybeBroadcastWatch calls. See issue #5733.\n              c.callback,\n              canonicalStringify({ optimistic, id, variables })\n            );\n          }\n        },\n      }\n    );\n\n    // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n    new Set([this.data.group, this.optimisticData.group]).forEach((group) =>\n      group.resetCaching()\n    );\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    this.init();\n    // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).extract();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"cache.read\");\n    }\n\n    const {\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = false,\n    } = options;\n    try {\n      return (\n        this.storeReader.diffQueryAgainstStore<T>({\n          ...options,\n          store: options.optimistic ? this.optimisticData : this.data,\n          config: this.config,\n          returnPartialData,\n        }).result || null\n      );\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        // Swallow MissingFieldError and return null, so callers do not need to\n        // worry about catching \"normal\" exceptions resulting from incomplete\n        // cache data. Unexpected errors will be re-thrown. If you need more\n        // information about which fields were missing, use cache.diff instead,\n        // and examine diffResult.missing.\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  public write(options: Cache.WriteOptions): Reference | undefined {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    const store =\n      (\n        options.optimistic // Defaults to false.\n      ) ?\n        this.optimisticData\n      : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public diff<TData, TVariables extends OperationVariables = any>(\n    options: Cache.DiffOptions<TData, TVariables>\n  ): Cache.DiffResult<TData> {\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"cache.diff\");\n    }\n\n    return this.storeReader.diffQueryAgainstStore({\n      ...options,\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config,\n    });\n  }\n\n  public watch<TData = any, TVariables = any>(\n    watch: Cache.WatchOptions<TData, TVariables>\n  ): () => void {\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return () => {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (this.watches.delete(watch) && !this.watches.size) {\n        forgetCache(this);\n      }\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      this.maybeBroadcastWatch.forget(watch);\n    };\n  }\n\n  public gc(options?: {\n    // If true, also free non-essential result cache memory by bulk-releasing\n    // this.{store{Reader,Writer},maybeBroadcastWatch}. Defaults to false.\n    resetResultCache?: boolean;\n    // If resetResultCache is true, this.storeReader.canon will be preserved by\n    // default, but can also be discarded by passing resetResultIdentities:true.\n    // Defaults to false.\n    /**\n     * @deprecated `resetResultIdentities` is removed in Apollo Client 4.0.\n     *\n     * **Recommended now**\n     *\n     * Ensure all usages of `canonizeResults` are removed. Once\n     * `canonizeResults` is no longer used, remove this option.\n     */\n    resetResultIdentities?: boolean;\n  }) {\n    if (__DEV__) {\n      warnRemovedOption(\n        options || {},\n        \"resetResultIdentities\",\n        \"cache.gc\",\n        \"First ensure all usages of `canonizeResults` are removed, then remove this option.\"\n      );\n    }\n\n    canonicalStringify.reset();\n    print.reset();\n    const ids = this.optimisticData.gc();\n    if (options && !this.txCount) {\n      if (options.resetResultCache) {\n        this.resetResultCache(options.resetResultIdentities);\n      } else if (options.resetResultIdentities) {\n        this.storeReader.resetCanon();\n      }\n    }\n    return ids;\n  }\n\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  public retain(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }\n\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  public release(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }\n\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  public identify(object: StoreObject | Reference): string | undefined {\n    if (isReference(object)) return object.__ref;\n    try {\n      return this.policies.identify(object)[0];\n    } catch (e) {\n      invariant.warn(e);\n    }\n  }\n\n  public evict(options: Cache.EvictOptions): boolean {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = { ...options, id: \"ROOT_QUERY\" };\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      // Pass this.data as a limit on the depth of the eviction, so evictions\n      // during optimistic updates (when this.data is temporarily set equal to\n      // this.optimisticData) do not escape their optimistic Layer.\n      return this.optimisticData.evict(options, this.data);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public reset(options?: Cache.ResetOptions): Promise<void> {\n    this.init();\n\n    canonicalStringify.reset();\n\n    if (options && options.discardWatches) {\n      // Similar to what happens in the unsubscribe function returned by\n      // cache.watch, applied to all current watches.\n      this.watches.forEach((watch) => this.maybeBroadcastWatch.forget(watch));\n      this.watches.clear();\n      forgetCache(this);\n    } else {\n      // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n      // this.broadcastWatches() triggers a broadcast to every current watcher\n      // (letting them know their data is now missing). This default behavior is\n      // convenient because it means the watches do not have to be manually\n      // reestablished after resetting the cache. To prevent this broadcast and\n      // cancel all watches, pass true for options.discardWatches.\n      this.broadcastWatches();\n    }\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  }\n\n  private txCount = 0;\n\n  public batch<TUpdateResult>(\n    options: Cache.BatchOptions<InMemoryCache, TUpdateResult>\n  ): TUpdateResult {\n    const {\n      update,\n      optimistic = true,\n      removeOptimistic,\n      onWatchUpdated,\n    } = options;\n\n    let updateResult: TUpdateResult;\n    const perform = (layer?: EntityStore): TUpdateResult => {\n      const { data, optimisticData } = this;\n      ++this.txCount;\n      if (layer) {\n        this.data = this.optimisticData = layer;\n      }\n      try {\n        return (updateResult = update(this));\n      } finally {\n        --this.txCount;\n        this.data = data;\n        this.optimisticData = optimisticData;\n      }\n    };\n\n    const alreadyDirty = new Set<Cache.WatchOptions>();\n\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch) {\n          alreadyDirty.add(watch);\n          return false;\n        },\n      });\n    }\n\n    if (typeof optimistic === \"string\") {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n\n    // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch, diff) {\n          const result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        },\n      });\n      // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach((watch) => this.maybeBroadcastWatch.dirty(watch));\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n\n    return updateResult!;\n  }\n\n  public performTransaction(\n    update: (cache: InMemoryCache) => any,\n    optimisticId?: string | null\n  ) {\n    return this.batch({\n      update,\n      optimistic: optimisticId || optimisticId !== null,\n    });\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return this.addTypenameToDocument(this.addFragmentsToDocument(document));\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode,\n    typename: string\n  ): boolean {\n    return this.policies.fragmentMatches(fragment, typename);\n  }\n\n  public lookupFragment(fragmentName: string): FragmentDefinitionNode | null {\n    return this.config.fragments?.lookup(fragmentName) || null;\n  }\n\n  protected broadcastWatches(options?: BroadcastOptions) {\n    if (!this.txCount) {\n      this.watches.forEach((c) => this.maybeBroadcastWatch(c, options));\n    }\n  }\n\n  private addFragmentsToDocument(document: DocumentNode) {\n    const { fragments } = this.config;\n    return fragments ? fragments.transform(document) : document;\n  }\n\n  private addTypenameToDocument(document: DocumentNode) {\n    if (this.addTypename) {\n      return this.addTypenameTransform.transformDocument(document);\n    }\n    return document;\n  }\n\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  private broadcastWatch(c: Cache.WatchOptions, options?: BroadcastOptions) {\n    const { lastDiff } = c;\n\n    // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n    // currently requires no additional properties, so we can use c (a\n    // WatchOptions object) as DiffOptions, without having to allocate a new\n    // object, and without having to enumerate the relevant properties (query,\n    // variables, etc.) explicitly. There will be some additional properties\n    // (lastDiff, callback, etc.), but cache.diff ignores them.\n    const diff = muteDeprecations(\"canonizeResults\", () => this.diff<any>(c));\n\n    if (options) {\n      if (c.optimistic && typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n\n      if (\n        options.onWatchUpdated &&\n        options.onWatchUpdated.call(this, c, diff, lastDiff) === false\n      ) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback((c.lastDiff = diff), lastDiff);\n    }\n  }\n\n  /**\n   * @experimental\n   * @internal\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   */\n  public getMemoryInternals?: typeof getInMemoryCacheMemoryInternals;\n}\n\nif (__DEV__) {\n  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}\n","import { ApolloLink } from \"../core/index.js\";\nimport type { HttpOptions } from \"./selectHttpOptionsAndBody.js\";\nimport { createHttpLink } from \"./createHttpLink.js\";\n\nexport class HttpLink extends ApolloLink {\n  constructor(public options: HttpOptions = {}) {\n    super(createHttpLink(options).request);\n  }\n}\n","import { isNonNullObject } from \"./objects.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\n// These mergeDeep and mergeDeepArray utilities merge any number of objects\n// together, sharing as much memory as possible with the source objects, while\n// remaining careful to avoid modifying any source objects.\n\n// Logically, the return type of mergeDeep should be the intersection of\n// all the argument types. The binary call signature is by far the most\n// common, but we support 0- through 5-ary as well. After that, the\n// resulting type is just the inferred array element type. Note to nerds:\n// there is a more clever way of doing this that converts the tuple type\n// first to a union type (easy enough: T[number]) and then converts the\n// union to an intersection type using distributive conditional type\n// inference, but that approach has several fatal flaws (boolean becomes\n// true & false, and the inferred type ends up as unknown in many cases),\n// in addition to being nearly impossible to explain/understand.\nexport type TupleToIntersection<T extends any[]> =\n  T extends [infer A] ? A\n  : T extends [infer A, infer B] ? A & B\n  : T extends [infer A, infer B, infer C] ? A & B & C\n  : T extends [infer A, infer B, infer C, infer D] ? A & B & C & D\n  : T extends [infer A, infer B, infer C, infer D, infer E] ? A & B & C & D & E\n  : T extends (infer U)[] ? U\n  : any;\n\nexport function mergeDeep<T extends any[]>(\n  ...sources: T\n): TupleToIntersection<T> {\n  return mergeDeepArray(sources);\n}\n\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray<T>(sources: T[]): T {\n  let target = sources[0] || ({} as T);\n  const count = sources.length;\n  if (count > 1) {\n    const merger = new DeepMerger();\n    for (let i = 1; i < count; ++i) {\n      target = merger.merge(target, sources[i]);\n    }\n  }\n  return target;\n}\n\nexport type ReconcilerFunction<TContextArgs extends any[]> = (\n  this: DeepMerger<TContextArgs>,\n  target: Record<string | number, any>,\n  source: Record<string | number, any>,\n  property: string | number,\n  ...context: TContextArgs\n) => any;\n\nconst defaultReconciler: ReconcilerFunction<any[]> = function (\n  target,\n  source,\n  property\n) {\n  return this.merge(target[property], source[property]);\n};\n\nexport class DeepMerger<TContextArgs extends any[]> {\n  constructor(\n    private reconciler: ReconcilerFunction<TContextArgs> = defaultReconciler as any as ReconcilerFunction<TContextArgs>\n  ) {}\n\n  public merge(target: any, source: any, ...context: TContextArgs): any {\n    if (isNonNullObject(source) && isNonNullObject(target)) {\n      Object.keys(source).forEach((sourceKey) => {\n        if (hasOwnProperty.call(target, sourceKey)) {\n          const targetValue = target[sourceKey];\n          if (source[sourceKey] !== targetValue) {\n            const result = this.reconciler(\n              target,\n              source,\n              sourceKey,\n              ...context\n            );\n            // A well-implemented reconciler may return targetValue to indicate\n            // the merge changed nothing about the structure of the target.\n            if (result !== targetValue) {\n              target = this.shallowCopyForMerge(target);\n              target[sourceKey] = result;\n            }\n          }\n        } else {\n          // If there is no collision, the target can safely share memory with\n          // the source, and the recursion can terminate here.\n          target = this.shallowCopyForMerge(target);\n          target[sourceKey] = source[sourceKey];\n        }\n      });\n\n      return target;\n    }\n\n    // If source (or target) is not an object, let source replace target.\n    return source;\n  }\n\n  public isObject = isNonNullObject;\n\n  private pastCopies = new Set<any>();\n\n  public shallowCopyForMerge<T>(value: T): T {\n    if (isNonNullObject(value)) {\n      if (!this.pastCopies.has(value)) {\n        if (Array.isArray(value)) {\n          value = (value as any).slice(0);\n        } else {\n          value = {\n            __proto__: Object.getPrototypeOf(value),\n            ...value,\n          };\n        }\n        this.pastCopies.add(value);\n      }\n    }\n    return value;\n  }\n}\n","import type { FormattedExecutionResult, GraphQLFormattedError } from \"graphql\";\n\nimport {\n  graphQLResultHasProtocolErrors,\n  PROTOCOL_ERRORS_SYMBOL,\n} from \"../../errors/index.js\";\nimport type { NetworkError } from \"../../errors/index.js\";\nimport { Observable } from \"../../utilities/index.js\";\nimport type { Operation, FetchResult, NextLink } from \"../core/index.js\";\nimport { ApolloLink } from \"../core/index.js\";\n\nexport interface ErrorResponse {\n  /**\n   * Errors returned in the `errors` property of the GraphQL response.\n   *\n   * @deprecated `graphQLErrors` will no longer available in options in Apollo Client 4.0.\n   * This value is safe to use in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * `graphQLErrors` has been consolidated to the `error` property. You will need to\n   * read the error from the `error` property.\n   */\n  graphQLErrors?: ReadonlyArray<GraphQLFormattedError>;\n  /**\n   * Errors thrown during a network request. This is usually an error thrown\n   * during a `fetch` call or an error while parsing the response from the\n   * network.\n   *\n   * @deprecated `networkError` will no longer available in options in Apollo Client 4.0.\n   * This value is safe to use in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * `networkError` has been consolidated to the `error` property. You will need to\n   * read the error from the `error` property.\n   */\n  networkError?: NetworkError;\n  /**\n   * Fatal transport-level errors from multipart subscriptions.\n   * See the [multipart subscription protocol](https://www.apollographql.com/docs/graphos/routing/operations/subscriptions/multipart-protocol#message-and-error-format) for more information.\n   *\n   * @deprecated `protocolErrors` will no longer available in options in Apollo Client 4.0.\n   * This value is safe to use in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * `protocolErrors` has been consolidated to the `error` property. You will need to\n   * read the error from the `error` property.\n   */\n  protocolErrors?: ReadonlyArray<GraphQLFormattedError>;\n\n  /**\n   * @deprecated `response` has renamed to `result` in Apollo Client 4.0. This\n   * property is safe to use in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When migrating**\n   *\n   * Use the `result` property instead of `response` inside your callback function.\n   */\n  response?: FormattedExecutionResult;\n  operation: Operation;\n  forward: NextLink;\n}\n\nexport namespace ErrorLink {\n  /**\n   * Callback to be triggered when an error occurs within the link stack.\n   */\n  export interface ErrorHandler {\n    (error: ErrorResponse): Observable<FetchResult> | void;\n  }\n}\n\n// For backwards compatibility.\nexport import ErrorHandler = ErrorLink.ErrorHandler;\n\nexport function onError(errorHandler: ErrorHandler): ApolloLink {\n  return new ApolloLink((operation, forward) => {\n    return new Observable((observer) => {\n      let sub: any;\n      let retriedSub: any;\n      let retriedResult: any;\n\n      try {\n        sub = forward(operation).subscribe({\n          next: (result) => {\n            if (result.errors) {\n              retriedResult = errorHandler({\n                graphQLErrors: result.errors,\n                response: result,\n                operation,\n                forward,\n              });\n            } else if (graphQLResultHasProtocolErrors(result)) {\n              retriedResult = errorHandler({\n                protocolErrors: result.extensions[PROTOCOL_ERRORS_SYMBOL],\n                response: result,\n                operation,\n                forward,\n              });\n            }\n\n            if (retriedResult) {\n              retriedSub = retriedResult.subscribe({\n                next: observer.next.bind(observer),\n                error: observer.error.bind(observer),\n                complete: observer.complete.bind(observer),\n              });\n              return;\n            }\n\n            observer.next(result);\n          },\n          error: (networkError) => {\n            retriedResult = errorHandler({\n              operation,\n              networkError,\n              //Network errors can return GraphQL errors on for example a 403\n              graphQLErrors:\n                (networkError &&\n                  networkError.result &&\n                  networkError.result.errors) ||\n                void 0,\n              forward,\n            });\n            if (retriedResult) {\n              retriedSub = retriedResult.subscribe({\n                next: observer.next.bind(observer),\n                error: observer.error.bind(observer),\n                complete: observer.complete.bind(observer),\n              });\n              return;\n            }\n            observer.error(networkError);\n          },\n          complete: () => {\n            // disable the previous sub from calling complete on observable\n            // if retry is in flight.\n            if (!retriedResult) {\n              observer.complete.bind(observer)();\n            }\n          },\n        });\n      } catch (e) {\n        errorHandler({ networkError: e as Error, operation, forward });\n        observer.error(e);\n      }\n\n      return () => {\n        if (sub) sub.unsubscribe();\n        if (retriedSub) sub.unsubscribe();\n      };\n    });\n  });\n}\n\nexport class ErrorLink extends ApolloLink {\n  private link: ApolloLink;\n  constructor(errorHandler: ErrorLink.ErrorHandler) {\n    super();\n    this.link = onError(errorHandler);\n  }\n\n  public request(\n    operation: Operation,\n    forward: NextLink\n  ): Observable<FetchResult> | null {\n    return this.link.request(operation, forward);\n  }\n}\n","import { invariant } from \"../globals/index.js\";\n\nimport type {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  ASTNode,\n  ASTVisitFn,\n  InlineFragmentNode,\n} from \"graphql\";\nimport { visit, Kind } from \"graphql\";\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  getMainDefinition,\n} from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport type { FragmentMap } from \"./fragments.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nimport { isArray, isNonEmptyArray } from \"../common/arrays.js\";\n\n// https://github.com/graphql/graphql-js/blob/8d7c8fccf5a9846a50785de04abda58a7eb13fc0/src/language/visitor.ts#L20-L23\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode>;\n  readonly leave?: ASTVisitFn<TVisitedNode>;\n}\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig =\n  RemoveNodeConfig<FragmentDefinitionNode>;\nexport type RemoveVariableDefinitionConfig =\n  RemoveNodeConfig<VariableDefinitionNode>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: \"__typename\",\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragmentMap: FragmentMap\n): boolean {\n  return (\n    !op ||\n    op.selectionSet.selections.every(\n      (selection) =>\n        selection.kind === Kind.FRAGMENT_SPREAD &&\n        isEmpty(fragmentMap[selection.name.value], fragmentMap)\n    )\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return (\n      isEmpty(\n        getOperationDefinition(doc) || getFragmentDefinition(doc),\n        createFragmentMap(getFragmentDefinitions(doc))\n      )\n    ) ?\n      null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  configs: (RemoveDirectiveConfig | GetDirectiveConfig)[]\n) {\n  const names = new Map<string, RemoveDirectiveConfig | GetDirectiveConfig>();\n\n  const tests = new Map<\n    (directive: DirectiveNode) => boolean,\n    RemoveDirectiveConfig | GetDirectiveConfig\n  >();\n\n  configs.forEach((directive) => {\n    if (directive) {\n      if (directive.name) {\n        names.set(directive.name, directive);\n      } else if (directive.test) {\n        tests.set(directive.test, directive);\n      }\n    }\n  });\n\n  return (directive: DirectiveNode) => {\n    let config = names.get(directive.name.value);\n    if (!config && tests.size) {\n      tests.forEach((testConfig, test) => {\n        if (test(directive)) {\n          config = testConfig;\n        }\n      });\n    }\n    return config;\n  };\n}\n\n// Helper interface and function used by removeDirectivesFromDocument to keep\n// track of variable references and fragments spreads found within a given\n// operation or fragment definition.\ninterface InternalInUseInfo {\n  variables: Set<string>;\n  fragmentSpreads: Set<string>;\n  // Set to true when we deliberately remove a fragment definition, so we can\n  // make sure also to remove dangling ...spreads that refer to it.\n  removed?: boolean;\n  // Populated by the populateTransitiveVars helper function below.\n  transitiveVars?: Set<string>;\n}\nfunction makeInUseGetterFunction<TKey>(defaultKey: TKey) {\n  const map = new Map<TKey, InternalInUseInfo>();\n\n  return function inUseGetterFunction(\n    key: TKey = defaultKey\n  ): InternalInUseInfo {\n    let inUse = map.get(key);\n    if (!inUse) {\n      map.set(\n        key,\n        (inUse = {\n          // Variable and fragment spread names used directly within this\n          // operation or fragment definition, as identified by key. These sets\n          // will be populated during the first traversal of the document in\n          // removeDirectivesFromDocument below.\n          variables: new Set(),\n          fragmentSpreads: new Set(),\n        })\n      );\n    }\n    return inUse;\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  checkDocument(doc);\n\n  // Passing empty strings to makeInUseGetterFunction means we handle anonymous\n  // operations as if their names were \"\". Anonymous fragment definitions are\n  // not supposed to be possible, but the same default naming strategy seems\n  // appropriate for that case as well.\n  const getInUseByOperationName = makeInUseGetterFunction<string>(\"\");\n  const getInUseByFragmentName = makeInUseGetterFunction<string>(\"\");\n  const getInUse = (\n    ancestors: readonly (ASTNode | readonly ASTNode[])[]\n  ): InternalInUseInfo | null => {\n    for (\n      let p = 0, ancestor: ASTNode | readonly ASTNode[];\n      p < ancestors.length && (ancestor = ancestors[p]);\n      ++p\n    ) {\n      if (isArray(ancestor)) continue;\n      if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n        // If an operation is anonymous, we use the empty string as its key.\n        return getInUseByOperationName(ancestor.name && ancestor.name.value);\n      }\n      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n        return getInUseByFragmentName(ancestor.name.value);\n      }\n    }\n    invariant.error(`Could not find operation or fragment`);\n    return null;\n  };\n\n  let operationCount = 0;\n  for (let i = doc.definitions.length - 1; i >= 0; --i) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      ++operationCount;\n    }\n  }\n\n  const directiveMatcher = getDirectiveMatcher(directives);\n  const shouldRemoveField = (nodeDirectives: FieldNode[\"directives\"]) =>\n    isNonEmptyArray(nodeDirectives) &&\n    nodeDirectives\n      .map(directiveMatcher)\n      .some(\n        (config: RemoveDirectiveConfig | undefined) => config && config.remove\n      );\n\n  const originalFragmentDefsByPath = new Map<string, FragmentDefinitionNode>();\n\n  // Any time the first traversal of the document below makes a change like\n  // removing a fragment (by returning null), this variable should be set to\n  // true. Once it becomes true, it should never be set to false again. If this\n  // variable remains false throughout the traversal, then we can return the\n  // original doc immediately without any modifications.\n  let firstVisitMadeChanges = false;\n\n  const fieldOrInlineFragmentVisitor: EnterLeaveVisitor<\n    FieldNode | InlineFragmentNode\n  > = {\n    enter(node) {\n      if (shouldRemoveField(node.directives)) {\n        firstVisitMadeChanges = true;\n        return null;\n      }\n    },\n  };\n\n  const docWithoutDirectiveSubtrees = visit(doc, {\n    // These two AST node types share the same implementation, defined above.\n    Field: fieldOrInlineFragmentVisitor,\n    InlineFragment: fieldOrInlineFragmentVisitor,\n\n    VariableDefinition: {\n      enter() {\n        // VariableDefinition nodes do not count as variables in use, though\n        // they do contain Variable nodes that might be visited below. To avoid\n        // counting variable declarations as usages, we skip visiting the\n        // contents of this VariableDefinition node by returning false.\n        return false;\n      },\n    },\n\n    Variable: {\n      enter(node, _key, _parent, _path, ancestors) {\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.variables.add(node.name.value);\n        }\n      },\n    },\n\n    FragmentSpread: {\n      enter(node, _key, _parent, _path, ancestors) {\n        if (shouldRemoveField(node.directives)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.fragmentSpreads.add(node.name.value);\n        }\n        // We might like to remove this FragmentSpread by returning null here if\n        // the corresponding FragmentDefinition node is also going to be removed\n        // by the logic below, but we can't control the relative order of those\n        // events, so we have to postpone the removal of dangling FragmentSpread\n        // nodes until after the current visit of the document has finished.\n      },\n    },\n\n    FragmentDefinition: {\n      enter(node, _key, _parent, path) {\n        originalFragmentDefsByPath.set(JSON.stringify(path), node);\n      },\n      leave(node, _key, _parent, path) {\n        const originalNode = originalFragmentDefsByPath.get(\n          JSON.stringify(path)\n        );\n        if (node === originalNode) {\n          // If the FragmentNode received by this leave function is identical to\n          // the one received by the corresponding enter function (above), then\n          // the visitor must not have made any changes within this\n          // FragmentDefinition node. This fragment definition may still be\n          // removed if there are no ...spread references to it, but it won't be\n          // removed just because it has only a __typename field.\n          return node;\n        }\n\n        if (\n          // This logic applies only if the document contains one or more\n          // operations, since removing all fragments from a document containing\n          // only fragments makes the document useless.\n          operationCount > 0 &&\n          node.selectionSet.selections.every(\n            (selection) =>\n              selection.kind === Kind.FIELD &&\n              selection.name.value === \"__typename\"\n          )\n        ) {\n          // This is a somewhat opinionated choice: if a FragmentDefinition ends\n          // up having no fields other than __typename, we remove the whole\n          // fragment definition, and later prune ...spread references to it.\n          getInUseByFragmentName(node.name.value).removed = true;\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n\n    Directive: {\n      leave(node) {\n        // If a matching directive is found, remove the directive itself. Note\n        // that this does not remove the target (field, argument, etc) of the\n        // directive, but only the directive itself.\n        if (directiveMatcher(node)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n  });\n\n  if (!firstVisitMadeChanges) {\n    // If our first pass did not change anything about the document, then there\n    // is no cleanup we need to do, and we can return the original doc.\n    return doc;\n  }\n\n  // Utility for making sure inUse.transitiveVars is recursively populated.\n  // Because this logic assumes inUse.fragmentSpreads has been completely\n  // populated and inUse.removed has been set if appropriate,\n  // populateTransitiveVars must be called after that information has been\n  // collected by the first traversal of the document.\n  const populateTransitiveVars = (inUse: InternalInUseInfo) => {\n    if (!inUse.transitiveVars) {\n      inUse.transitiveVars = new Set(inUse.variables);\n      if (!inUse.removed) {\n        inUse.fragmentSpreads.forEach((childFragmentName) => {\n          populateTransitiveVars(\n            getInUseByFragmentName(childFragmentName)\n          ).transitiveVars!.forEach((varName) => {\n            inUse.transitiveVars!.add(varName);\n          });\n        });\n      }\n    }\n    return inUse;\n  };\n\n  // Since we've been keeping track of fragment spreads used by particular\n  // operations and fragment definitions, we now need to compute the set of all\n  // spreads used (transitively) by any operations in the document.\n  const allFragmentNamesUsed = new Set<string>();\n  docWithoutDirectiveSubtrees.definitions.forEach((def) => {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      populateTransitiveVars(\n        getInUseByOperationName(def.name && def.name.value)\n      ).fragmentSpreads.forEach((childFragmentName) => {\n        allFragmentNamesUsed.add(childFragmentName);\n      });\n    } else if (\n      def.kind === Kind.FRAGMENT_DEFINITION &&\n      // If there are no operations in the document, then all fragment\n      // definitions count as usages of their own fragment names. This heuristic\n      // prevents accidentally removing all fragment definitions from the\n      // document just because it contains no operations that use the fragments.\n      operationCount === 0 &&\n      !getInUseByFragmentName(def.name.value).removed\n    ) {\n      allFragmentNamesUsed.add(def.name.value);\n    }\n  });\n  // Now that we have added all fragment spreads used by operations to the\n  // allFragmentNamesUsed set, we can complete the set by transitively adding\n  // all fragment spreads used by those fragments, and so on.\n  allFragmentNamesUsed.forEach((fragmentName) => {\n    // Once all the childFragmentName strings added here have been seen already,\n    // the top-level allFragmentNamesUsed.forEach loop will terminate.\n    populateTransitiveVars(\n      getInUseByFragmentName(fragmentName)\n    ).fragmentSpreads.forEach((childFragmentName) => {\n      allFragmentNamesUsed.add(childFragmentName);\n    });\n  });\n\n  const fragmentWillBeRemoved = (fragmentName: string) =>\n    !!(\n      // A fragment definition will be removed if there are no spreads that refer\n      // to it, or the fragment was explicitly removed because it had no fields\n      // other than __typename.\n      (\n        !allFragmentNamesUsed.has(fragmentName) ||\n        getInUseByFragmentName(fragmentName).removed\n      )\n    );\n\n  const enterVisitor: EnterLeaveVisitor<\n    FragmentSpreadNode | FragmentDefinitionNode\n  > = {\n    enter(node) {\n      if (fragmentWillBeRemoved(node.name.value)) {\n        return null;\n      }\n    },\n  };\n\n  return nullIfDocIsEmpty(\n    visit(docWithoutDirectiveSubtrees, {\n      // If the fragment is going to be removed, then leaving any dangling\n      // FragmentSpread nodes with the same name would be a mistake.\n      FragmentSpread: enterVisitor,\n\n      // This is where the fragment definition is actually removed.\n      FragmentDefinition: enterVisitor,\n\n      OperationDefinition: {\n        leave(node) {\n          // Upon leaving each operation in the depth-first AST traversal, prune\n          // any variables that are declared by the operation but unused within.\n          if (node.variableDefinitions) {\n            const usedVariableNames = populateTransitiveVars(\n              // If an operation is anonymous, we use the empty string as its key.\n              getInUseByOperationName(node.name && node.name.value)\n            ).transitiveVars!;\n\n            // According to the GraphQL spec, all variables declared by an\n            // operation must either be used by that operation or used by some\n            // fragment included transitively into that operation:\n            // https://spec.graphql.org/draft/#sec-All-Variables-Used\n            //\n            // To stay on the right side of this validation rule, if/when we\n            // remove the last $var references from an operation or its fragments,\n            // we must also remove the corresponding $var declaration from the\n            // enclosing operation. This pruning applies only to operations and\n            // not fragment definitions, at the moment. Fragments may be able to\n            // declare variables eventually, but today they can only consume them.\n            if (usedVariableNames.size < node.variableDefinitions.length) {\n              return {\n                ...node,\n                variableDefinitions: node.variableDefinitions.filter((varDef) =>\n                  usedVariableNames.has(varDef.variable.name.value)\n                ),\n              };\n            }\n          }\n        },\n      },\n    })\n  );\n}\n\nexport const addTypenameToDocument = Object.assign(\n  function <TNode extends ASTNode>(doc: TNode): TNode {\n    return visit(doc, {\n      SelectionSet: {\n        enter(node, _key, parent) {\n          // Don't add __typename to OperationDefinitions.\n          if (\n            parent &&\n            (parent as OperationDefinitionNode).kind ===\n              Kind.OPERATION_DEFINITION\n          ) {\n            return;\n          }\n\n          // No changes if no selections.\n          const { selections } = node;\n          if (!selections) {\n            return;\n          }\n\n          // If selections already have a __typename, or are part of an\n          // introspection query, do nothing.\n          const skip = selections.some((selection) => {\n            return (\n              isField(selection) &&\n              (selection.name.value === \"__typename\" ||\n                selection.name.value.lastIndexOf(\"__\", 0) === 0)\n            );\n          });\n          if (skip) {\n            return;\n          }\n\n          // If this SelectionSet is @export-ed as an input variable, it should\n          // not have a __typename field (see issue #4691).\n          const field = parent as FieldNode;\n          if (\n            isField(field) &&\n            field.directives &&\n            field.directives.some((d) => d.name.value === \"export\")\n          ) {\n            return;\n          }\n\n          // Create and return a new SelectionSet with a __typename Field.\n          return {\n            ...node,\n            selections: [...selections, TYPENAME_FIELD],\n          };\n        },\n      },\n    });\n  },\n  {\n    added(field: FieldNode): boolean {\n      return field === TYPENAME_FIELD;\n    },\n  }\n);\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === \"connection\";\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some((arg) => arg.name.value === \"key\")\n      ) {\n        invariant.warn(\n          \"Removing an @connection directive even though it does not have a key. \" +\n            \"You may want to use the key parameter to specify a store key.\"\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc)\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode | undefined,\n  nestedCheck = true\n): boolean {\n  return (\n    !!selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some((selection) =>\n      hasDirectivesInSelection(directives, selection, nestedCheck)\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck\n      ))\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === Kind.VARIABLE &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument)))\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions:\n              node.variableDefinitions ?\n                node.variableDefinitions.filter(\n                  (varDef) =>\n                    !config.some(\n                      (arg) => arg.name === varDef.variable.name.value\n                    )\n                )\n              : [],\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(\n            (argConfig) => argConfig.remove\n          );\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            if (node.arguments) {\n              node.arguments.forEach((arg) => {\n                if (argMatcher(arg)) {\n                  argMatchCount += 1;\n                }\n              });\n            }\n\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    })\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode\n  ): null | void {\n    if (config.some((def) => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    })\n  );\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === \"query\") {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: \"query\",\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === \"client\",\n        remove: true,\n      },\n    ],\n    document\n  );\n\n  return modifiedDoc;\n}\n\nexport function addNonReactiveToNamedFragments(document: DocumentNode) {\n  checkDocument(document);\n\n  return visit(document, {\n    FragmentSpread: (node) => {\n      // Do not add `@nonreactive` if the fragment is marked with `@unmask`\n      // since we want to react to changes in this fragment.\n      if (\n        node.directives?.some((directive) => directive.name.value === \"unmask\")\n      ) {\n        return;\n      }\n\n      return {\n        ...node,\n        directives: [\n          ...(node.directives || []),\n          {\n            kind: Kind.DIRECTIVE,\n            name: { kind: Kind.NAME, value: \"nonreactive\" },\n          } satisfies DirectiveNode,\n        ],\n      };\n    },\n  });\n}\n","import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { DocumentNode } from \"graphql\";\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype OperationTypeNode = any;\nimport { equal } from \"@wry/equality\";\n\nimport type { ApolloLink, FetchResult } from \"../link/core/index.js\";\nimport { execute } from \"../link/core/index.js\";\nimport {\n  addNonReactiveToNamedFragments,\n  defaultCacheSizes,\n  hasDirectives,\n  isExecutionPatchIncrementalResult,\n  isExecutionPatchResult,\n  isFullyUnmaskedOperation,\n  removeDirectivesFromDocument,\n} from \"../utilities/index.js\";\nimport type { Cache, ApolloCache } from \"../cache/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\n\nimport type {\n  ObservableSubscription,\n  ConcastSourcesArray,\n} from \"../utilities/index.js\";\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  getGraphQLErrorsFromResult,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  makeUniqueId,\n  isDocumentNode,\n  isNonNullObject,\n  DocumentTransform,\n} from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport {\n  ApolloError,\n  isApolloError,\n  graphQLResultHasProtocolErrors,\n} from \"../errors/index.js\";\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n  MutationFetchPolicy,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type {\n  ApolloQueryResult,\n  OperationVariables,\n  MutationUpdaterFunction,\n  OnQueryUpdated,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  InternalRefetchQueriesMap,\n  DefaultContext,\n} from \"./types.js\";\nimport type { LocalState } from \"./LocalState.js\";\n\nimport type { QueryStoreValue } from \"./QueryInfo.js\";\nimport {\n  QueryInfo,\n  shouldWriteResult,\n  CacheWriteBehavior,\n} from \"./QueryInfo.js\";\nimport type { ApolloErrorOptions } from \"../errors/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nimport type { IgnoreModifier } from \"../cache/core/types/common.js\";\nimport type { TODO } from \"../utilities/types/TODO.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst IGNORE: IgnoreModifier = Object.create(null);\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ntype UpdateQueries<TData> = MutationOptions<TData, any, any>[\"updateQueries\"];\n\ninterface TransformCacheEntry {\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  hasNonreactiveDirective: boolean;\n  nonReactiveQuery: DocumentNode;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n}\n\nimport type { DefaultOptions } from \"./ApolloClient.js\";\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nimport { maskFragment, maskOperation } from \"../masking/index.js\";\nimport type { MaybeMasked, Unmasked } from \"../masking/index.js\";\nimport { muteDeprecations } from \"../utilities/deprecation/index.js\";\n\ninterface MaskFragmentOptions<TData> {\n  fragment: DocumentNode;\n  data: TData;\n  fragmentName?: string;\n}\n\ninterface MaskOperationOptions<TData> {\n  document: DocumentNode;\n  data: TData;\n  id: string;\n  fetchPolicy?: WatchQueryFetchPolicy;\n}\n\nexport interface QueryManagerOptions<TStore> {\n  cache: ApolloCache<TStore>;\n  link: ApolloLink;\n  defaultOptions: DefaultOptions;\n  documentTransform: DocumentTransform | null | undefined;\n  queryDeduplication: boolean;\n  onBroadcast: undefined | (() => void);\n  ssrMode: boolean;\n  clientAwareness: Record<string, string>;\n  localState: LocalState<TStore>;\n  assumeImmutableResults: boolean;\n  defaultContext: Partial<DefaultContext> | undefined;\n  dataMasking: boolean;\n}\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public defaultOptions: DefaultOptions;\n\n  public readonly assumeImmutableResults: boolean;\n  public readonly documentTransform: DocumentTransform;\n  public readonly ssrMode: boolean;\n  public readonly defaultContext: Partial<DefaultContext>;\n  public readonly dataMasking: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor(options: QueryManagerOptions<TStore>) {\n    const defaultDocumentTransform = new DocumentTransform(\n      (document) => this.cache.transformDocument(document),\n      // Allow the apollo cache to manage its own transform caches\n      { cache: false }\n    );\n\n    this.cache = options.cache;\n    this.link = options.link;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientAwareness = options.clientAwareness;\n    this.localState = options.localState;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    const documentTransform = options.documentTransform;\n    this.documentTransform =\n      documentTransform ?\n        defaultDocumentTransform\n          .concat(documentTransform)\n          // The custom document transform may add new fragment spreads or new\n          // field selections, so we want to give the cache a chance to run\n          // again. For example, the InMemoryCache adds __typename to field\n          // selections and fragments from the fragment registry.\n          .concat(defaultDocumentTransform)\n      : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || Object.create(null);\n\n    if ((this.onBroadcast = options.onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      newInvariantError(\"QueryManager stopped while query was in flight\")\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach((cancel) => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables extends OperationVariables,\n    TContext extends Record<string, any>,\n    TCache extends ApolloCache<any>,\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy = this.defaultOptions.mutate?.fetchPolicy || \"network-only\",\n    errorPolicy = this.defaultOptions.mutate?.errorPolicy || \"none\",\n    keepRootFields,\n    context,\n  }: MutationOptions<TData, TVariables, TContext>): Promise<\n    FetchResult<MaybeMasked<TData>>\n  > {\n    invariant(\n      mutation,\n      \"mutation option is required. You must specify your GraphQL document in the mutation option.\"\n    );\n\n    invariant(\n      fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\",\n      \"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\"\n    );\n\n    const mutationId = this.generateMutationId();\n\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const { hasClientExports } = this.getDocumentInfo(mutation);\n\n    variables = this.getVariables(mutation, variables) as TVariables;\n    if (hasClientExports) {\n      variables = (await this.localState.addExportedVariables(\n        mutation,\n        variables,\n        context\n      )) as TVariables;\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    const isOptimistic =\n      optimisticResponse &&\n      this.markMutationOptimistic<TData, TVariables, TContext, TCache>(\n        optimisticResponse,\n        {\n          mutationId,\n          document: mutation,\n          variables,\n          fetchPolicy,\n          errorPolicy,\n          context,\n          updateQueries,\n          update: updateWithProxyFn,\n          keepRootFields,\n        }\n      );\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      return asyncMap(\n        self.getObservableFromLink(\n          mutation,\n          {\n            ...context,\n            optimisticResponse: isOptimistic ? optimisticResponse : void 0,\n          },\n          variables,\n          {},\n          false\n        ),\n\n        (result: FetchResult<TData>) => {\n          if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n            throw new ApolloError({\n              graphQLErrors: getGraphQLErrorsFromResult(result),\n            });\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          const storeResult: typeof result = { ...result };\n\n          if (typeof refetchQueries === \"function\") {\n            refetchQueries = refetchQueries(\n              storeResult as FetchResult<Unmasked<TData>>\n            );\n          }\n\n          if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n            delete storeResult.errors;\n          }\n\n          return self.markMutationResult<TData, TVariables, TContext, TCache>({\n            mutationId,\n            result: storeResult,\n            document: mutation,\n            variables,\n            fetchPolicy,\n            errorPolicy,\n            context,\n            update: updateWithProxyFn,\n            updateQueries,\n            awaitRefetchQueries,\n            refetchQueries,\n            removeOptimistic: isOptimistic ? mutationId : void 0,\n            onQueryUpdated,\n            keepRootFields,\n          });\n        }\n      ).subscribe({\n        next(storeResult) {\n          self.broadcastQueries();\n\n          // Since mutations might receive multiple payloads from the\n          // ApolloLink chain (e.g. when used with @defer),\n          // we resolve with a SingleExecutionResult or after the final\n          // ExecutionPatchResult has arrived and we have assembled the\n          // multipart response into a single result.\n          if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n            resolve({\n              ...storeResult,\n              data: self.maskOperation({\n                document: mutation,\n                data: storeResult.data,\n                fetchPolicy,\n                id: mutationId,\n              }) as any,\n            });\n          }\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n\n          if (isOptimistic) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          reject(\n            err instanceof ApolloError ? err : (\n              new ApolloError({\n                networkError: err,\n              })\n            )\n          );\n        },\n      });\n    });\n  }\n\n  public markMutationResult<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      awaitRefetchQueries?: boolean;\n      refetchQueries?: InternalRefetchQueriesInclude;\n      removeOptimistic?: string;\n      onQueryUpdated?: OnQueryUpdated<any>;\n      keepRootFields?: boolean;\n    },\n    cache = this.cache\n  ): Promise<FetchResult<TData>> {\n    let { result } = mutation;\n    const cacheWrites: Cache.WriteOptions[] = [];\n    const skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: \"ROOT_MUTATION\",\n          query: mutation.document,\n          variables: mutation.variables,\n        });\n      }\n      if (\n        isExecutionPatchIncrementalResult(result) &&\n        isNonEmptyArray(result.incremental)\n      ) {\n        const diff = cache.diff<TData>({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true,\n        });\n        let mergedData;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== \"undefined\") {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          (result as FetchResult).data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables,\n          });\n        }\n      }\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result as FetchResult<Unmasked<TData>>,\n              queryName: (document && getOperationName(document)) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: \"ROOT_QUERY\",\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (\n      cacheWrites.length > 0 ||\n      (mutation.refetchQueries || \"\").length > 0 ||\n      mutation.update ||\n      mutation.onQueryUpdated ||\n      mutation.removeOptimistic\n    ) {\n      const results: any[] = [];\n\n      this.refetchQueries({\n        updateCache: (cache) => {\n          if (!skipCache) {\n            cacheWrites.forEach((write) => cache.write(write));\n          }\n\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          const { update } = mutation;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          const isFinalResult =\n            !isExecutionPatchResult(result) ||\n            (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              const diff = cache.diff<TData>({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true,\n              });\n\n              if (diff.complete) {\n                result = { ...(result as FetchResult), data: diff.result };\n                if (\"incremental\" in result) {\n                  delete result.incremental;\n                }\n                if (\"hasNext\" in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache as TCache, result as FetchResult<Unmasked<TData>>, {\n                context: mutation.context,\n                variables: mutation.variables,\n              });\n            }\n          }\n\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: \"ROOT_MUTATION\",\n              fields(value, { fieldName, DELETE }) {\n                return fieldName === \"__typename\" ? value : DELETE;\n              },\n            });\n          }\n        },\n\n        include: mutation.refetchQueries,\n\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null,\n      }).forEach((result) => results.push(result));\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results).then(() => result);\n      }\n    }\n\n    return Promise.resolve(result);\n  }\n\n  public markMutationOptimistic<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      keepRootFields?: boolean;\n    }\n  ) {\n    const data =\n      typeof optimisticResponse === \"function\" ?\n        optimisticResponse(mutation.variables, { IGNORE })\n      : optimisticResponse;\n\n    if (data === IGNORE) {\n      return false;\n    }\n\n    this.cache.recordOptimisticTransaction((cache) => {\n      try {\n        this.markMutationResult<TData, TVariables, TContext, TCache>(\n          {\n            ...mutation,\n            result: { data },\n          },\n          cache\n        );\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n\n    return true;\n  }\n\n  public fetchQuery<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchConcastWithInfo(\n      this.getOrCreateQuery(queryId),\n      options,\n      networkStatus\n    ).concast.promise as TODO;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  public transform(document: DocumentNode) {\n    return this.documentTransform.transformDocument(document);\n  }\n\n  private transformCache = new AutoCleanedWeakCache<\n    DocumentNode,\n    TransformCacheEntry\n  >(\n    cacheSizes[\"queryManager.getDocumentInfo\"] ||\n      defaultCacheSizes[\"queryManager.getDocumentInfo\"]\n  );\n\n  public getDocumentInfo(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cacheEntry: TransformCacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument(\n          [\n            { name: \"client\", remove: true },\n            { name: \"connection\" },\n            { name: \"nonreactive\" },\n            { name: \"unmask\" },\n          ],\n          document\n        ),\n        defaultVars: getDefaultValues(\n          getOperationDefinition(document)\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...document,\n          definitions: document.definitions.map((def) => {\n            if (\n              def.kind === \"OperationDefinition\" &&\n              def.operation !== \"query\"\n            ) {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        },\n      };\n\n      transformCache.set(document, cacheEntry);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables<TVariables>(\n    document: DocumentNode,\n    variables?: TVariables\n  ): OperationVariables {\n    return {\n      ...this.getDocumentInfo(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<\n    T,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    const query = this.transform(options.query);\n\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = {\n      ...options,\n      variables: this.getVariables(query, options.variables) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n    observable[\"lastQuery\"] = query;\n\n    if (!ObservableQuery[\"inactiveOnCreation\"].getValue()) {\n      this.queries.set(observable.queryId, queryInfo);\n    }\n\n    // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars extends OperationVariables = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n    queryId = this.generateQueryId()\n  ): Promise<ApolloQueryResult<MaybeMasked<TData>>> {\n    invariant(\n      options.query,\n      \"query option is required. You must specify your GraphQL document \" +\n        \"in the query option.\"\n    );\n\n    invariant(\n      options.query.kind === \"Document\",\n      'You must wrap the query string in a \"gql\" tag.'\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      \"returnPartialData option only supported on watchQuery.\"\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      \"pollInterval option only supported on watchQuery.\"\n    );\n\n    const query = this.transform(options.query);\n\n    return this.fetchQuery<TData, TVars>(queryId, { ...options, query })\n      .then(\n        (result) =>\n          result && {\n            ...result,\n            data: this.maskOperation({\n              document: query,\n              data: result.data,\n              fetchPolicy: options.fetchPolicy,\n              id: queryId,\n            }),\n          }\n      )\n      .finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(\n    options: Cache.ResetOptions = {\n      discardWatches: true,\n    }\n  ): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(\n      newInvariantError(\n        \"Store reset while query was in flight (not completed in link chain)\"\n      )\n    );\n\n    this.queries.forEach((queryInfo) => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\"\n  ) {\n    const queries = new Map<string, ObservableQuery<any>>();\n    const queryNames = new Map<string, string | null>();\n    const queryNamesAndQueryStrings = new Map<string, boolean>();\n    const legacyQueryOptions = new Set<QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach((desc) => {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          const queryString = print(this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(({ observableQuery: oq, document }, queryId) => {\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        const {\n          queryName,\n          options: { fetchPolicy },\n        } = oq;\n\n        if (\n          fetchPolicy === \"standby\" ||\n          (include === \"active\" && !oq.hasObservers())\n        ) {\n          return;\n        }\n\n        if (\n          include === \"active\" ||\n          (queryName && queryNamesAndQueryStrings.has(queryName)) ||\n          (document && queryNamesAndQueryStrings.has(print(document)))\n        ) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n          if (document) queryNamesAndQueryStrings.set(print(document), true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options: QueryOptions) => {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        const queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        const queryInfo = this.getOrCreateQuery(queryId).init({\n          document: options.query,\n          variables: options.variables,\n        });\n        const oq = new ObservableQuery({\n          queryManager: this,\n          queryInfo,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach((included, nameOrQueryString) => {\n        if (!included) {\n          const queryName = queryNames.get(nameOrQueryString);\n\n          if (queryName) {\n            invariant.warn(\n              `Unknown query named \"%s\" requested in refetchQueries options.include array`,\n              queryName\n            );\n          } else {\n            invariant.warn(\n              `Unknown anonymous query requested in refetchQueries options.include array`\n            );\n          }\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(\n      (observableQuery, queryId) => {\n        const { fetchPolicy } = observableQuery.options;\n        muteDeprecations(\"resetLastResults\", () =>\n          observableQuery.resetLastResults()\n        );\n        if (\n          includeStandby ||\n          (fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\")\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n        (this.queries.get(queryId) || observableQuery[\"queryInfo\"]).setDiff(\n          null\n        );\n      }\n    );\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public startGraphQLSubscription<T = any>(\n    options: SubscriptionOptions\n  ): Observable<FetchResult<T>> {\n    let { query, variables } = options;\n    const {\n      fetchPolicy,\n      errorPolicy = \"none\",\n      context = {},\n      extensions = {},\n    } = options;\n\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(query, context, variables, extensions).map(\n        (result) => {\n          if (fetchPolicy !== \"no-cache\") {\n            // the subscription interface should handle not sending us results we no longer subscribe to.\n            // XXX I don't think we ever send in an object with errors, but we might in the future...\n            if (shouldWriteResult(result, errorPolicy)) {\n              this.cache.write({\n                query,\n                result: result.data,\n                dataId: \"ROOT_SUBSCRIPTION\",\n                variables: variables,\n              });\n            }\n\n            this.broadcastQueries();\n          }\n\n          const hasErrors = graphQLResultHasError(result);\n          const hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n          if (hasErrors || hasProtocolErrors) {\n            const errors: ApolloErrorOptions = {};\n            if (hasErrors) {\n              errors.graphQLErrors = result.errors;\n            }\n            if (hasProtocolErrors) {\n              errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n            }\n\n            // `errorPolicy` is a mechanism for handling GraphQL errors, according\n            // to our documentation, so we throw protocol errors regardless of the\n            // set error policy.\n            if (errorPolicy === \"none\" || hasProtocolErrors) {\n              throw new ApolloError(errors);\n            }\n          }\n\n          if (errorPolicy === \"ignore\") {\n            delete result.errors;\n          }\n\n          return result;\n        }\n      );\n\n    if (this.getDocumentInfo(query).hasClientExports) {\n      const observablePromise = this.localState\n        .addExportedVariables(query, variables, context)\n        .then(makeObservable);\n\n      return new Observable<FetchResult<T>>((observer) => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          (observable) => (sub = observable.subscribe(observer)),\n          observer.error\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.queries.get(queryId)?.stop();\n      this.queries.delete(queryId);\n    }\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach((info) => info.observableQuery?.[\"notify\"]());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected inFlightLinkObservables = new Trie<{\n    observable?: Observable<FetchResult<any>>;\n  }>(false);\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    extensions?: Record<string, any>,\n    // Prefer context.queryDeduplication if specified.\n    deduplication: boolean = context?.queryDeduplication ??\n      this.queryDeduplication\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>> | undefined;\n\n    const { serverQuery, clientQuery } = this.getDocumentInfo(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication,\n        }),\n        extensions,\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const printedServerQuery = print(serverQuery);\n        const varJson = canonicalStringify(variables);\n\n        const entry = inFlightLinkObservables.lookup(\n          printedServerQuery,\n          varJson\n        );\n\n        observable = entry.observable;\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>,\n          ]);\n          observable = entry.observable = concast;\n\n          concast.beforeNext(function cb(method, arg: FetchResult) {\n            if (method === \"next\" && \"hasNext\" in arg && arg.hasNext) {\n              concast.beforeNext(cb);\n            } else {\n              inFlightLinkObservables.remove(printedServerQuery, varJson);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>,\n        ]);\n      }\n    } else {\n      observable = new Concast([Observable.of({ data: {} } as FetchResult<T>)]);\n      context = this.prepareContext(context);\n    }\n\n    if (clientQuery) {\n      observable = asyncMap(observable, (result) => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    cacheWriteBehavior: CacheWriteBehavior,\n    options: Pick<\n      WatchQueryOptions<TVars, TData>,\n      \"query\" | \"variables\" | \"context\" | \"fetchPolicy\" | \"errorPolicy\"\n    >\n  ): Observable<ApolloQueryResult<TData>> {\n    const requestId = (queryInfo.lastRequestId = this.generateRequestId());\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n\n    return asyncMap(\n      this.getObservableFromLink(\n        linkDocument,\n        options.context,\n        options.variables\n      ),\n\n      (result) => {\n        const graphQLErrors = getGraphQLErrorsFromResult(result);\n        const hasErrors = graphQLErrors.length > 0;\n        const { errorPolicy } = options;\n\n        // If we interrupted this request by calling getResultsFromLink again\n        // with the same QueryInfo object, we ignore the old results.\n        if (requestId >= queryInfo.lastRequestId) {\n          if (hasErrors && errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(\n              new ApolloError({\n                graphQLErrors,\n              })\n            );\n          }\n          // Use linkDocument rather than queryInfo.document so the\n          // operation/fragments used to write the result are the same as the\n          // ones used to obtain it from the link.\n          queryInfo.markResult(\n            result,\n            linkDocument,\n            options,\n            cacheWriteBehavior\n          );\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n\n        // In the case we start multiple network requests simulatenously, we\n        // want to ensure we properly set `data` if we're reporting on an old\n        // result which will not be caught by the conditional above that ends up\n        // throwing the markError result.\n        if (hasErrors && errorPolicy === \"none\") {\n          aqr.data = void 0 as TData;\n        }\n\n        if (hasErrors && errorPolicy !== \"ignore\") {\n          aqr.errors = graphQLErrors;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return aqr;\n      },\n\n      (networkError) => {\n        const error =\n          isApolloError(networkError) ? networkError : (\n            new ApolloError({ networkError })\n          );\n\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      }\n    );\n  }\n\n  private fetchConcastWithInfo<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading,\n    query = options.query\n  ): ConcastAndInfo<TData> {\n    const variables = this.getVariables(query, options.variables) as TVars;\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = (defaults && defaults.fetchPolicy) || \"cache-first\",\n      errorPolicy = (defaults && defaults.errorPolicy) || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const sourcesWithInfo = this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus\n      );\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\" &&\n        // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n        // this is another way to detect when nothing was done/fetched.\n        sourcesWithInfo.sources.length > 0 &&\n        queryInfo.observableQuery\n      ) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\n          \"after-fetch\",\n          options\n        );\n      }\n\n      return sourcesWithInfo;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => this.fetchCancelFns.delete(queryInfo.queryId);\n    this.fetchCancelFns.set(queryInfo.queryId, (reason) => {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(() => concast.cancel(reason));\n    });\n\n    let concast: Concast<ApolloQueryResult<TData>>,\n      containsDataFromLink: boolean;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(\n        this.localState\n          .addExportedVariables(\n            normalized.query,\n            normalized.variables,\n            normalized.context\n          )\n          .then(fromVariables)\n          .then((sourcesWithInfo) => sourcesWithInfo.sources)\n      );\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n\n    return {\n      concast,\n      fromLink: containsDataFromLink,\n    };\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<\n    ApolloCache<TStore>,\n    TResult\n  >): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesById = new Map<\n      string,\n      {\n        oq: ObservableQuery<any>;\n        lastDiff?: Cache.DiffResult<any>;\n        diff?: Cache.DiffResult<any>;\n      }\n    >();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq, queryId) => {\n        includedQueriesById.set(queryId, {\n          oq,\n          lastDiff: (this.queries.get(queryId) || oq[\"queryInfo\"]).getDiff(),\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map();\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: (optimistic && removeOptimistic) || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq =\n            watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n\n              let result: TResult | boolean | Promise<ApolloQueryResult<any>> =\n                onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(\n                  oq,\n                  result as InternalRefetchQueriesResult<TResult>\n                );\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(({ oq, lastDiff, diff }, queryId) => {\n        let result:\n          | TResult\n          | boolean\n          | Promise<ApolloQueryResult<any>>\n          | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            diff = muteDeprecations(\"canonizeResults\", () =>\n              this.cache.diff(oq[\"queryInfo\"][\"getDiffOptions\"]())\n            );\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private noCacheWarningsByQueryId = new Set<string>();\n\n  public maskOperation<TData = unknown>(\n    options: MaskOperationOptions<TData>\n  ): MaybeMasked<TData> {\n    const { document, data } = options;\n\n    if (__DEV__) {\n      const { fetchPolicy, id } = options;\n      const operationType = getOperationDefinition(document)?.operation;\n      const operationId = (operationType?.[0] ?? \"o\") + id;\n\n      if (\n        this.dataMasking &&\n        fetchPolicy === \"no-cache\" &&\n        !isFullyUnmaskedOperation(document) &&\n        !this.noCacheWarningsByQueryId.has(operationId)\n      ) {\n        this.noCacheWarningsByQueryId.add(operationId);\n\n        invariant.warn(\n          '[%s]: Fragments masked by data masking are inaccessible when using fetch policy \"no-cache\". Please add `@unmask` to each fragment spread to access the data.',\n          getOperationName(document) ??\n            `Unnamed ${operationType ?? \"operation\"}`\n        );\n      }\n    }\n\n    return (\n      this.dataMasking ?\n        maskOperation(data, document, this.cache)\n      : data) as MaybeMasked<TData>;\n  }\n\n  public maskFragment<TData = unknown>(options: MaskFragmentOptions<TData>) {\n    const { data, fragment, fragmentName } = options;\n\n    return this.dataMasking ?\n        maskFragment(data, fragment, this.cache, fragmentName)\n      : data;\n  }\n\n  private fetchQueryByPolicy<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    {\n      query,\n      variables,\n      fetchPolicy,\n      refetchWritePolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n      notifyOnNetworkStatusChange,\n    }: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus\n  ): SourcesAndInfo<TData> {\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    queryInfo.init({\n      document: query,\n      variables,\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff();\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading\n    ) => {\n      const data = diff.result;\n\n      if (__DEV__ && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const fromData = (data: TData | undefined) =>\n        Observable.of({\n          data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus,\n          ...(diff.complete ? null : { partial: true }),\n        } as ApolloQueryResult<TData>);\n\n      if (data && this.getDocumentInfo(query).hasForcedResolvers) {\n        return this.localState\n          .runResolvers({\n            document: query,\n            remoteResult: { data },\n            context,\n            variables,\n            onlyRunForcedResolvers: true,\n          })\n          .then((resolved) => fromData(resolved.data || void 0));\n      }\n\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (\n        errorPolicy === \"none\" &&\n        networkStatus === NetworkStatus.refetch &&\n        Array.isArray(diff.missing)\n      ) {\n        return fromData(void 0);\n      }\n\n      return fromData(data);\n    };\n\n    const cacheWriteBehavior =\n      fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID\n        // Watched queries must opt into overwriting existing data on refetch,\n        // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n      : (\n        networkStatus === NetworkStatus.refetch &&\n        refetchWritePolicy !== \"merge\"\n      ) ?\n        CacheWriteBehavior.OVERWRITE\n      : CacheWriteBehavior.MERGE;\n\n    const resultsFromLink = () =>\n      this.getResultsFromLink<TData, TVars>(queryInfo, cacheWriteBehavior, {\n        query,\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      });\n\n    const shouldNotify =\n      notifyOnNetworkStatusChange &&\n      typeof oldNetworkStatus === \"number\" &&\n      oldNetworkStatus !== networkStatus &&\n      isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\": {\n        const diff = readCache();\n\n        if (diff.complete) {\n          return {\n            fromLink: false,\n            sources: [resultsFromCache(diff, queryInfo.markReady())],\n          };\n        }\n\n        if (returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-and-network\": {\n        const diff = readCache();\n\n        if (diff.complete || returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())],\n        };\n\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"standby\":\n        return { fromLink: false, sources: [] };\n    }\n  }\n\n  public getOrCreateQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...this.defaultContext,\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n\n// Return types used by fetchQueryByPolicy and other private methods above.\ninterface FetchConcastInfo {\n  // Metadata properties that can be returned in addition to the Concast.\n  fromLink: boolean;\n}\ninterface SourcesAndInfo<TData> extends FetchConcastInfo {\n  sources: ConcastSourcesArray<ApolloQueryResult<TData>>;\n}\ninterface ConcastAndInfo<TData> extends FetchConcastInfo {\n  concast: Concast<ApolloQueryResult<TData>>;\n}\n","import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { DocumentNode, FormattedExecutionResult } from \"graphql\";\n\nimport type { GraphQLRequest } from \"../link/core/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport type { ApolloCache, DataProxy, Reference } from \"../cache/index.js\";\nimport type { DocumentTransform } from \"../utilities/index.js\";\nimport type { Observable } from \"../utilities/index.js\";\nimport { version } from \"../version.js\";\nimport type { UriFunction } from \"../link/http/index.js\";\nimport { HttpLink } from \"../link/http/index.js\";\n\nimport { QueryManager } from \"./QueryManager.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\n\nimport type {\n  DefaultContext,\n  OperationVariables,\n  Resolvers,\n  RefetchQueriesOptions,\n  RefetchQueriesResult,\n  InternalRefetchQueriesResult,\n  RefetchQueriesInclude,\n  InteropApolloQueryResult,\n  InteropMutateResult,\n  InteropSubscribeResult,\n} from \"./types.js\";\n\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nimport type { FragmentMatcher } from \"./LocalState.js\";\nimport { LocalState } from \"./LocalState.js\";\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions<any, any>>;\n  query?: Partial<QueryOptions<any, any>>;\n  mutate?: Partial<MutationOptions<any, any, any>>;\n}\n\nexport interface DevtoolsOptions {\n  /**\n   * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to this `ApolloClient` instance.\n   *\n   * The default value is `false` in production and `true` in development if there is a `window` object.\n   */\n  enabled?: boolean;\n\n  /**\n   * Optional name for this `ApolloClient` instance in the devtools. This is\n   * useful when you instantiate multiple clients and want to be able to\n   * identify them by name.\n   */\n  name?: string;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport interface ApolloClientOptions<TCacheShape> {\n  /**\n   * The URI of the GraphQL endpoint that Apollo Client will communicate with.\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   *\n   * @deprecated `uri` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Instantiate an instance of `HttpClient` and pass `uri` as an option.\n   *\n   * ```js\n   * import { HttpLink } from \"@apollo/client\";\n   *\n   * new ApolloClient({\n   *   link: new HttpLink({ uri })\n   * });\n   * ```\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * @deprecated `credentials` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Instantiate an instance of `HttpClient` and pass `credentials` as an option.\n   *\n   * ```js\n   * import { HttpLink } from \"@apollo/client\";\n   *\n   * new ApolloClient({\n   *   link: new HttpLink({ credentials })\n   * });\n   * ```\n   */\n  credentials?: string;\n  /**\n   * An object representing headers to include in every HTTP request, such as `{Authorization: 'Bearer 1234'}`\n   *\n   * This value will be ignored when using the `link` option.\n   *\n   * @deprecated `headers` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Instantiate an instance of `HttpClient` and pass `headers` as an option.\n   *\n   * ```js\n   * import { HttpLink } from \"@apollo/client\";\n   *\n   * new ApolloClient({\n   *   link: new HttpLink({ headers })\n   * });\n   * ```\n   */\n  headers?: Record<string, string>;\n  /**\n   * You can provide an `ApolloLink` instance to serve as Apollo Client's network layer. For more information, see [Advanced HTTP networking](https://www.apollographql.com/docs/react/networking/advanced-http-networking/).\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   */\n  link?: ApolloLink;\n  /**\n   * The cache that Apollo Client should use to store query results locally. The recommended cache is `InMemoryCache`, which is provided by the `@apollo/client` package.\n   *\n   * For more information, see [Configuring the cache](https://www.apollographql.com/docs/react/caching/cache-configuration/).\n   */\n  cache: ApolloCache<TCacheShape>;\n  /**\n   * The time interval (in milliseconds) before Apollo Client force-fetches queries after a server-side render.\n   *\n   * @defaultValue `0` (no delay)\n   */\n  ssrForceFetchDelay?: number;\n  /**\n   * When using Apollo Client for [server-side rendering](https://www.apollographql.com/docs/react/performance/server-side-rendering/), set this to `true` so that the [`getDataFromTree` function](../react/ssr/#getdatafromtree) can work effectively.\n   *\n   * @defaultValue `false`\n   */\n  ssrMode?: boolean;\n  /**\n   * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to Apollo Client.\n   *\n   * The default value is `false` in production and `true` in development (if there is a `window` object).\n   *\n   * @deprecated `connectToDevTools` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Use the `devtools.enabled` option instead.\n   *\n   * ```ts\n   * new ApolloClient({\n   *   devtools: { enabled: true }\n   * });\n   * ```\n   */\n  connectToDevTools?: boolean;\n  /**\n   * If `false`, Apollo Client sends every created query to the server, even if a _completely_ identical query (identical in terms of query string, variable values, and operationName) is already in flight.\n   *\n   * @defaultValue `true`\n   */\n  queryDeduplication?: boolean;\n  /**\n   * Provide this object to set application-wide default values for options you can provide to the `watchQuery`, `query`, and `mutate` functions. See below for an example object.\n   *\n   * See this [example object](https://www.apollographql.com/docs/react/api/core/ApolloClient#example-defaultoptions-object).\n   */\n  defaultOptions?: DefaultOptions;\n  defaultContext?: Partial<DefaultContext>;\n  /**\n   * If `true`, Apollo Client will assume results read from the cache are never mutated by application code, which enables substantial performance optimizations.\n   *\n   * @defaultValue `false`\n   */\n  assumeImmutableResults?: boolean;\n\n  /**\n   * @deprecated `resolvers` has been moved in Apollo Client 4.0. This option is\n   * safe to use in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * `resolvers` will need to be passed as the `resolvers` option to an instance\n   * of `LocalState`. That `LocalState` instance should be provided as the\n   * `localState` option to the `ApolloClient` constructor.\n   */\n  resolvers?: Resolvers | Resolvers[];\n\n  /**\n   * @deprecated `typeDefs` will be removed in Apollo Client 4.0. It is safe to\n   * stop using this option in Apollo Client 3.x.\n   */\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n\n  /**\n   * @deprecated Custom fragment matchers will no longer be supported in Apollo\n   * Client 4.0 and has been replaced by `cache.fragmentMatches`. It is safe to\n   * continue using this in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * Leverage `possibleTypes` with `InMemoryCache` to ensure fragments match\n   * correctly. Ensure `possibleTypes` include local types if needed. This\n   * option should then be removed. If working with a 3rd party cache\n   * implementation, ensure the 3rd party cache implements the\n   * `cache.fragmentMatches` method.\n   */\n  fragmentMatcher?: FragmentMatcher;\n  /**\n   * A custom name (e.g., `iOS`) that identifies this particular client among your set of clients. Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   *\n   * @deprecated `name` has been moved to `clientAwareness.name` in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Use `clientAwareness.name` to set the client awareness name.\n   *\n   * ```ts\n   * new ApolloClient({ clientAwareness: { name } });\n   * ```\n   */\n  name?: string;\n  /**\n   * A custom version that identifies the current version of this particular client (e.g., `1.2`). Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   *\n   * This is **not** the version of Apollo Client that you are using, but rather any version string that helps you differentiate between versions of your client.\n   *\n   * @deprecated `name` has been moved to `clientAwareness.version` in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Use `clientAwareness.version` to set the client awareness version.\n   *\n   * ```ts\n   * new ApolloClient({ clientAwareness: { version } });\n   * ```\n   */\n  version?: string;\n\n  clientAwareness?: {\n    /**\n     * A custom name (e.g., `iOS`) that identifies this particular client among your set of clients. Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n     */\n    name?: string;\n    /**\n     * A custom version that identifies the current version of this particular client (e.g., `1.2`). Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n     *\n     * This is **not** the version of Apollo Client that you are using, but rather any version string that helps you differentiate between versions of your client.\n     */\n    version?: string;\n  };\n\n  documentTransform?: DocumentTransform;\n\n  /**\n   * Configuration used by the [Apollo Client Devtools extension](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) for this client.\n   *\n   * @since 3.11.0\n   */\n  devtools?: DevtoolsOptions;\n\n  /**\n   * Determines if data masking is enabled for the client.\n   *\n   * @defaultValue false\n   */\n  dataMasking?: boolean;\n}\n\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nimport { getApolloClientMemoryInternals } from \"../utilities/caching/getMemoryInternals.js\";\nimport type {\n  WatchFragmentOptions,\n  WatchFragmentResult,\n} from \"../cache/core/cache.js\";\nimport type { MaybeMasked, Unmasked } from \"../masking/index.js\";\nimport { warnRemovedOption } from \"../utilities/deprecation/index.js\";\nexport { mergeOptions };\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nexport class ApolloClient<TCacheShape = any> implements DataProxy {\n  public link: ApolloLink;\n  public cache: ApolloCache<TCacheShape>;\n\n  /**\n   * @deprecated `disableNetworkFetches` has been renamed to `prioritizeCacheValues`\n   * in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Access `client.prioritizeCacheValues` instead.\n   */\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions;\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>[\"typeDefs\"];\n  public readonly devtoolsConfig: DevtoolsOptions;\n\n  private queryManager: QueryManager<TCacheShape>;\n  private devToolsHookCb?: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  public localState: LocalState<TCacheShape>;\n\n  /**\n   * Whether to prioritize cache values over network results when `query` or `watchQuery` is called.\n   * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"` fetchPolicy into a `\"cache-first\"` fetchPolicy,\n   * but without influencing the `fetchPolicy` of the created `ObservableQuery` long-term.\n   *\n   * This can e.g. be used to prioritize the cache during the first render after SSR.\n   */\n  public get prioritizeCacheValues() {\n    return this.disableNetworkFetches;\n  }\n\n  public set prioritizeCacheValues(value: boolean) {\n    this.disableNetworkFetches = value;\n  }\n\n  /**\n   * Constructs an instance of `ApolloClient`.\n   *\n   * @example\n   * ```js\n   * import { ApolloClient, InMemoryCache } from '@apollo/client';\n   *\n   * const cache = new InMemoryCache();\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   uri: 'http://localhost:4000/',\n   *\n   *   // Provide some optional constructor fields\n   *   name: 'react-web-client',\n   *   version: '1.3',\n   *   queryDeduplication: false,\n   *   defaultOptions: {\n   *     watchQuery: {\n   *       fetchPolicy: 'cache-and-network',\n   *     },\n   *   },\n   * });\n   * ```\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    if (!options.cache) {\n      throw newInvariantError(\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n          \"in the options object. \\n\" +\n          \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    const {\n      uri,\n      credentials,\n      headers,\n      cache,\n      documentTransform,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      // Expose the client instance as window.__APOLLO_CLIENT__ and call\n      // onBroadcast in queryManager.broadcastQueries to enable browser\n      // devtools, but disable them by default in production.\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      defaultContext,\n      assumeImmutableResults = cache.assumeImmutableResults,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      clientAwareness,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n      devtools,\n      dataMasking,\n    } = options;\n\n    if (__DEV__) {\n      warnRemovedOption(\n        options,\n        \"connectToDevTools\",\n        \"ApolloClient\",\n        \"Please use `devtools.enabled` instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"uri\",\n        \"ApolloClient\",\n        \"Please initialize an instance of `HttpLink` with `uri` instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"credentials\",\n        \"ApolloClient\",\n        \"Please initialize an instance of `HttpLink` with `credentials` instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"headers\",\n        \"ApolloClient\",\n        \"Please initialize an instance of `HttpLink` with `headers` instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"name\",\n        \"ApolloClient\",\n        \"Please use the `clientAwareness.name` option instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"version\",\n        \"ApolloClient\",\n        \"Please use the `clientAwareness.version` option instead.\"\n      );\n      warnRemovedOption(options, \"typeDefs\", \"ApolloClient\");\n\n      if (!options.link) {\n        invariant.warn(\n          \"[ApolloClient]: Apollo Client 4.0 will require a `link` option and will not create a default link when not provided. Please provide a `link` option.\"\n        );\n      }\n    }\n\n    let { link } = options;\n\n    if (!link) {\n      link =\n        uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n    this.devtoolsConfig = {\n      ...devtools,\n      enabled: devtools?.enabled ?? connectToDevTools,\n    };\n\n    if (this.devtoolsConfig.enabled === undefined) {\n      this.devtoolsConfig.enabled = __DEV__;\n    }\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.watchFragment = this.watchFragment.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      defaultContext,\n      documentTransform,\n      queryDeduplication,\n      ssrMode,\n      dataMasking: !!dataMasking,\n      clientAwareness: {\n        name: clientAwareness?.name ?? clientAwarenessName!,\n        version: clientAwareness?.version ?? clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast:\n        this.devtoolsConfig.enabled ?\n          () => {\n            if (this.devToolsHookCb) {\n              this.devToolsHookCb({\n                action: {},\n                state: {\n                  queries: this.queryManager.getQueryStore(),\n                  mutations: this.queryManager.mutationStore || {},\n                },\n                dataWithOptimisticResults: this.cache.extract(true),\n              });\n            }\n          }\n        : void 0,\n    });\n\n    if (this.devtoolsConfig.enabled) this.connectToDevTools();\n  }\n\n  private connectToDevTools() {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n\n    type DevToolsConnector = {\n      push(client: ApolloClient<any>): void;\n    };\n    const windowWithDevTools = window as Window & {\n      [devtoolsSymbol]?: DevToolsConnector;\n      __APOLLO_CLIENT__?: ApolloClient<any>;\n    };\n    const devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n    (windowWithDevTools[devtoolsSymbol] =\n      windowWithDevTools[devtoolsSymbol] || ([] as DevToolsConnector)).push(\n      this\n    );\n    windowWithDevTools.__APOLLO_CLIENT__ = this;\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && __DEV__) {\n      hasSuggestedDevtools = true;\n      if (\n        window.document &&\n        window.top === window.self &&\n        /^(https?|file):$/.test(window.location.protocol)\n      ) {\n        setTimeout(() => {\n          if (!(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n            const nav = window.navigator;\n            const ua = nav && nav.userAgent;\n            let url: string | undefined;\n            if (typeof ua === \"string\") {\n              if (ua.indexOf(\"Chrome/\") > -1) {\n                url =\n                  \"https://chrome.google.com/webstore/detail/\" +\n                  \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n              } else if (ua.indexOf(\"Firefox/\") > -1) {\n                url =\n                  \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n              }\n            }\n            if (url) {\n              invariant.log(\n                \"Download the Apollo DevTools for a better development \" +\n                  \"experience: %s\",\n                url\n              );\n            }\n          }\n        }, 10000);\n      }\n    }\n  }\n\n  /**\n   * The `DocumentTransform` used to modify GraphQL documents before a request\n   * is made. If a custom `DocumentTransform` is not provided, this will be the\n   * default document transform.\n   */\n  get documentTransform() {\n    return this.queryManager.documentTransform;\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n   * receive updated results through an observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === \"network-only\" ||\n        options.fetchPolicy === \"cache-and-network\")\n    ) {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"client.watchQuery\");\n      warnRemovedOption(options, \"partialRefetch\", \"client.watchQuery\");\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type `QueryOptions` that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: QueryOptions<TVariables, T>\n  ): Promise<InteropApolloQueryResult<MaybeMasked<T>>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== \"cache-and-network\",\n      \"The cache-and-network fetchPolicy does not work with client.query, because \" +\n        \"client.query can only return a single result. Please use client.watchQuery \" +\n        \"to receive multiple results from the cache and the network, or consider \" +\n        \"using a different fetchPolicy, such as cache-first or network-only.\"\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"client.query\");\n      warnRemovedOption(\n        options,\n        \"notifyOnNetworkStatusChange\",\n        \"client.query\",\n        \"This option does not affect `client.query` and can be safely removed.\"\n      );\n\n      if (options.fetchPolicy === \"standby\") {\n        invariant.warn(\n          \"[client.query]: Apollo Client 4.0 will no longer support the `standby` fetch policy with `client.query`. Please use a different fetch policy.\"\n        );\n      }\n    }\n\n    return this.queryManager.query<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error. In some cases both `data` and `errors` might be undefined, for example\n   * when `errorPolicy` is set to `'ignore'`.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<\n    TData = any,\n    TVariables extends OperationVariables = OperationVariables,\n    TContext extends Record<string, any> = DefaultContext,\n    TCache extends ApolloCache<any> = ApolloCache<any>,\n  >(\n    options: MutationOptions<TData, TVariables, TContext>\n  ): Promise<InteropMutateResult<MaybeMasked<TData>>> {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate<TData, TVariables, TContext, TCache>(\n      options\n    );\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * `Observable` which either emits received data or an error.\n   */\n  public subscribe<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: SubscriptionOptions<TVariables, T>\n  ): Observable<InteropSubscribeResult<MaybeMasked<T>>> {\n    const id = this.queryManager.generateQueryId();\n\n    return this.queryManager\n      .startGraphQLSubscription<T>(options)\n      .map((result) => ({\n        ...result,\n        data: this.queryManager.maskOperation({\n          document: options.query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          id,\n        }),\n      }));\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables, T>,\n    optimistic: boolean = false\n  ): Unmasked<T> | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Watches the cache store of the fragment according to the options specified\n   * and returns an `Observable`. We can subscribe to this\n   * `Observable` and receive updated results through an\n   * observer when the cache store changes.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @since 3.10.0\n   * @param options - An object of type `WatchFragmentOptions` that allows\n   * the cache to identify the fragment and optionally specify whether to react\n   * to optimistic updates.\n   */\n\n  public watchFragment<\n    TFragmentData = unknown,\n    TVariables = OperationVariables,\n  >(\n    options: WatchFragmentOptions<TFragmentData, TVariables>\n  ): Observable<WatchFragmentResult<TFragmentData>> {\n    return this.cache.watchFragment({\n      ...options,\n      [Symbol.for(\"apollo.dataMasking\")]: this.queryManager.dataMasking,\n    });\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables, T>,\n    optimistic: boolean = false\n  ): Unmasked<T> | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeQuery<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeFragment<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(\n    payload: GraphQLRequest\n  ): Observable<FormattedExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<InteropApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: false,\n        })\n      )\n      .then(() => Promise.all(this.resetStoreCallbacks.map((fn) => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: true,\n        })\n      )\n      .then(() => Promise.all(this.clearStoreCallbacks.map((fn) => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean\n  ): Promise<InteropApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public refetchQueries<\n    TCache extends ApolloCache<any> = ApolloCache<TCacheShape>,\n    TResult = Promise<InteropApolloQueryResult<any>>,\n  >(\n    options: RefetchQueriesOptions<TCache, TResult>\n  ): RefetchQueriesResult<TResult> {\n    const map = this.queryManager.refetchQueries(\n      options as RefetchQueriesOptions<ApolloCache<TCacheShape>, TResult>\n    );\n    const queries: ObservableQuery<any>[] = [];\n    const results: InternalRefetchQueriesResult<TResult>[] = [];\n\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n\n    const result = Promise.all<TResult>(\n      results as TResult[]\n    ) as RefetchQueriesResult<TResult>;\n\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch((error) => {\n      invariant.debug(\n        `In client.refetchQueries, Promise.all promise rejected with error %o`,\n        error\n      );\n    });\n\n    return result;\n  }\n\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n  public getObservableQueries(\n    include: RefetchQueriesInclude = \"active\"\n  ): Map<string, ObservableQuery<any>> {\n    return this.queryManager.getObservableQueries(include);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   *\n   * @deprecated `addResolvers` will been removed in Apollo Client 4.0. It is\n   * safe to continue using this method in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * Use `client.localState.addResolvers(resolvers)`. Alternatively, store\n   * the `LocalState` instance in a separate variable and call `addResolvers` on\n   * that.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   *\n   * @deprecated `setResolvers` will been removed in Apollo Client 4.0. It is\n   * safe to continue using this method in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * If possible, stop using the `setResolvers` method.\n   *\n   * **When upgrading**\n   *\n   * Remove the use of `setResolvers`.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   *\n   * @deprecated `getResolvers` will be removed in Apollo Client 4.0. It is\n   * safe to continue using this method in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * If possible, stop using the `getResolvers` method.\n   *\n   * **When upgrading**\n   *\n   * Remove the use of `getResolvers`.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   *\n   * @deprecated Custom fragment matchers will no longer be supported in Apollo\n   * Client 4.0 and has been replaced by `cache.fragmentMatches`. It is safe to\n   * continue using `setLocalStateFragmentMatcher` in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * Leverage `possibleTypes` with `InMemoryCache` to ensure fragments match\n   * correctly. Ensure `possibleTypes` include local types if needed. If working\n   * with a 3rd party cache implementation, ensure the 3rd party cache implements\n   * the `cache.fragmentMatches` method. This function should no longer be used.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = this.queryManager.link = newLink;\n  }\n\n  public get defaultContext() {\n    return this.queryManager.defaultContext;\n  }\n\n  /**\n   * @experimental\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   * For more details, see [Memory Management](https://www.apollographql.com/docs/react/caching/memory-management/#measuring-cache-usage)\n   *\n   * @example\n   * ```ts\n   * console.log(client.getMemoryInternals())\n   * ```\n   * Logs output in the following JSON format:\n   * @example\n   * ```json\n   *{\n   *  limits:     {\n   *    parser: 1000,\n   *    canonicalStringify: 1000,\n   *    print: 2000,\n   *    'documentTransform.cache': 2000,\n   *    'queryManager.getDocumentInfo': 2000,\n   *    'PersistedQueryLink.persistedQueryHashes': 2000,\n   *    'fragmentRegistry.transform': 2000,\n   *    'fragmentRegistry.lookup': 1000,\n   *    'fragmentRegistry.findFragmentSpreads': 4000,\n   *    'cache.fragmentQueryDocuments': 1000,\n   *    'removeTypenameFromVariables.getVariableDefinitions': 2000,\n   *    'inMemoryCache.maybeBroadcastWatch': 5000,\n   *    'inMemoryCache.executeSelectionSet': 10000,\n   *    'inMemoryCache.executeSubSelectedArray': 5000\n   *  },\n   *  sizes: {\n   *    parser: 26,\n   *    canonicalStringify: 4,\n   *    print: 14,\n   *    addTypenameDocumentTransform: [\n   *      {\n   *        cache: 14,\n   *      },\n   *    ],\n   *    queryManager: {\n   *      getDocumentInfo: 14,\n   *      documentTransforms: [\n   *        {\n   *          cache: 14,\n   *        },\n   *        {\n   *          cache: 14,\n   *        },\n   *      ],\n   *    },\n   *    fragmentRegistry: {\n   *      findFragmentSpreads: 34,\n   *      lookup: 20,\n   *      transform: 14,\n   *    },\n   *    cache: {\n   *      fragmentQueryDocuments: 22,\n   *    },\n   *    inMemoryCache: {\n   *      executeSelectionSet: 4345,\n   *      executeSubSelectedArray: 1206,\n   *      maybeBroadcastWatch: 32,\n   *    },\n   *    links: [\n   *      {\n   *        PersistedQueryLink: {\n   *          persistedQueryHashes: 14,\n   *        },\n   *      },\n   *      {\n   *        removeTypenameFromVariables: {\n   *          getVariableDefinitions: 14,\n   *        },\n   *      },\n   *    ],\n   *  },\n   * }\n   *```\n   */\n  public getMemoryInternals?: typeof getApolloClientMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n","import type { Operation, GraphQLRequest, NextLink } from \"../core/index.js\";\nimport { ApolloLink } from \"../core/index.js\";\nimport type { ObservableSubscription } from \"../../utilities/index.js\";\nimport { Observable } from \"../../utilities/index.js\";\nimport type { DefaultContext } from \"../../core/index.js\";\n\nexport type ContextSetter = (\n  operation: GraphQLRequest,\n  prevContext: DefaultContext\n) => Promise<DefaultContext> | DefaultContext;\n\nexport function setContext(setter: ContextSetter): ApolloLink {\n  return new ApolloLink((operation: Operation, forward: NextLink) => {\n    const { ...request } = operation;\n\n    return new Observable((observer) => {\n      let handle: ObservableSubscription;\n      let closed = false;\n      Promise.resolve(request)\n        .then((req) => setter(req, operation.getContext()))\n        .then(operation.setContext)\n        .then(() => {\n          // if the observer is already closed, no need to subscribe.\n          if (closed) return;\n          handle = forward(operation).subscribe({\n            next: observer.next.bind(observer),\n            error: observer.error.bind(observer),\n            complete: observer.complete.bind(observer),\n          });\n        })\n        .catch(observer.error.bind(observer));\n\n      return () => {\n        closed = true;\n        if (handle) handle.unsubscribe();\n      };\n    });\n  });\n}\n","import type { GraphQLRequest, Operation } from \"../core/index.js\";\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest\n): Operation {\n  let context = { ...starting };\n  const setContext: Operation[\"setContext\"] = (next) => {\n    if (typeof next === \"function\") {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext: Operation[\"getContext\"] = () => ({ ...context });\n\n  Object.defineProperty(operation, \"setContext\", {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, \"getContext\", {\n    enumerable: false,\n    value: getContext,\n  });\n\n  return operation as Operation;\n}\n","import type { DocumentNode, FieldNode } from \"graphql\";\n\nimport type {\n  Reference,\n  StoreObject,\n  StoreValue,\n  isReference,\n  AsStoreObject,\n  DeepPartial,\n} from \"../../../utilities/index.js\";\n\nimport type { StorageType } from \"../../inmemory/policies.js\";\n\n// The Readonly<T> type only really works for object types, since it marks\n// all of the object's properties as readonly, but there are many cases when\n// a generic type parameter like TExisting might be a string or some other\n// primitive type, in which case we need to avoid wrapping it with Readonly.\n// SafeReadonly<string> collapses to just string, which makes string\n// assignable to SafeReadonly<any>, whereas string is not assignable to\n// Readonly<any>, somewhat surprisingly.\nexport type SafeReadonly<T> = T extends object ? Readonly<T> : T;\n\nexport type MissingTree =\n  | string\n  | {\n      readonly [key: string]: MissingTree;\n    };\n\nexport class MissingFieldError extends Error {\n  constructor(\n    public readonly message: string,\n    public readonly path: MissingTree | Array<string | number>,\n    public readonly query: DocumentNode,\n    public readonly variables?: Record<string, any>\n  ) {\n    // 'Error' breaks prototype chain here\n    super(message);\n\n    if (Array.isArray(this.path)) {\n      this.missing = this.message;\n      for (let i = this.path.length - 1; i >= 0; --i) {\n        this.missing = { [this.path[i]]: this.missing };\n      }\n    } else {\n      this.missing = this.path;\n    }\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully supported\n    // on Android (see issue #3236).\n    (this as any).__proto__ = MissingFieldError.prototype;\n  }\n\n  public readonly missing: MissingTree;\n}\n\nexport interface FieldSpecifier {\n  typename?: string;\n  fieldName: string;\n  field?: FieldNode;\n  args?: Record<string, any>;\n  variables?: Record<string, any>;\n}\n\nexport interface ReadFieldOptions extends FieldSpecifier {\n  from?: StoreObject | Reference;\n}\n\nexport interface ReadFieldFunction {\n  <V = StoreValue>(options: ReadFieldOptions): SafeReadonly<V> | undefined;\n  <V = StoreValue>(\n    fieldName: string,\n    from?: StoreObject | Reference\n  ): SafeReadonly<V> | undefined;\n}\n\nexport type ToReferenceFunction = (\n  objOrIdOrRef: StoreObject | string | Reference,\n  mergeIntoStore?: boolean\n) => Reference | undefined;\n\nexport type CanReadFunction = (value: StoreValue) => boolean;\n\ndeclare const _deleteModifier: unique symbol;\nexport interface DeleteModifier {\n  [_deleteModifier]: true;\n}\ndeclare const _invalidateModifier: unique symbol;\nexport interface InvalidateModifier {\n  [_invalidateModifier]: true;\n}\ndeclare const _ignoreModifier: unique symbol;\nexport interface IgnoreModifier {\n  [_ignoreModifier]: true;\n}\n\nexport type ModifierDetails = {\n  DELETE: DeleteModifier;\n  INVALIDATE: InvalidateModifier;\n  fieldName: string;\n  storeFieldName: string;\n  readField: ReadFieldFunction;\n  canRead: CanReadFunction;\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n  storage: StorageType;\n};\n\nexport type Modifier<T> = (\n  value: T,\n  details: ModifierDetails\n) => DeepPartial<T> | DeleteModifier | InvalidateModifier | undefined;\n\ntype StoreObjectValueMaybeReference<StoreVal> =\n  StoreVal extends Array<Record<string, any>> ?\n    StoreVal extends Array<infer Item> ?\n      [Item] extends [Record<string, any>] ?\n        ReadonlyArray<AsStoreObject<Item> | Reference>\n      : never\n    : never\n  : StoreVal extends Record<string, any> ? AsStoreObject<StoreVal> | Reference\n  : StoreVal;\n\nexport type AllFieldsModifier<Entity extends Record<string, any>> = Modifier<\n  Entity[keyof Entity] extends infer Value ?\n    StoreObjectValueMaybeReference<Exclude<Value, undefined>>\n  : never\n>;\n\nexport type Modifiers<T extends Record<string, any> = Record<string, unknown>> =\n  Partial<{\n    [FieldName in keyof T]: Modifier<\n      StoreObjectValueMaybeReference<Exclude<T[FieldName], undefined>>\n    >;\n  }>;\n","/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/async.ts\n */\n\nexport default function asyncIterator<T>(\n  source: AsyncIterableIterator<T>\n): AsyncIterableIterator<T> {\n  const iterator = source[Symbol.asyncIterator]();\n  return {\n    next(): Promise<IteratorResult<T, boolean>> {\n      return iterator.next();\n    },\n    [Symbol.asyncIterator](): AsyncIterableIterator<T> {\n      return this;\n    },\n  };\n}\n","/**\n * Prints a string as a GraphQL StringValue literal. Replaces control characters\n * and excluded characters (\" U+0022 and \\\\ U+005C) with escape sequences.\n */\nexport function printString(str) {\n  return `\"${str.replace(escapedRegExp, escapedReplacer)}\"`;\n} // eslint-disable-next-line no-control-regex\n\nconst escapedRegExp = /[\\x00-\\x1f\\x22\\x5c\\x7f-\\x9f]/g;\n\nfunction escapedReplacer(str) {\n  return escapeSequences[str.charCodeAt(0)];\n} // prettier-ignore\n\nconst escapeSequences = [\n  '\\\\u0000',\n  '\\\\u0001',\n  '\\\\u0002',\n  '\\\\u0003',\n  '\\\\u0004',\n  '\\\\u0005',\n  '\\\\u0006',\n  '\\\\u0007',\n  '\\\\b',\n  '\\\\t',\n  '\\\\n',\n  '\\\\u000B',\n  '\\\\f',\n  '\\\\r',\n  '\\\\u000E',\n  '\\\\u000F',\n  '\\\\u0010',\n  '\\\\u0011',\n  '\\\\u0012',\n  '\\\\u0013',\n  '\\\\u0014',\n  '\\\\u0015',\n  '\\\\u0016',\n  '\\\\u0017',\n  '\\\\u0018',\n  '\\\\u0019',\n  '\\\\u001A',\n  '\\\\u001B',\n  '\\\\u001C',\n  '\\\\u001D',\n  '\\\\u001E',\n  '\\\\u001F',\n  '',\n  '',\n  '\\\\\"',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '', // 2F\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '', // 3F\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '', // 4F\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '\\\\\\\\',\n  '',\n  '',\n  '', // 5F\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '', // 6F\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '\\\\u007F',\n  '\\\\u0080',\n  '\\\\u0081',\n  '\\\\u0082',\n  '\\\\u0083',\n  '\\\\u0084',\n  '\\\\u0085',\n  '\\\\u0086',\n  '\\\\u0087',\n  '\\\\u0088',\n  '\\\\u0089',\n  '\\\\u008A',\n  '\\\\u008B',\n  '\\\\u008C',\n  '\\\\u008D',\n  '\\\\u008E',\n  '\\\\u008F',\n  '\\\\u0090',\n  '\\\\u0091',\n  '\\\\u0092',\n  '\\\\u0093',\n  '\\\\u0094',\n  '\\\\u0095',\n  '\\\\u0096',\n  '\\\\u0097',\n  '\\\\u0098',\n  '\\\\u0099',\n  '\\\\u009A',\n  '\\\\u009B',\n  '\\\\u009C',\n  '\\\\u009D',\n  '\\\\u009E',\n  '\\\\u009F',\n];\n","/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/index.ts\n */\n\nimport type { Response as NodeResponse } from \"node-fetch\";\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../utilities/index.js\";\n\nimport asyncIterator from \"./iterators/async.js\";\nimport nodeStreamIterator from \"./iterators/nodeStream.js\";\nimport promiseIterator from \"./iterators/promise.js\";\nimport readerIterator from \"./iterators/reader.js\";\n\nfunction isNodeResponse(value: any): value is NodeResponse {\n  return !!(value as NodeResponse).body;\n}\n\nfunction isReadableStream(value: any): value is ReadableStream<any> {\n  return !!(value as ReadableStream<any>).getReader;\n}\n\nfunction isAsyncIterableIterator(\n  value: any\n): value is AsyncIterableIterator<any> {\n  return !!(\n    canUseAsyncIteratorSymbol &&\n    (value as AsyncIterableIterator<any>)[Symbol.asyncIterator]\n  );\n}\n\nfunction isStreamableBlob(value: any): value is Blob {\n  return !!(value as Blob).stream;\n}\n\nfunction isBlob(value: any): value is Blob {\n  return !!(value as Blob).arrayBuffer;\n}\n\nfunction isNodeReadableStream(value: any): value is NodeReadableStream {\n  return !!(value as NodeReadableStream).pipe;\n}\n\nexport function responseIterator<T>(\n  response: Response | NodeResponse\n): AsyncIterableIterator<T> {\n  let body: unknown = response;\n\n  if (isNodeResponse(response)) body = response.body;\n\n  if (isAsyncIterableIterator(body)) return asyncIterator<T>(body);\n\n  if (isReadableStream(body)) return readerIterator<T>(body.getReader());\n\n  // this errors without casting to ReadableStream<T>\n  // because Blob.stream() returns a NodeJS ReadableStream\n  if (isStreamableBlob(body)) {\n    return readerIterator<T>(\n      (body.stream() as unknown as ReadableStream<T>).getReader()\n    );\n  }\n\n  if (isBlob(body)) return promiseIterator<T>(body.arrayBuffer());\n\n  if (isNodeReadableStream(body)) return nodeStreamIterator<T>(body);\n\n  throw new Error(\n    \"Unknown body type for responseIterator. Please pass a streamable response.\"\n  );\n}\n","/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/reader.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface ReaderIterator<T> {\n  next(): Promise<IteratorResult<T, T | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function readerIterator<T>(\n  reader: ReadableStreamDefaultReader<T>\n): AsyncIterableIterator<T> {\n  const iterator: ReaderIterator<T> = {\n    next() {\n      return reader.read() as Promise<\n        | ReadableStreamReadValueResult<T>\n        // DoneResult has `value` optional, which doesn't comply with an\n        // `IteratorResult`, so we assert it to `T | undefined` instead\n        | Required<ReadableStreamReadDoneResult<T | undefined>>\n      >;\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<\n      T,\n      T | undefined\n    > {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n","/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */\n\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface NodeStreamIterator<T> {\n  next(): Promise<IteratorResult<T, boolean | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function nodeStreamIterator<T>(\n  stream: NodeReadableStream\n): AsyncIterableIterator<T> {\n  let cleanup: (() => void) | null = null;\n  let error: Error | null = null;\n  let done = false;\n  const data: unknown[] = [];\n\n  const waiting: [\n    (\n      value:\n        | IteratorResult<T, boolean | undefined>\n        | PromiseLike<IteratorResult<T, boolean | undefined>>\n    ) => void,\n    (reason?: any) => void,\n  ][] = [];\n\n  function onData(chunk: any) {\n    if (error) return;\n    if (waiting.length) {\n      const shiftedArr = waiting.shift();\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({ value: chunk, done: false });\n      }\n    }\n    data.push(chunk);\n  }\n  function onError(err: Error) {\n    error = err;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({ value: undefined, done: true });\n    });\n    !cleanup || cleanup();\n  }\n\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n\n  function getNext(): Promise<IteratorResult<T, boolean | undefined>> {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length)\n        return resolve({ value: data.shift() as T, done: false });\n      if (done) return resolve({ value: undefined, done: true });\n      waiting.push([resolve, reject]);\n    });\n  }\n\n  const iterator: NodeStreamIterator<T> = {\n    next(): Promise<IteratorResult<T, boolean | undefined>> {\n      return getNext();\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n","/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/promise.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface PromiseIterator<T> {\n  next(): Promise<IteratorResult<T, ArrayBuffer | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function promiseIterator<T = ArrayBuffer>(\n  promise: Promise<ArrayBuffer>\n): AsyncIterableIterator<T> {\n  let resolved = false;\n\n  const iterator: PromiseIterator<T> = {\n    next(): Promise<IteratorResult<T, ArrayBuffer | undefined>> {\n      if (resolved)\n        return Promise.resolve({\n          value: undefined,\n          done: true,\n        });\n      resolved = true;\n      return new Promise(function (resolve, reject) {\n        promise\n          .then(function (value) {\n            resolve({ value: value as unknown as T, done: false });\n          })\n          .catch(reject);\n      });\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n","import {\n  ApolloClient,\n  InMemoryCache,\n  createHttpLink,\n  from,\n  split,\n} from '@apollo/client';\nimport { setContext } from '@apollo/client/link/context';\nimport { onError } from '@apollo/client/link/error';\nimport { getMainDefinition } from '@apollo/client/utilities';\nimport { GraphQLWsLink } from '@apollo/client/link/subscriptions';\nimport { createClient } from 'graphql-ws';\n\n// Utility function to safely stringify objects for logging\nconst safeStringify = (obj: any, maxDepth = 3): string => {\n  try {\n    const seen = new WeakSet();\n    return JSON.stringify(obj, (key, value) => {\n      if (typeof value === 'object' && value !== null) {\n        if (seen.has(value)) {\n          return '[Circular Reference]';\n        }\n        seen.add(value);\n      }\n      return value;\n    }, 2);\n  } catch (error) {\n    return `[Unable to stringify: ${error}]`;\n  }\n};\n\n// Check if we're in development mode for detailed logging\nconst isDevelopment = process.env.NODE_ENV === 'development';\n\n// Enhanced logging function\nconst logError = (level: 'error' | 'warn' | 'info', message: string, data?: any) => {\n  const timestamp = new Date().toISOString();\n  const prefix = `[${timestamp}] Apollo Client`;\n  \n  if (level === 'error') {\n    console.error(`${prefix} `, message, data ? safeStringify(data) : '');\n  } else if (level === 'warn') {\n    console.warn(`${prefix} `, message, data ? safeStringify(data) : '');\n  } else {\n    console.info(`${prefix} `, message, data ? safeStringify(data) : '');\n  }\n};\n\n// Error context collector for debugging\nconst collectErrorContext = () => {\n  if (typeof window === 'undefined') return {};\n  \n  return {\n    userAgent: navigator.userAgent,\n    url: window.location.href,\n    timestamp: new Date().toISOString(),\n    connection: (navigator as any).connection ? {\n      effectiveType: (navigator as any).connection.effectiveType,\n      downlink: (navigator as any).connection.downlink,\n      rtt: (navigator as any).connection.rtt\n    } : null,\n    online: navigator.onLine,\n    cookieEnabled: navigator.cookieEnabled,\n    language: navigator.language,\n    platform: navigator.platform\n  };\n};\n\n// HTTP Link\nconst getGraphQLUri = () => {\n  let endpoint = process.env.NEXT_PUBLIC_GRAPHQL_ENDPOINT || 'http://localhost:14000/graphql';\n  \n  // In browser environment, if page is loaded via HTTPS but endpoint is HTTP, fix it\n  if (typeof window !== 'undefined') {\n    // If current page is HTTPS but endpoint is HTTP, upgrade to HTTPS\n    if (window.location.protocol === 'https:' && endpoint.startsWith('http://')) {\n      // Replace http:// with https://\n      endpoint = endpoint.replace('http://', 'https://');\n      console.info(`[Apollo] Upgraded GraphQL endpoint to HTTPS: ${endpoint}`);\n    }\n    // If current page is HTTP and endpoint is HTTPS, downgrade to HTTP\n    else if (window.location.protocol === 'http:' && endpoint.startsWith('https://')) {\n      endpoint = endpoint.replace('https://', 'http://');\n      console.info(`[Apollo] Downgraded GraphQL endpoint to HTTP: ${endpoint}`);\n    }\n  }\n  \n  return endpoint;\n};\n\nconst httpLink = createHttpLink({\n  uri: getGraphQLUri(),\n});\n\n// WebSocket Link for subscriptions - completely disabled in development\nconst wsLink = null; // Temporarily disabled due to connection issues\n\n// Auth Link - adds authorization header with token caching and debugging\nlet cachedToken: string | null = null;\nconst authLink = setContext((_, { headers }) => {\n  let token: string | null = null;\n  \n  if (typeof window !== 'undefined') {\n    // First check localStorage\n    const storedToken = localStorage.getItem('accessToken');\n    if (storedToken) {\n      token = storedToken;\n      cachedToken = storedToken;\n    }\n    // Fall back to cached token (for cases where localStorage isn't synced)\n    else if (cachedToken) {\n      token = cachedToken;\n    }\n  }\n  \n  if (process.env.NODE_ENV === 'development' && !token) {\n    console.warn('[AuthLink] No token found in localStorage or cache');\n  }\n  \n  return {\n    headers: {\n      ...headers,\n      ...(token && { authorization: `Bearer ${token}` }),\n    },\n  };\n});\n\n// Error Link - handles GraphQL and network errors\n// IMPORTANT: This link should NOT redirect users or clear tokens!\n// The AuthContext is responsible for managing auth state.\n// Apollo should only log errors and let the application handle the response.\nconst errorLink = onError(({ graphQLErrors, networkError, operation, forward }) => {\n  if (graphQLErrors && graphQLErrors.length > 0) {\n    console.group('%c GraphQL Errors Detected', 'color: #e74c3c; font-weight: bold;');\n    console.log(`Operation: ${operation.operationName}`);\n    console.table(graphQLErrors.map((err, idx) => ({\n      '#': idx + 1,\n      'Message': err.message,\n      'Code': err.extensions?.code || 'N/A',\n      'Path': err.path?.join('.') || 'N/A',\n    })));\n    const errorDetails = graphQLErrors.map(({ message, locations, path, extensions }) => {\n      const errorInfo = {\n        message,\n        path,\n        locations,\n        extensions,\n        operation: operation.operationName,\n        variables: operation.variables,\n        timestamp: new Date().toISOString()\n      };\n\n      // Handle specific GraphQL errors with logging only\n      if (message === 'Bad Request Exception') {\n        logError('warn', ' Bad request - check query syntax and variables', { message, path });\n      }\n      \n      // Log authentication errors but don't redirect here\n      // AuthContext will handle token removal based on error type (only UNAUTHENTICATED code)\n      if (extensions?.code === 'UNAUTHENTICATED') {\n        console.log('%c UNAUTHENTICATED error - delegating to AuthContext', 'color: #f39c12;');\n        logError('warn', ' UNAUTHENTICATED error - AuthContext will handle logout', { message, path });\n        // Don't redirect or clear tokens here - let AuthContext handle it\n        return errorInfo;\n      }\n      \n      if (message === 'Forbidden resource' || (extensions?.code === 'FORBIDDEN')) {\n        console.log('%c Forbidden error - delegating to AuthContext', 'color: #f39c12;');\n        logError('warn', ' Forbidden error - let AuthContext decide if logout is needed', { message, path });\n        // Let AuthContext handle this, don't auto-logout from Apollo\n      }\n      \n      // Handle validation errors\n      if (message.includes('validation') || message.includes('invalid')) {\n        logError('warn', ' Validation error - check input data', { message, path });\n      }\n\n      // Handle resource not found errors\n      if (message.includes('not found')) {\n        logError('warn', ' Resource not found - check if resource exists', { \n          message, \n          path,\n          operation: operation.operationName,\n          variables: operation.variables\n        });\n      }\n\n      return errorInfo;\n    });\n\n    // Log based on environment\n    if (isDevelopment) {\n      // Detailed logging in development\n      console.log('%c Full error details:', 'color: #3498db;', errorDetails);\n    } else {\n      // Production logging - summarized\n      const errorSummary = graphQLErrors.map((err: any) => ({\n        message: err.message,\n        code: err.extensions?.code,\n        path: err.path\n      }));\n      logError('warn', 'GraphQL errors occurred', { \n        errors: errorSummary,\n        context: collectErrorContext()\n      });\n    }\n    console.groupEnd();\n  }\n\n  if (networkError) {\n    // Create detailed error information\n    const errorInfo = {\n      type: networkError.name || 'NetworkError',\n      message: networkError.message,\n      operation: operation.operationName,\n      variables: operation.variables,\n      timestamp: new Date().toISOString()\n    };\n\n    // Add additional properties if available\n    if ('statusCode' in networkError) {\n      (errorInfo as any).statusCode = networkError.statusCode;\n    }\n    if ('result' in networkError && networkError.result) {\n      (errorInfo as any).result = networkError.result;\n    }\n    if ('response' in networkError && networkError.response) {\n      (errorInfo as any).response = networkError.response;\n    }\n    if ('request' in networkError && networkError.request) {\n      const request = networkError.request as any;\n      (errorInfo as any).requestUrl = request?.url || 'N/A';\n      (errorInfo as any).requestMethod = request?.method || 'N/A';\n    }\n\n    // Log based on environment\n    if (isDevelopment) {\n      console.group(' [Network Error Details]');\n      console.error('Error Info:', errorInfo);\n      console.error('Context:', collectErrorContext());\n      console.log(` Error Type: ${errorInfo.type}`);\n      console.log(` Operation: ${errorInfo.operation}`);\n      console.groupEnd();\n    } else {\n      // Production logging - less verbose but include context\n      logError('error', 'Network error occurred', {\n        ...errorInfo,\n        context: collectErrorContext()\n      });\n    }\n    \n    // Handle WebSocket errors gracefully\n    if (networkError.message?.includes('Socket closed') || \n        networkError.message?.includes('WebSocket')) {\n      console.warn(' WebSocket connection lost - will attempt to reconnect');\n      // Don't redirect on WebSocket errors\n      return;\n    }\n    \n    // IMPORTANT: Only redirect for explicit 401 errors\n    // Transient network errors should not cause logout\n    // That way, if there's a temporary network hiccup during page reload,\n    // the user won't get logged out\n    if ('statusCode' in networkError && networkError.statusCode === 401) {\n      console.log('%c HTTP 401 Unauthorized - LOGGING OUT', 'color: #c0392b; font-weight: bold;');\n      logError('warn', ' Unauthorized access (401) - redirecting to login');\n      if (typeof window !== 'undefined') {\n        // Clear ALL auth-related data at once\n        console.log('%c Clearing auth data from Apollo error link', 'color: #c0392b;');\n        localStorage.removeItem('accessToken');\n        localStorage.removeItem('refreshToken');\n        localStorage.removeItem('user');\n        console.log('%c Redirecting to /login', 'color: #c0392b;');\n        window.location.href = '/login';\n      }\n    }\n    \n    // Handle other common network errors with logging only\n    if ('statusCode' in networkError) {\n      const statusCode = networkError.statusCode;\n      switch (statusCode) {\n        case 403:\n          console.log(`%c Forbidden (403) - insufficient permissions`, 'color: #e67e22;');\n          logError('warn', ' Forbidden (403) - insufficient permissions');\n          break;\n        case 404:\n          console.log(`%c Not Found (404) - resource not found`, 'color: #e67e22;');\n          logError('warn', ' Not Found (404) - resource not found');\n          break;\n        case 500:\n          console.log(`%c Internal Server Error (500)`, 'color: #e74c3c;');\n          logError('error', ' Internal Server Error (500)');\n          break;\n        case 502:\n          console.log(`%c Bad Gateway (502) - server might be down`, 'color: #e74c3c;');\n          logError('error', ' Bad Gateway (502) - server might be down');\n          break;\n        case 503:\n          console.log(`%c Service Unavailable (503) - please try again later`, 'color: #e74c3c;');\n          logError('error', ' Service Unavailable (503) - please try again later');\n          break;\n        default:\n          // For other status codes, just log - don't auto-logout\n          console.log(`%c HTTP Error ${statusCode}`, 'color: #e67e22;');\n          logError('warn', ` HTTP Error ${statusCode}`);\n      }\n    }\n  }\n});\n\n// Split based on operation type - only if WebSocket is available\nconst splitLink = wsLink \n  ? split(\n      ({ query }) => {\n        const definition = getMainDefinition(query);\n        return (\n          definition.kind === 'OperationDefinition' &&\n          definition.operation === 'subscription'\n        );\n      },\n      wsLink,\n      authLink.concat(httpLink)\n    )\n  : authLink.concat(httpLink); // Fallback to HTTP only\n\n// Create Apollo Client\nexport const apolloClient = new ApolloClient({\n  link: from([errorLink, splitLink]),\n  cache: new InMemoryCache({\n    typePolicies: {\n      Query: {\n        fields: {\n          getPosts: {\n            keyArgs: ['filters'],\n            merge(existing, incoming, { args }) {\n              if (args?.pagination?.page === 1) {\n                // First page - replace existing\n                return incoming;\n              }\n              // Subsequent pages - merge items\n              return {\n                ...incoming,\n                items: [...(existing?.items || []), ...(incoming?.items || [])],\n              };\n            },\n          },\n          posts: {\n            merge(existing, incoming, { args }) {\n              // Simple replacement strategy\n              return incoming;\n            },\n          },\n          getPostById: {\n            merge(existing, incoming) {\n              return incoming;\n            },\n          },\n          tasks: {\n            merge(existing = [], incoming) {\n              return incoming;\n            },\n          },\n          getTask: {\n            merge(existing, incoming) {\n              return incoming;\n            },\n          },\n        },\n      },\n    },\n  }),\n  defaultOptions: {\n    watchQuery: {\n      errorPolicy: 'all',\n    },\n    query: {\n      errorPolicy: 'all',\n    },\n  },\n});\n\nexport default apolloClient;\n","export type ServerError = Error & {\n  response: Response;\n  /**\n   * @deprecated `result` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When migrating**\n   *\n   * `result` has been replaced by `bodyText` which is the raw string body\n   * returned in the result. Use `JSON.parse` on the `bodyText` property to get\n   * the same value as `result`.\n   */\n  result: Record<string, any> | string;\n  statusCode: number;\n};\n\n/**\n * @deprecated `throwServerError` will be removed in Apollo Client 4.0. This is\n * safe to use in Apollo Client 3.x.\n *\n * **Recommended now**\n *\n * No action needed\n *\n * **When migrating**\n *\n * `ServerError` is a subclass of `Error`. To throw a server error, use\n * `throw new ServerError(...)` instead.\n *\n * ```ts\n * throw new ServerError(\"error message\", { response, result });\n * ```\n */\nexport const throwServerError = (\n  response: Response,\n  result: any,\n  message: string\n) => {\n  const error = new Error(message) as ServerError;\n  error.name = \"ServerError\";\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n  throw error;\n};\n","'use client';\n\nimport { useQuery, gql } from '@apollo/client';\nimport SupportChatWidget from './SupportChatWidget';\n\nconst GET_SUPPORT_CHAT_SETTINGS = gql`\n  query GetSupportChatSettings {\n    websiteSettings(\n      category: \"SUPPORT_CHAT\"\n      isActive: true\n    ) {\n      key\n      value\n      type\n    }\n  }\n`;\n\ninterface SupportChatSettings {\n  enabled: boolean;\n  position: 'bottom-right' | 'bottom-left' | 'top-right' | 'top-left';\n  primaryColor: string;\n  welcomeMessage: string;\n  offlineMessage: string;\n  aiEnabled: boolean;\n  showAgentTyping: boolean;\n  enableFileUpload: boolean;\n  enableEmojis: boolean;\n  soundNotification: boolean;\n  desktopNotification: boolean;\n}\n\nexport default function SupportChatWidgetWrapper() {\n  const { data, loading } = useQuery(GET_SUPPORT_CHAT_SETTINGS);\n\n  if (loading) return null;\n\n  const settings = data?.websiteSettings || [];\n  \n  // Parse settings into object\n  const config: Partial<SupportChatSettings> = {};\n  settings.forEach((setting: any) => {\n    const key = setting.key.replace('support_chat.', '');\n    let value = setting.value;\n\n    // Parse based on type\n    if (setting.type === 'BOOLEAN') {\n      value = value === 'true';\n    } else if (setting.type === 'NUMBER') {\n      value = parseFloat(value);\n    } else if (setting.type === 'JSON') {\n      try {\n        value = JSON.parse(value);\n      } catch (e) {\n        console.error('Failed to parse JSON setting:', key, value);\n      }\n    }\n\n    config[key as keyof SupportChatSettings] = value;\n  });\n\n  // Nu disabled, khng render widget\n  if (config.enabled === false) {\n    return null;\n  }\n\n  // Get API URLs from env\n  const apiUrl = process.env.NEXT_PUBLIC_GRAPHQL_ENDPOINT?.replace('/graphql', '') || \n                 \"http://116.118.49.243:12001\";\n  const websocketUrl = process.env.NEXT_PUBLIC_GRAPHQL_ENDPOINT?.replace('/graphql', '/support-chat') || \n                       \"http://116.118.49.243:12001/support-chat\";\n\n  return (\n    <SupportChatWidget\n      apiUrl={apiUrl}\n      websocketUrl={websocketUrl}\n      primaryColor={config.primaryColor || '#16a34a'}\n      position={(config.position as 'bottom-right' | 'bottom-left') || 'bottom-right'}\n    />\n  );\n}\n","'use client';\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { io, Socket } from 'socket.io-client';\nimport { useMutation } from '@apollo/client';\nimport { CREATE_SUPPORT_CONVERSATION, SEND_SUPPORT_MESSAGE } from '@/graphql/support-chat/support-chat.graphql';\nimport {\n  MessageCircle,\n  X,\n  Send,\n  Paperclip,\n  Smile,\n  Phone,\n  Video,\n  MoreVertical,\n  ChevronDown,\n  CheckCheck,\n  Bot,\n  User,\n} from 'lucide-react';\n\ninterface Message {\n  id: string;\n  content: string;\n  senderType: 'CUSTOMER' | 'AGENT' | 'BOT';\n  senderName?: string;\n  sentAt: string;\n  isRead: boolean;\n  isAIGenerated?: boolean;\n}\n\ninterface SupportChatWidgetProps {\n  apiUrl?: string;\n  websocketUrl?: string;\n  primaryColor?: string;\n  position?: 'bottom-right' | 'bottom-left';\n}\n\nexport default function SupportChatWidget({\n  apiUrl = 'http://localhost:3001',\n  websocketUrl = 'http://localhost:3001/support-chat',\n  primaryColor = '#2563eb',\n  position = 'bottom-right',\n}: SupportChatWidgetProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [isMinimized, setIsMinimized] = useState(false);\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [inputMessage, setInputMessage] = useState('');\n  const [isTyping, setIsTyping] = useState(false);\n  const [conversationId, setConversationId] = useState<string | null>(null);\n  const [socket, setSocket] = useState<Socket | null>(null);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [customerName, setCustomerName] = useState('');\n  const [showNameInput, setShowNameInput] = useState(true);\n  const [agentInfo, setAgentInfo] = useState<any>(null);\n  \n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  // Apollo mutations\n  const [createConversationMutation] = useMutation(CREATE_SUPPORT_CONVERSATION);\n  const [sendMessageMutation] = useMutation(SEND_SUPPORT_MESSAGE);\n\n  // Initialize Socket.IO connection\n  useEffect(() => {\n    if (isOpen && !socket) {\n      const newSocket = io(websocketUrl, {\n        transports: ['websocket'],\n      });\n\n      newSocket.on('connect', () => {\n        console.log('Connected to support chat');\n      });\n\n      newSocket.on('new_message', (message: Message) => {\n        setMessages(prev => [...prev, message]);\n        if (message.senderType !== 'CUSTOMER') {\n          setUnreadCount(prev => prev + 1);\n        }\n        scrollToBottom();\n      });\n\n      newSocket.on('ai_suggestion', (data: any) => {\n        console.log('AI Suggestion:', data);\n      });\n\n      newSocket.on('user_typing', () => {\n        setIsTyping(true);\n      });\n\n      newSocket.on('user_stopped_typing', () => {\n        setIsTyping(false);\n      });\n\n      newSocket.on('agent_assigned', (data: any) => {\n        setAgentInfo(data.agent);\n      });\n\n      setSocket(newSocket);\n\n      return () => {\n        newSocket.disconnect();\n      };\n    }\n  }, [isOpen, websocketUrl]);\n\n  // Auto-scroll to bottom\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  };\n\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n\n  // Start conversation\n  const startConversation = async () => {\n    if (!customerName.trim()) return;\n\n    try {\n      const { data } = await createConversationMutation({\n        variables: {\n          input: {\n            customerName,\n            platform: 'WEBSITE',\n          },\n        },\n      });\n\n      if (!data?.createSupportConversation) {\n        throw new Error('Failed to create conversation');\n      }\n      \n      const conversation = data.createSupportConversation;\n      \n      setConversationId(conversation.id);\n      setShowNameInput(false);\n\n      // Join conversation via WebSocket\n      if (socket) {\n        socket.emit('join_conversation', {\n          conversationId: conversation.id,\n        });\n      }\n\n      // Send welcome message\n      setMessages([\n        {\n          id: '1',\n          content: `Xin cho ${customerName}! Ti c th gip g cho bn?`,\n          senderType: 'BOT',\n          senderName: 'Tr l o',\n          sentAt: new Date().toISOString(),\n          isRead: true,\n          isAIGenerated: true,\n        },\n      ]);\n    } catch (error) {\n      console.error('Error starting conversation:', error);\n    }\n  };\n\n  // Send message\n  const sendMessage = async () => {\n    if (!inputMessage.trim() || !conversationId) return;\n\n    const messageContent = inputMessage;\n    setInputMessage(''); // Clear input immediately\n\n    try {\n      // Send via GraphQL mutation to save in DB\n      const { data } = await sendMessageMutation({\n        variables: {\n          input: {\n            conversationId,\n            content: messageContent,\n            senderType: 'CUSTOMER',\n            senderName: customerName,\n          },\n        },\n      });\n\n      // Also send via WebSocket for real-time\n      if (socket && data?.sendSupportMessage) {\n        socket.emit('send_message', {\n          conversationId,\n          messageId: data.sendSupportMessage.id,\n          content: messageContent,\n          senderType: 'CUSTOMER',\n          senderName: customerName,\n        });\n      }\n\n      // Add to local messages (optimistic update)\n      setMessages(prev => [...prev, {\n        id: data?.sendSupportMessage?.id || Date.now().toString(),\n        content: messageContent,\n        senderType: 'CUSTOMER',\n        senderName: customerName,\n        sentAt: new Date().toISOString(),\n        isRead: false,\n      }]);\n    } catch (error) {\n      console.error('Error sending message:', error);\n      setInputMessage(messageContent); // Restore message on error\n    }\n  };\n\n  // Handle typing indicator\n  const handleTyping = () => {\n    if (socket && conversationId) {\n      socket.emit('typing_start', {\n        conversationId,\n        userId: 'customer',\n      });\n\n      setTimeout(() => {\n        socket.emit('typing_stop', {\n          conversationId,\n          userId: 'customer',\n        });\n      }, 3000);\n    }\n  };\n\n  const positionClasses = position === 'bottom-right' \n    ? 'right-4 md:right-6' \n    : 'left-4 md:left-6';\n\n  return (\n    <>\n      {/* Chat Button */}\n      <AnimatePresence>\n        {!isOpen && (\n          <motion.button\n            initial={{ scale: 0, opacity: 0 }}\n            animate={{ scale: 1, opacity: 1 }}\n            exit={{ scale: 0, opacity: 0 }}\n            whileHover={{ scale: 1.1 }}\n            whileTap={{ scale: 0.9 }}\n            onClick={() => setIsOpen(true)}\n            className={`fixed bottom-4 md:bottom-6 ${positionClasses} z-50 w-14 h-14 md:w-16 md:h-16 rounded-full shadow-2xl flex items-center justify-center focus:outline-none focus:ring-4 focus:ring-opacity-50`}\n            style={{\n              backgroundColor: primaryColor,\n              boxShadow: `0 10px 40px rgba(0, 0, 0, 0.2), 0 0 0 4px ${primaryColor}20`,\n            }}\n          >\n            <MessageCircle className=\"w-6 h-6 md:w-8 md:h-8 text-white\" />\n            {unreadCount > 0 && (\n              <motion.div\n                initial={{ scale: 0 }}\n                animate={{ scale: 1 }}\n                className=\"absolute -top-1 -right-1 bg-red-500 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center\"\n              >\n                {unreadCount > 9 ? '9+' : unreadCount}\n              </motion.div>\n            )}\n          </motion.button>\n        )}\n      </AnimatePresence>\n\n      {/* Chat Window */}\n      <AnimatePresence>\n        {isOpen && (\n          <motion.div\n            initial={{ opacity: 0, y: 20, scale: 0.95 }}\n            animate={{ \n              opacity: 1, \n              y: 0, \n              scale: 1,\n              height: isMinimized ? 'auto' : undefined,\n            }}\n            exit={{ opacity: 0, y: 20, scale: 0.95 }}\n            transition={{ type: 'spring', damping: 25, stiffness: 300 }}\n            className={`fixed bottom-4 md:bottom-6 ${positionClasses} z-50 w-[calc(100vw-2rem)] md:w-96 bg-white rounded-2xl shadow-2xl overflow-hidden flex flex-col`}\n            style={{\n              maxHeight: isMinimized ? '60px' : 'calc(100vh - 8rem)',\n              height: isMinimized ? 'auto' : '600px',\n            }}\n          >\n            {/* Header */}\n            <div\n              className=\"p-4 flex items-center justify-between text-white relative overflow-hidden\"\n              style={{ backgroundColor: primaryColor }}\n            >\n              {/* Animated background */}\n              <div className=\"absolute inset-0 opacity-10\">\n                <div className=\"absolute w-32 h-32 bg-white rounded-full -top-10 -left-10 animate-pulse\" />\n                <div className=\"absolute w-24 h-24 bg-white rounded-full -bottom-5 -right-5 animate-pulse delay-300\" />\n              </div>\n\n              <div className=\"flex items-center space-x-3 relative z-10\">\n                <div className=\"relative\">\n                  <div className=\"w-10 h-10 rounded-full bg-white/20 flex items-center justify-center\">\n                    {agentInfo?.avatar ? (\n                      <img \n                        src={agentInfo.avatar} \n                        alt={agentInfo.name}\n                        className=\"w-full h-full rounded-full object-cover\"\n                      />\n                    ) : (\n                      <Bot className=\"w-6 h-6\" />\n                    )}\n                  </div>\n                  <div className=\"absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-green-400 rounded-full border-2 border-white\" />\n                </div>\n                <div>\n                  <h3 className=\"font-semibold text-sm\">\n                    {agentInfo ? agentInfo.name : 'H tr khch hng'}\n                  </h3>\n                  <p className=\"text-xs opacity-90\">\n                    {isTyping ? 'ang nhp...' : 'Trc tuyn'}\n                  </p>\n                </div>\n              </div>\n\n              <div className=\"flex items-center space-x-2 relative z-10\">\n                <button\n                  onClick={() => setIsMinimized(!isMinimized)}\n                  className=\"p-1.5 hover:bg-white/20 rounded-lg transition-colors\"\n                >\n                  <ChevronDown \n                    className={`w-5 h-5 transition-transform ${isMinimized ? 'rotate-180' : ''}`} \n                  />\n                </button>\n                <button\n                  onClick={() => {\n                    setIsOpen(false);\n                    setUnreadCount(0);\n                  }}\n                  className=\"p-1.5 hover:bg-white/20 rounded-lg transition-colors\"\n                >\n                  <X className=\"w-5 h-5\" />\n                </button>\n              </div>\n            </div>\n\n            {!isMinimized && (\n              <>\n                {/* Messages Area */}\n                <div className=\"flex-1 overflow-y-auto p-4 space-y-4 bg-gray-50\">\n                  {showNameInput ? (\n                    <motion.div\n                      initial={{ opacity: 0, y: 20 }}\n                      animate={{ opacity: 1, y: 0 }}\n                      className=\"bg-white rounded-xl p-6 shadow-sm\"\n                    >\n                      <h4 className=\"font-semibold mb-2 text-gray-900\">\n                        Cho mng bn! \n                      </h4>\n                      <p className=\"text-sm text-gray-600 mb-4\">\n                        Vui lng cho chng ti bit tn ca bn  bt u hi thoi.\n                      </p>\n                      <input\n                        type=\"text\"\n                        value={customerName}\n                        onChange={(e) => setCustomerName(e.target.value)}\n                        onKeyPress={(e) => e.key === 'Enter' && startConversation()}\n                        placeholder=\"Nhp tn ca bn...\"\n                        className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none mb-3\"\n                      />\n                      <button\n                        onClick={startConversation}\n                        disabled={!customerName.trim()}\n                        className=\"w-full py-2 rounded-lg font-medium text-white disabled:opacity-50 disabled:cursor-not-allowed transition-opacity\"\n                        style={{ backgroundColor: primaryColor }}\n                      >\n                        Bt u chat\n                      </button>\n                    </motion.div>\n                  ) : (\n                    messages.map((message, index) => (\n                      <motion.div\n                        key={message.id}\n                        initial={{ opacity: 0, y: 10 }}\n                        animate={{ opacity: 1, y: 0 }}\n                        transition={{ delay: index * 0.05 }}\n                        className={`flex ${message.senderType === 'CUSTOMER' ? 'justify-end' : 'justify-start'}`}\n                      >\n                        <div\n                          className={`max-w-[80%] rounded-2xl px-4 py-2.5 ${\n                            message.senderType === 'CUSTOMER'\n                              ? 'text-white rounded-br-sm'\n                              : 'bg-white text-gray-900 rounded-bl-sm shadow-sm'\n                          }`}\n                          style={{\n                            backgroundColor: message.senderType === 'CUSTOMER' ? primaryColor : undefined,\n                          }}\n                        >\n                          {message.senderType !== 'CUSTOMER' && (\n                            <div className=\"flex items-center space-x-1 mb-1\">\n                              {message.isAIGenerated ? (\n                                <Bot className=\"w-3 h-3 text-blue-500\" />\n                              ) : (\n                                <User className=\"w-3 h-3 text-gray-500\" />\n                              )}\n                              <span className=\"text-xs font-medium text-gray-600\">\n                                {message.senderName}\n                              </span>\n                            </div>\n                          )}\n                          <p className=\"text-sm leading-relaxed\">{message.content}</p>\n                          <div className=\"flex items-center justify-end space-x-1 mt-1\">\n                            <span className={`text-xs ${message.senderType === 'CUSTOMER' ? 'text-white/70' : 'text-gray-400'}`}>\n                              {new Date(message.sentAt).toLocaleTimeString('vi-VN', {\n                                hour: '2-digit',\n                                minute: '2-digit',\n                              })}\n                            </span>\n                            {message.senderType === 'CUSTOMER' && (\n                              <CheckCheck\n                                className={`w-3.5 h-3.5 ${message.isRead ? 'text-blue-300' : 'text-white/50'}`}\n                              />\n                            )}\n                          </div>\n                        </div>\n                      </motion.div>\n                    ))\n                  )}\n\n                  {isTyping && (\n                    <motion.div\n                      initial={{ opacity: 0 }}\n                      animate={{ opacity: 1 }}\n                      className=\"flex justify-start\"\n                    >\n                      <div className=\"bg-white rounded-2xl rounded-bl-sm px-4 py-3 shadow-sm\">\n                        <div className=\"flex space-x-1\">\n                          <div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '0ms' }} />\n                          <div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '150ms' }} />\n                          <div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '300ms' }} />\n                        </div>\n                      </div>\n                    </motion.div>\n                  )}\n\n                  <div ref={messagesEndRef} />\n                </div>\n\n                {/* Input Area */}\n                {!showNameInput && (\n                  <div className=\"p-4 bg-white border-t border-gray-200\">\n                    <div className=\"flex items-end space-x-2\">\n                      <button\n                        className=\"p-2 hover:bg-gray-100 rounded-lg transition-colors flex-shrink-0\"\n                        title=\"nh km file\"\n                      >\n                        <Paperclip className=\"w-5 h-5 text-gray-500\" />\n                      </button>\n\n                      <div className=\"flex-1 relative\">\n                        <input\n                          ref={inputRef}\n                          type=\"text\"\n                          value={inputMessage}\n                          onChange={(e) => {\n                            setInputMessage(e.target.value);\n                            handleTyping();\n                          }}\n                          onKeyPress={(e) => e.key === 'Enter' && sendMessage()}\n                          placeholder=\"Nhp tin nhn...\"\n                          className=\"w-full px-4 py-2.5 pr-10 border border-gray-300 rounded-xl focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none resize-none\"\n                        />\n                      </div>\n\n                      <button\n                        onClick={sendMessage}\n                        disabled={!inputMessage.trim()}\n                        className=\"p-2.5 rounded-xl text-white disabled:opacity-50 disabled:cursor-not-allowed transition-all hover:scale-105 active:scale-95 flex-shrink-0\"\n                        style={{ backgroundColor: primaryColor }}\n                      >\n                        <Send className=\"w-5 h-5\" />\n                      </button>\n                    </div>\n\n                    {/* Quick Replies */}\n                    <div className=\"mt-2 flex flex-wrap gap-2\">\n                      {messages.length === 1 && (\n                        <>\n                          <button className=\"px-3 py-1.5 text-xs bg-gray-100 hover:bg-gray-200 rounded-full transition-colors\">\n                             Gi sn phm\n                          </button>\n                          <button className=\"px-3 py-1.5 text-xs bg-gray-100 hover:bg-gray-200 rounded-full transition-colors\">\n                             Theo di n hng\n                          </button>\n                          <button className=\"px-3 py-1.5 text-xs bg-gray-100 hover:bg-gray-200 rounded-full transition-colors\">\n                             Vn chuyn\n                          </button>\n                        </>\n                      )}\n                    </div>\n                  </div>\n                )}\n              </>\n            )}\n          </motion.div>\n        )}\n      </AnimatePresence>\n    </>\n  );\n}\n","\"use client\";\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { usePresence } from './use-presence.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = \"sync\", propagate = false, anchorX = \"left\", root }) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate);\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children]);\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true);\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren);\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map());\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        pendingPresentChildren.current = presentChildren;\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i]);\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false);\n                }\n            }\n            else {\n                exitComplete.delete(key);\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n    const exitingChildren = [];\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren];\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i];\n            const key = getChildKey(child);\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child);\n                exitingChildren.push(child);\n            }\n        }\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren;\n        }\n        setRenderedChildren(onlyElements(nextChildren));\n        setDiffedChildren(presentChildren);\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null;\n    }\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext);\n    return (jsx(Fragment, { children: renderedChildren.map((child) => {\n            const key = getChildKey(child);\n            const isPresent = propagate && !isParentPresent\n                ? false\n                : presentChildren === renderedChildren ||\n                    presentKeys.includes(key);\n            const onExit = () => {\n                if (exitComplete.has(key)) {\n                    exitComplete.set(key, true);\n                }\n                else {\n                    return;\n                }\n                let isEveryExitComplete = true;\n                exitComplete.forEach((isExitComplete) => {\n                    if (!isExitComplete)\n                        isEveryExitComplete = false;\n                });\n                if (isEveryExitComplete) {\n                    forceRender?.();\n                    setRenderedChildren(pendingPresentChildren.current);\n                    propagate && safeToRemove?.();\n                    onExitComplete && onExitComplete();\n                }\n            };\n            return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\n                    ? undefined\n                    : false, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, root: root, onExitComplete: isPresent ? undefined : onExit, anchorX: anchorX, children: child }, key));\n        }) }));\n};\n\nexport { AnimatePresence };\n","\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root }) => {\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = useId();\n    let isReusedContext = true;\n    let context = useMemo(() => {\n        isReusedContext = false;\n        return {\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: (childId) => {\n                presenceChildren.set(childId, true);\n                for (const isComplete of presenceChildren.values()) {\n                    if (!isComplete)\n                        return; // can stop searching when any is incomplete\n                }\n                onExitComplete && onExitComplete();\n            },\n            register: (childId) => {\n                presenceChildren.set(childId, false);\n                return () => presenceChildren.delete(childId);\n            },\n        };\n    }, [isPresent, presenceChildren, onExitComplete]);\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    if (presenceAffectsLayout && isReusedContext) {\n        context = { ...context };\n    }\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete();\n    }, [isPresent]);\n    if (mode === \"popLayout\") {\n        children = (jsx(PopChild, { isPresent: isPresent, anchorX: anchorX, root: root, children: children }));\n    }\n    return (jsx(PresenceContext.Provider, { value: context, children: children }));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n","\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { isHTMLElement } from 'motion-dom';\nimport * as React from 'react';\nimport { useId, useRef, useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { useComposedRefs } from '../../utils/use-composed-ref.mjs';\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component {\n    getSnapshotBeforeUpdate(prevProps) {\n        const element = this.props.childRef.current;\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const parent = element.offsetParent;\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0;\n            const size = this.props.sizeRef.current;\n            size.height = element.offsetHeight || 0;\n            size.width = element.offsetWidth || 0;\n            size.top = element.offsetTop;\n            size.left = element.offsetLeft;\n            size.right = parentWidth - size.width - size.left;\n        }\n        return null;\n    }\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() { }\n    render() {\n        return this.props.children;\n    }\n}\nfunction PopChild({ children, isPresent, anchorX, root }) {\n    const id = useId();\n    const ref = useRef(null);\n    const size = useRef({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n    });\n    const { nonce } = useContext(MotionConfigContext);\n    const composedRef = useComposedRefs(ref, children?.ref);\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right } = size.current;\n        if (isPresent || !ref.current || !width || !height)\n            return;\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`;\n        ref.current.dataset.motionPopId = id;\n        const style = document.createElement(\"style\");\n        if (nonce)\n            style.nonce = nonce;\n        const parent = root ?? document.head;\n        parent.appendChild(style);\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            top: ${top}px !important;\n          }\n        `);\n        }\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style);\n            }\n        };\n    }, [isPresent]);\n    return (jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: React.cloneElement(children, { ref: composedRef }) }));\n}\n\nexport { PopChild };\n","import * as React from 'react';\n\n/**\n * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef(ref, value) {\n    if (typeof ref === \"function\") {\n        return ref(value);\n    }\n    else if (ref !== null && ref !== undefined) {\n        ref.current = value;\n    }\n}\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs(...refs) {\n    return (node) => {\n        let hasCleanup = false;\n        const cleanups = refs.map((ref) => {\n            const cleanup = setRef(ref, node);\n            if (!hasCleanup && typeof cleanup === \"function\") {\n                hasCleanup = true;\n            }\n            return cleanup;\n        });\n        // React <19 will log an error to the console if a callback ref returns a\n        // value. We don't use ref cleanups internally so this will only happen if a\n        // user's ref callback returns a value, which we only expect if they are\n        // using the cleanup functionality added in React 19.\n        if (hasCleanup) {\n            return () => {\n                for (let i = 0; i < cleanups.length; i++) {\n                    const cleanup = cleanups[i];\n                    if (typeof cleanup === \"function\") {\n                        cleanup();\n                    }\n                    else {\n                        setRef(refs[i], null);\n                    }\n                }\n            };\n        }\n    };\n}\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs(...refs) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { useComposedRefs };\n","import { Children, isValidElement } from 'react';\n\nconst getChildKey = (child) => child.key || \"\";\nfunction onlyElements(children) {\n    const filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n\nexport { getChildKey, onlyElements };\n"],"names":[],"mappings":"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AsBN,CvB9SgD,CuBwR1C,CvBxR0C,CuByRzD,KAiBE,OAAO,QvBzSc,WuBwRD,EvBpRqB,AuBoR3C,MvBpR2C,YuBoRzB,mBAAG,CAAC,KAAA,qBvBvQtB,EAAA,KAAA,CAAA,EAAuB,EAAM,GAAS,IAAI,CMgIlC,CAAA,yBN5HZ,SAAc,CAAA,yDAKQ,CAAA,CACF,wDASpB,SAAA,CACY,CAAA,CACsB,CK5DqB,gDL+DrC,EAAC,UAAA,uEAMe,QACrB,CPQC,AoBwPE,IAAA,CAAA,YbtPR,oCAOmC,8FAOlC,IAAA,EAmBX,CAAA,CAxKA,AAwKC,0DF9LC,EJJI,AD6BA,AqB9BA,EAAA,gChBQK,EAAQ,UACI,EAAA,iBAAA,AAAiB,EAAA,GAAA,EAAA,EAAA,OAAA,oBAKf,CAAA,clBfZ,CCDD,CDCa,AIFZ,ACAA,AFAA,ADAA,CYCW,ACMA,AdNV,AKAA,CJDC,AEAA,ADAA,AaCU,AXDV,CYAW,AEAA,AlBCA,AmBDA,AZAA,AMCA,AIDA,AXKA,AQEA,CLPC,AJCA,AMDA,ADAA,AFCA,AOAA,CIDC,ADAA,AFAA,ACAA,AVAV,APCA,AKAA,ACIA,CKLC,ANCU,AOmBpB,AFpBU,AFCA,ACDA,CHKC,ANJA,AYkBP,ALnBO,AREE,AGFQ,ADAA,CUAT,ACqBnB,ATrB6B,ADAA,AMCV,ACDA,APAA,AQAA,ANAA,ADAA,AFAA,AAAU,CYCC,ADmB9B,CbjBoB,AiBHY,AEAA,ADAA,AGAA,CRsBhC,APrBiC,CNGwB,ACHvB,CmBDC,AnBCA,CMIoB,CaLlB,AbKmB,CcLlB,ALCmB,CHoB/C,AGpBgD,ARDA,CAAC,AROrD,EAAA,A4BNC,E5BKmB,AagBJ,EACtB,CIvBkE,AEAA,ADAA,CDAC,ACAA,ACAA,CEAC,CAAC,IrBMjC,GACT,CoBPkD,AagBxD,ANbO,AzBMA,AIFA,ADLA,AsCGA,AnBHA,CXqBf,AOvBiE,CIElD,CXsB5B,WbbO,IaaQ,EACf,MbdO,CacA,EACP,IbfO,EACE,EAAA,SacQ,EACjB,sBAAsB,EACtB,OAAO,GACR,MAAM,0BAA0B,CAAC,gDqCFtB,CAAA,OAAA,aAAA,CAAA,CAAA,2BISL,IAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,yBAMC,IAAA,CAAA,2BAEN,CHLC,A9CsDA,A8BYA,CmB7DK,UAAA,CAAa,EAAA,MAAA,GACb,MAAA,CAAA,EACA,6JfhBC,EAAA,cASyB,CAAA,mDAKrB,C1BeD,A0BfE,CAAA,EAAA,EAAA,EAAiB,EAAA,EAAK,IACd,KAAK,CAAA,EAAA,CAAgB,CAAC,EAAA,SAGnC,sBAcC,SAED,IAAI,CAAA,KAAM,CAAA,CAAO,CAAC,EAAS,CAAE,CAAM,CAAC,EAAS,C/BDL,A+BCM,CAAC,C/BA5C,CAAC,MYlBmD,CAAC,CAAC,oDmBuBtD,CHiDW,gDGVH,CAAA,IAAA,sCApCL,CAAW,CAAE,CAAA,yHACsB,EAAA,eACjC,CAAA,GAAA,OAAA,CAAA,SAAA,CAAA,0BAEoB,EAAA,CAC3B,GAAA,CAAA,CAAA,EAAqB,GAAA,EAAkB,iDAEnC,cJyFS,IAAA,aIlFiB,oCAQhB,mBAAmB,CAAA,EAAA,SACI,GAIlC,qCAWe,CAA1B,SAAA,CAAA,8BACsB,yBACO,CRoEN,CDnDQ,ACmDP,WQnER,OAAO,CAAA,6DAImB,CAAC,GZqHsB,oBYjH3C,GAAA,CAAA,IAGb,IAEX,CA3DA,AA2DC,cxBlHC,CAAqB,CgBLiC,C7BGC,A6BHA,C7BGC,EKKvB,AyBVyB,CAAC,AIgBjC,ErBPnB,gBAAA,eA6BP,CAAA,qDAMkB,EAAA,WAAkB,GAClC,cACmB,OAAO,CAAA,SAAA,CAAgB,EACxC,IAAA,sBAAA,EAAA,EAAA,MAAA,CAAA,EAA8B,GAAA,EAAA,EAAU,EAAA,cAEhB,MAAM,CAAC,GACmC,CAAA,EAAJ,EAAE,CAAC,CAAC,oBAIxC,EAAA,KAGvB,uCQvDa,CQKsC,A5BM3D,AoBX2C,AHYkC,AeH5E,AZuHI,SAAA,EAAA,CAA6C,CAAE,AmB4ItC,CnB5IsD,EIqJ/C,AJpJpB,EAAa,CoB2WH,KpB3WS,EAAI,+BAIV,KAAK,KAAK,CAAA,GACjB,MAAO,EAAK,cAOd,CrB6EqB,gDAAA,MAAA,CqB7E4B,EAAS,MAAD,AAAO,CAAE,CACnE,CAAC,WAIK,KAAA,KAAU,CAAA,WACL,SAED,IAAA,CAAO,6BACC,CEvBH,AkBgYJ,AbzUQ,IP/BT,UAAA,CAAA,EAAA,MAAA,YACW,gEN3JhB,CUCK,AMyBP,AdzBG,AbI4C,A6BPxC,CRGA,iBAAA,EAAA,K5BLf,EAAA,EAAA,CAAA,CAAA,QiDQA,IAAM,EAAgB,gCAEtB,SAAS,EAAgB,CAAG,EAC1B,OAAO,CAAe,CAAC,EAAI,UAAU,CAAC,GAAG,AAC3C,CAEA,CAFE,GAEI,EAAkB,CACtB,UACA,EAJkB,QAKlB,UACA,UACA,UACA,UACA,UACA,UACA,MACA,MACA,MACA,UACA,MACA,MACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,GACA,GACA,MACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,OACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACD,CjD7KD,IAAA,EAAA,EAAA,CAAA,CAAA,QAUA,IAAM,EAAqB,CACzB,KAAM,CACJ,MAAO,AAAC,GAAS,EAAK,KAAK,AAC7B,EACA,SAAU,CACR,MAAO,AAAC,GAAS,IA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","ignoreList":[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,58,61,62,63,64,65]}