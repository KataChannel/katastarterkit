{"version":3,"sources":["turbopack:///[project]/node_modules/.bun/@heroicons+react@2.2.0+55f3e2d4ca346cd1/node_modules/@heroicons/react/24/outline/esm/XMarkIcon.js","turbopack:///[project]/frontend/src/lib/graphql/todo-queries.ts","turbopack:///[project]/frontend/src/hooks/useTodos.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/react/hooks/useSubscription.ts","turbopack:///[project]/node_modules/.bun/@apollo+client@3.14.0+e60a82a7e355cd63/node_modules/@apollo/src/react/hooks/internal/useDeepMemo.ts","turbopack:///[project]/frontend/src/types/todo.ts"],"sourcesContent":["import * as React from \"react\";\nfunction XMarkIcon({\n  title,\n  titleId,\n  ...props\n}, svgRef) {\n  return /*#__PURE__*/React.createElement(\"svg\", Object.assign({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    strokeWidth: 1.5,\n    stroke: \"currentColor\",\n    \"aria-hidden\": \"true\",\n    \"data-slot\": \"icon\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    d: \"M6 18 18 6M6 6l12 12\"\n  }));\n}\nconst ForwardRef = /*#__PURE__*/ React.forwardRef(XMarkIcon);\nexport default ForwardRef;","import { gql } from '@apollo/client';\n\n// Todo Fragments\nexport const TASK_FRAGMENT = gql`\n  fragment TaskFragment on Task {\n    id\n    title\n    description\n    category\n    priority\n    status\n    dueDate\n    createdAt\n    updatedAt\n    userId\n    author {\n      id\n      username\n      firstName\n      lastName\n      avatar\n    }\n  }\n`;\n\nexport const TASK_MEDIA_FRAGMENT = gql`\n  fragment TaskMediaFragment on TaskMedia {\n    id\n    filename\n    url\n    type\n    size\n    mimeType\n    caption\n    createdAt\n    updatedAt\n    taskId\n    uploadedBy\n    uploader {\n      id\n      username\n      firstName\n      lastName\n      avatar\n    }\n  }\n`;\n\nexport const TASK_SHARE_FRAGMENT = gql`\n  fragment TaskShareFragment on TaskShare {\n    id\n    permission\n    shareToken\n    expiresAt\n    isActive\n    createdAt\n    updatedAt\n    taskId\n    sharedBy\n    sharedByUser {\n      id\n      username\n      firstName\n      lastName\n      avatar\n    }\n    sharedWith\n    sharedWithUser {\n      id\n      username\n      firstName\n      lastName\n      avatar\n    }\n  }\n`;\n\nexport const TASK_COMMENT_FRAGMENT = gql`\n  fragment TaskCommentFragment on TaskComment {\n    id\n    content\n    createdAt\n    updatedAt\n    taskId\n    userId\n    user {\n      id\n      username\n      firstName\n      lastName\n      avatar\n    }\n  }\n`;\n\nexport const NOTIFICATION_FRAGMENT = gql`\n  fragment NotificationFragment on Notification {\n    id\n    type\n    title\n    message\n    isRead\n    createdAt\n    userId\n    user {\n      id\n      username\n      firstName\n      lastName\n      avatar\n    }\n  }\n`;\n\n// Todo Queries\nexport const GET_TASKS = gql`\n  ${TASK_FRAGMENT}\n  query GetTasks($filters: TaskFilterInput) {\n    getTasks(filters: $filters) {\n      ...TaskFragment\n    }\n  }\n`;\n\nexport const GET_TASK_BY_ID = gql`\n  ${TASK_FRAGMENT}\n  ${TASK_MEDIA_FRAGMENT}\n  ${TASK_SHARE_FRAGMENT}\n  ${TASK_COMMENT_FRAGMENT}\n  query GetTaskById($id: ID!) {\n    getTaskById(id: $id) {\n      ...TaskFragment\n      media {\n        ...TaskMediaFragment\n      }\n      shares {\n        ...TaskShareFragment\n      }\n      comments {\n        ...TaskCommentFragment\n      }\n    }\n  }\n`;\n\nexport const GET_SHARED_TASKS = gql`\n  ${TASK_FRAGMENT}\n  query GetSharedTasks($filters: TaskFilterInput) {\n    getSharedTasks(filters: $filters) {\n      ...TaskFragment\n    }\n  }\n`;\n\n// Todo Mutations\nexport const CREATE_TASK = gql`\n  ${TASK_FRAGMENT}\n  mutation CreateTask($input: CreateTaskInput!) {\n    createTask(input: $input) {\n      ...TaskFragment\n    }\n  }\n`;\n\nexport const UPDATE_TASK = gql`\n  ${TASK_FRAGMENT}\n  mutation UpdateTask($input: UpdateTaskInput!) {\n    updateTask(input: $input) {\n      ...TaskFragment\n    }\n  }\n`;\n\nexport const DELETE_TASK = gql`\n  mutation DeleteTask($id: ID!) {\n    deleteTask(id: $id)\n  }\n`;\n\nexport const SHARE_TASK = gql`\n  ${TASK_SHARE_FRAGMENT}\n  mutation ShareTask($input: ShareTaskInput!) {\n    shareTask(input: $input) {\n      ...TaskShareFragment\n    }\n  }\n`;\n\nexport const CREATE_TASK_COMMENT = gql`\n  ${TASK_COMMENT_FRAGMENT}\n  mutation CreateTaskComment($input: CreateTaskCommentInput!) {\n    createTaskComment(input: $input) {\n      ...TaskCommentFragment\n    }\n  }\n`;\n\n// Todo Subscriptions\nexport const TASK_CREATED_SUBSCRIPTION = gql`\n  ${TASK_FRAGMENT}\n  subscription TaskCreated {\n    taskCreated {\n      ...TaskFragment\n    }\n  }\n`;\n\nexport const TASK_UPDATED_SUBSCRIPTION = gql`\n  ${TASK_FRAGMENT}\n  subscription TaskUpdated {\n    taskUpdated {\n      ...TaskFragment\n    }\n  }\n`;\n\nexport const TASK_COMMENT_CREATED_SUBSCRIPTION = gql`\n  ${TASK_COMMENT_FRAGMENT}\n  subscription TaskCommentCreated {\n    taskCommentCreated {\n      ...TaskCommentFragment\n    }\n  }\n`;\n","import { useState, useEffect } from 'react';\nimport { useQuery, useMutation, useSubscription } from '@apollo/client';\nimport {\n  GET_TASKS,\n  GET_TASK_BY_ID,\n  GET_SHARED_TASKS,\n  CREATE_TASK,\n  UPDATE_TASK,\n  DELETE_TASK,\n  SHARE_TASK,\n  CREATE_TASK_COMMENT,\n  TASK_CREATED_SUBSCRIPTION,\n  TASK_UPDATED_SUBSCRIPTION,\n  TASK_COMMENT_CREATED_SUBSCRIPTION,\n} from '../lib/graphql/todo-queries';\nimport {\n  Task,\n  TaskFilterInput,\n  CreateTaskInput,\n  UpdateTaskInput,\n  ShareTaskInput,\n  CreateTaskCommentInput,\n} from '../types/todo';\n\n// Hook for fetching user's tasks\nexport const useTasks = (filters?: TaskFilterInput) => {\n  const { data, loading, error, refetch } = useQuery(GET_TASKS, {\n    variables: { filters },\n    fetchPolicy: 'cache-and-network',\n  });\n\n  return {\n    tasks: data?.getTasks || [],\n    loading,\n    error,\n    refetch,\n  };\n};\n\n// Hook for fetching shared tasks\nexport const useSharedTasks = (filters?: TaskFilterInput) => {\n  const { data, loading, error, refetch } = useQuery(GET_SHARED_TASKS, {\n    variables: { filters },\n    fetchPolicy: 'cache-and-network',\n  });\n\n  return {\n    sharedTasks: data?.getSharedTasks || [],\n    loading,\n    error,\n    refetch,\n  };\n};\n\n// Hook for fetching a single task with details\nexport const useTask = (taskId: string) => {\n  const { data, loading, error, refetch } = useQuery(GET_TASK_BY_ID, {\n    variables: { id: taskId },\n    skip: !taskId,\n    fetchPolicy: 'cache-and-network',\n  });\n\n  return {\n    task: data?.getTaskById,\n    loading,\n    error,\n    refetch,\n  };\n};\n\n// Hook for task mutations\nexport const useTaskMutations = () => {\n  const [createTask, { loading: creating }] = useMutation(CREATE_TASK, {\n    refetchQueries: [GET_TASKS, GET_SHARED_TASKS],\n  });\n\n  const [updateTask, { loading: updating }] = useMutation(UPDATE_TASK, {\n    refetchQueries: [GET_TASKS, GET_SHARED_TASKS, GET_TASK_BY_ID],\n  });\n\n  const [deleteTask, { loading: deleting }] = useMutation(DELETE_TASK, {\n    refetchQueries: [GET_TASKS, GET_SHARED_TASKS],\n  });\n\n  const [shareTask, { loading: sharing }] = useMutation(SHARE_TASK, {\n    refetchQueries: [GET_TASK_BY_ID],\n  });\n\n  const [createComment, { loading: commenting }] = useMutation(CREATE_TASK_COMMENT, {\n    refetchQueries: [GET_TASK_BY_ID],\n  });\n\n  const handleCreateTask = async (input: CreateTaskInput) => {\n    try {\n      const result = await createTask({ variables: { input } });\n      return result.data?.createTask;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  const handleUpdateTask = async (input: UpdateTaskInput) => {\n    try {\n      const result = await updateTask({ variables: { input } });\n      return result.data?.updateTask;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  const handleDeleteTask = async (id: string) => {\n    try {\n      await deleteTask({ variables: { id } });\n      return true;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  const handleShareTask = async (input: ShareTaskInput) => {\n    try {\n      const result = await shareTask({ variables: { input } });\n      return result.data?.shareTask;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  const handleCreateComment = async (input: CreateTaskCommentInput) => {\n    try {\n      const result = await createComment({ variables: { input } });\n      return result.data?.createTaskComment;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  return {\n    createTask: handleCreateTask,\n    updateTask: handleUpdateTask,\n    deleteTask: handleDeleteTask,\n    shareTask: handleShareTask,\n    createComment: handleCreateComment,\n    loading: {\n      creating,\n      updating,\n      deleting,\n      sharing,\n      commenting,\n    },\n  };\n};\n\n// Hook for real-time task updates\nexport const useTaskSubscriptions = () => {\n  const [newTasks, setNewTasks] = useState<Task[]>([]);\n  const [updatedTasks, setUpdatedTasks] = useState<Task[]>([]);\n\n  useSubscription(TASK_CREATED_SUBSCRIPTION, {\n    onData: ({ data }) => {\n      if (data.data?.taskCreated) {\n        setNewTasks(prev => [data.data.taskCreated, ...prev]);\n      }\n    },\n  });\n\n  useSubscription(TASK_UPDATED_SUBSCRIPTION, {\n    onData: ({ data }) => {\n      if (data.data?.taskUpdated) {\n        setUpdatedTasks(prev => [data.data.taskUpdated, ...prev]);\n      }\n    },\n  });\n\n  useSubscription(TASK_COMMENT_CREATED_SUBSCRIPTION, {\n    onData: ({ data }) => {\n      console.log('New comment:', data.data?.taskCommentCreated);\n    },\n  });\n\n  return {\n    newTasks,\n    updatedTasks,\n    clearNotifications: () => {\n      setNewTasks([]);\n      setUpdatedTasks([]);\n    },\n  };\n};\n\n// Hook for task filtering\nexport const useTaskFilters = () => {\n  const [filters, setFilters] = useState<TaskFilterInput>({});\n\n  const updateFilter = (key: keyof TaskFilterInput, value: any) => {\n    setFilters(prev => ({\n      ...prev,\n      [key]: value,\n    }));\n  };\n\n  const clearFilters = () => {\n    setFilters({});\n  };\n\n  const resetFilter = (key: keyof TaskFilterInput) => {\n    setFilters(prev => {\n      const newFilters = { ...prev };\n      delete newFilters[key];\n      return newFilters;\n    });\n  };\n\n  return {\n    filters,\n    updateFilter,\n    clearFilters,\n    resetFilter,\n    hasActiveFilters: Object.keys(filters).length > 0,\n  };\n};\n\n// Hook aliases for backward compatibility\nexport const useTaskById = (id: string) => useTask(id);\n\nexport const useCreateTask = () => {\n  const { createTask, loading } = useTaskMutations();\n  return {\n    createTask,\n    loading: loading.creating,\n  };\n};\n\nexport const useUpdateTask = () => {\n  const [updateTaskMutation, { loading, error }] = useMutation(UPDATE_TASK, {\n    refetchQueries: [GET_TASKS, GET_SHARED_TASKS, GET_TASK_BY_ID],\n  });\n\n  return {\n    updateTask: updateTaskMutation,\n    loading,\n    error,\n  };\n};\n\nexport const useDeleteTask = () => {\n  const [deleteTaskMutation, { loading, error }] = useMutation(DELETE_TASK, {\n    refetchQueries: [GET_TASKS, GET_SHARED_TASKS],\n  });\n\n  return {\n    deleteTask: deleteTaskMutation,\n    loading,\n    error,\n  };\n};\n","import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  NoInfer,\n  SubscriptionHookOptions,\n  SubscriptionResult,\n} from \"../types/types.js\";\nimport type {\n  ApolloClient,\n  DefaultContext,\n  ErrorPolicy,\n  FetchPolicy,\n  FetchResult,\n  OperationVariables,\n} from \"../../core/index.js\";\nimport { ApolloError, Observable } from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useDeepMemo } from \"./internal/useDeepMemo.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { toApolloError } from \"./useQuery.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\nimport type { MaybeMasked } from \"../../masking/index.js\";\n\n/**\n * > Refer to the [Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/) section for a more in-depth overview of `useSubscription`.\n *\n * @example\n * ```jsx\n * const COMMENTS_SUBSCRIPTION = gql`\n *   subscription OnCommentAdded($repoFullName: String!) {\n *     commentAdded(repoFullName: $repoFullName) {\n *       id\n *       content\n *     }\n *   }\n * `;\n *\n * function DontReadTheComments({ repoFullName }) {\n *   const {\n *     data: { commentAdded },\n *     loading,\n *   } = useSubscription(COMMENTS_SUBSCRIPTION, { variables: { repoFullName } });\n *   return <h4>New comment: {!loading && commentAdded.content}</h4>;\n * }\n * ```\n * @remarks\n * #### Consider using `onData` instead of `useEffect`\n *\n * If you want to react to incoming data, please use the `onData` option instead of `useEffect`.\n * State updates you make inside a `useEffect` hook might cause additional rerenders, and `useEffect` is mostly meant for side effects of rendering, not as an event handler.\n * State updates made in an event handler like `onData` might - depending on the React version - be batched and cause only a single rerender.\n *\n * Consider the following component:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const { data, error, loading } = useSubscription(query);\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *\n *   useEffect(() => {\n *     setAccumulatedData((prev) => [...prev, data]);\n *   }, [data]);\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * Instead of using `useEffect` here, we can re-write this component to use the `onData` callback function accepted in `useSubscription`'s `options` object:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *   const { data, error, loading } = useSubscription(\n *     query,\n *     {\n *       onData({ data }) {\n *         setAccumulatedData((prev) => [...prev, data])\n *       }\n *     }\n *   );\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * > ⚠️ **Note:** The `useSubscription` option `onData` is available in Apollo Client >= 3.7. In previous versions, the equivalent option is named `onSubscriptionData`.\n *\n * Now, the first message will be added to the `accumulatedData` array since `onData` is called _before_ the component re-renders. React 18 automatic batching is still in effect and results in a single re-render, but with `onData` we can guarantee each message received after the component mounts is added to `accumulatedData`.\n *\n * @since 3.0.0\n * @param subscription - A GraphQL subscription document parsed into an AST by `gql`.\n * @param options - Options to control how the subscription is executed.\n * @returns Query result object\n */\nexport function useSubscription<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SubscriptionHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>\n  > = Object.create(null)\n) {\n  const hasIssuedDeprecationWarningRef = React.useRef(false);\n  const client = useApolloClient(options.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n\n  if (!hasIssuedDeprecationWarningRef.current) {\n    // eslint-disable-next-line react-compiler/react-compiler\n    hasIssuedDeprecationWarningRef.current = true;\n\n    if (options.onSubscriptionData) {\n      invariant.warn(\n        options.onData ?\n          \"'useSubscription' supports only the 'onSubscriptionData' or 'onData' option, but not both. Only the 'onData' option will be used.\"\n        : \"[useSubscription]: `onSubscriptionData` is deprecated and will be removed in Apollo Client 4.0. Please use the 'onData' option instead.\"\n      );\n    }\n\n    if (options.onSubscriptionComplete) {\n      invariant.warn(\n        options.onComplete ?\n          \"'useSubscription' supports only the 'onSubscriptionComplete' or 'onComplete' option, but not both. Only the 'onComplete' option will be used.\"\n        : \"[useSubscription]: `onSubscriptionComplete` is deprecated and will be removed in Apollo Client 4.0. Please use the 'onComplete' option instead.\"\n      );\n    }\n  }\n\n  const {\n    skip,\n    fetchPolicy,\n    errorPolicy,\n    shouldResubscribe,\n    context,\n    extensions,\n    ignoreResults,\n  } = options;\n  const variables = useDeepMemo(() => options.variables, [options.variables]);\n\n  const recreate = () =>\n    createSubscription(\n      client,\n      subscription,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      context,\n      extensions\n    );\n\n  let [observable, setObservable] = React.useState(\n    options.skip ? null : recreate\n  );\n\n  const recreateRef = React.useRef(recreate);\n  useIsomorphicLayoutEffect(() => {\n    recreateRef.current = recreate;\n  });\n\n  if (skip) {\n    if (observable) {\n      setObservable((observable = null));\n    }\n  } else if (\n    !observable ||\n    ((client !== observable.__.client ||\n      subscription !== observable.__.query ||\n      fetchPolicy !== observable.__.fetchPolicy ||\n      errorPolicy !== observable.__.errorPolicy ||\n      !equal(variables, observable.__.variables)) &&\n      (typeof shouldResubscribe === \"function\" ?\n        !!shouldResubscribe(options!)\n      : shouldResubscribe) !== false)\n  ) {\n    setObservable((observable = recreate()));\n  }\n\n  const optionsRef = React.useRef(options);\n  React.useEffect(() => {\n    optionsRef.current = options;\n  });\n\n  const fallbackLoading = !skip && !ignoreResults;\n  const fallbackResult = React.useMemo<SubscriptionResult<TData, TVariables>>(\n    () => ({\n      loading: fallbackLoading,\n      error: void 0,\n      data: void 0,\n      variables,\n    }),\n    [fallbackLoading, variables]\n  );\n\n  const ignoreResultsRef = React.useRef(ignoreResults);\n  useIsomorphicLayoutEffect(() => {\n    // We cannot reference `ignoreResults` directly in the effect below\n    // it would add a dependency to the `useEffect` deps array, which means the\n    // subscription would be recreated if `ignoreResults` changes\n    // As a result, on resubscription, the last result would be re-delivered,\n    // rendering the component one additional time, and re-triggering `onData`.\n    // The same applies to `fetchPolicy`, which results in a new `observable`\n    // being created. We cannot really avoid it in that case, but we can at least\n    // avoid it for `ignoreResults`.\n    ignoreResultsRef.current = ignoreResults;\n  });\n\n  const ret = useSyncExternalStore<SubscriptionResult<TData, TVariables>>(\n    React.useCallback(\n      (update) => {\n        if (!observable) {\n          return () => {};\n        }\n\n        let subscriptionStopped = false;\n        const variables = observable.__.variables;\n        const client = observable.__.client;\n        const subscription = observable.subscribe({\n          next(fetchResult) {\n            if (subscriptionStopped) {\n              return;\n            }\n\n            const result = {\n              loading: false,\n              // TODO: fetchResult.data can be null but SubscriptionResult.data\n              // expects TData | undefined only\n              data: fetchResult.data!,\n              error: toApolloError(fetchResult),\n              variables,\n            };\n            observable.__.setResult(result);\n            if (!ignoreResultsRef.current) update();\n\n            if (result.error) {\n              optionsRef.current.onError?.(result.error);\n            } else if (optionsRef.current.onData) {\n              optionsRef.current.onData({\n                client,\n                data: result,\n              });\n            } else if (optionsRef.current.onSubscriptionData) {\n              optionsRef.current.onSubscriptionData({\n                client,\n                subscriptionData: result,\n              });\n            }\n          },\n          error(error) {\n            error =\n              error instanceof ApolloError ? error : (\n                new ApolloError({ protocolErrors: [error] })\n              );\n            if (!subscriptionStopped) {\n              observable.__.setResult({\n                loading: false,\n                data: void 0,\n                error,\n                variables,\n              });\n              if (!ignoreResultsRef.current) update();\n              optionsRef.current.onError?.(error);\n            }\n          },\n          complete() {\n            if (!subscriptionStopped) {\n              if (optionsRef.current.onComplete) {\n                optionsRef.current.onComplete();\n              } else if (optionsRef.current.onSubscriptionComplete) {\n                optionsRef.current.onSubscriptionComplete();\n              }\n            }\n          },\n        });\n\n        return () => {\n          // immediately stop receiving subscription values, but do not unsubscribe\n          // until after a short delay in case another useSubscription hook is\n          // reusing the same underlying observable and is about to subscribe\n          subscriptionStopped = true;\n          setTimeout(() => {\n            subscription.unsubscribe();\n          });\n        };\n      },\n      [observable]\n    ),\n    () =>\n      observable && !skip && !ignoreResults ?\n        observable.__.result\n      : fallbackResult,\n    () => fallbackResult\n  );\n\n  const restart = React.useCallback(() => {\n    invariant(\n      !optionsRef.current.skip,\n      \"A subscription that is skipped cannot be restarted.\"\n    );\n    setObservable(recreateRef.current());\n  }, [optionsRef, recreateRef]);\n\n  return React.useMemo(() => ({ ...ret, restart }), [ret, restart]);\n}\n\nfunction createSubscription<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  client: ApolloClient<any>,\n  query: TypedDocumentNode<TData, TVariables>,\n  variables: TVariables | undefined,\n  fetchPolicy: FetchPolicy | undefined,\n  errorPolicy: ErrorPolicy | undefined,\n  context: DefaultContext | undefined,\n  extensions: Record<string, any> | undefined\n) {\n  const options = {\n    query,\n    variables,\n    fetchPolicy,\n    errorPolicy,\n    context,\n    extensions,\n  };\n  const __ = {\n    ...options,\n    client,\n    result: {\n      loading: true,\n      data: void 0,\n      error: void 0,\n      variables,\n    } as SubscriptionResult<TData, TVariables>,\n    setResult(result: SubscriptionResult<TData, TVariables>) {\n      __.result = result;\n    },\n  };\n\n  let observable: Observable<FetchResult<MaybeMasked<TData>>> | null = null;\n  return Object.assign(\n    new Observable<FetchResult<MaybeMasked<TData>>>((observer) => {\n      // lazily start the subscription when the first observer subscribes\n      // to get around strict mode\n      if (!observable) {\n        observable = client.subscribe(options);\n      }\n      const sub = observable.subscribe(observer);\n      return () => sub.unsubscribe();\n    }),\n    {\n      /**\n       * A tracking object to store details about the observable and the latest result of the subscription.\n       */\n      __,\n    }\n  );\n}\n","import type { DependencyList } from \"react\";\nimport * as React from \"rehackt\";\nimport { equal } from \"@wry/equality\";\n\nexport function useDeepMemo<TValue>(\n  memoFn: () => TValue,\n  deps: DependencyList\n) {\n  const ref = React.useRef<{ deps: DependencyList; value: TValue }>(void 0);\n\n  if (!ref.current || !equal(ref.current.deps, deps)) {\n    // eslint-disable-next-line react-compiler/react-compiler\n    ref.current = { value: memoFn(), deps };\n  }\n\n  return ref.current.value;\n}\n","export enum TaskCategory {\n  WORK = 'WORK',\n  PERSONAL = 'PERSONAL',\n  STUDY = 'STUDY',\n}\n\nexport enum TaskPriority {\n  HIGH = 'HIGH',\n  MEDIUM = 'MEDIUM',\n  LOW = 'LOW',\n}\n\nexport enum TaskStatus {\n  PENDING = 'PENDING',\n  IN_PROGRESS = 'IN_PROGRESS',\n  COMPLETED = 'COMPLETED',\n  CANCELLED = 'CANCELLED',\n}\n\nexport enum SharePermission {\n  VIEW = 'VIEW',\n  EDIT = 'EDIT',\n  ADMIN = 'ADMIN',\n}\n\nexport enum MediaType {\n  IMAGE = 'IMAGE',\n  VIDEO = 'VIDEO',\n  DOCUMENT = 'DOCUMENT',\n}\n\nexport interface User {\n  id: string;\n  username: string;\n  firstName?: string;\n  lastName?: string;\n  avatar?: string;\n}\n\n// Task comment interface\nexport interface TaskComment {\n  id: string;\n  content: string;\n  taskId: string;\n  authorId: string;\n  author: User;\n  parentId?: string;\n  replies?: TaskComment[];\n  createdAt: string;\n  updatedAt: string;\n}\n\n// Task media/attachment interface\nexport interface TaskMedia {\n  id: string;\n  filename: string;\n  fileUrl: string;\n  url?: string; // For backward compatibility\n  fileSize?: number;\n  size?: number; // For backward compatibility\n  mimeType: string;\n  type?: MediaType; // For backward compatibility\n  caption?: string;\n  taskId: string;\n  uploadedById: string;\n  uploadedBy: User;\n  createdAt: string;\n}\n\n// Task sharing interface\nexport interface TaskShare {\n  id: string;\n  taskId: string;\n  userId: string;\n  user: User;\n  permission: SharePermission;\n  sharedById: string;\n  sharedBy: User;\n  createdAt: string;\n}\n\n// Share permission enum\nexport enum SharePermission {\n  READ = 'READ',\n  WRITE = 'WRITE',\n}\n\n// Updated Task interface with relationships\nexport interface Task {\n  id: string;\n  title: string;\n  description?: string;\n  status: TaskStatus;\n  priority: TaskPriority;\n  dueDate?: string;\n  category?: string;\n  authorId: string;\n  author: User;\n  createdAt: string;\n  updatedAt: string;\n  comments?: TaskComment[];\n  media?: TaskMedia[];\n  shares?: TaskShare[];\n}\n\n// Input Types\nexport interface CreateTaskInput {\n  title: string;\n  description?: string;\n  category: TaskCategory;\n  priority: TaskPriority;\n  dueDate?: string;\n}\n\nexport interface UpdateTaskInput {\n  id: string;\n  title?: string;\n  description?: string;\n  category?: TaskCategory;\n  priority?: TaskPriority;\n  status?: TaskStatus;\n  dueDate?: string;\n}\n\nexport interface TaskFilterInput {\n  category?: TaskCategory;\n  priority?: TaskPriority;\n  status?: TaskStatus;\n  search?: string;\n  dueBefore?: string;\n  dueAfter?: string;\n}\n\nexport interface ShareTaskInput {\n  taskId: string;\n  sharedWithId: string;\n  permission: SharePermission;\n}\n\nexport interface CreateTaskCommentInput {\n  taskId: string;\n  content: string;\n}\n\nexport interface Notification {\n  id: string;\n  type: string;\n  title: string;\n  message: string;\n  isRead: boolean;\n  createdAt: string;\n  userId: string;\n  user: User;\n}\n"],"names":[],"mappings":"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","ignoreList":[0,3,4]}